<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解合约升级(1) - 概括</title>
    <url>/2022/07/27/Ethereum-2022-07-27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-1-%E6%A6%82%E6%8B%AC/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(1) - 概括 </blockquote>

<a id="more"></a>
<p>这篇文章开始，我将用一个系列的文章详细介绍智能合约升级原理，尽量会以 Solidity 初学者的角度来探究，同时也能帮助自己更加巩固对这个知识点的了解。</p>
<h2 id="了解合约升级"><a href="#了解合约升级" class="headerlink" title="了解合约升级"></a>了解合约升级</h2><p>我们知道，区块链上的内容都是不可变的，一旦数据上链之后，那么便是不可修改的。智能合约也是一样，部署在链上之后，合约本身的代码便是不可修改的，如果部署之后发现了合约中有 bug，那就完全没办法，只能另外部署一份合约了。其实这样也是有好处的，因为如果一份合约没有问题的话，那么也就代表它能够一直正确运行，而没有人能够修改合约的运行逻辑，真正达到的 <code>Code is law</code> 的理念。</p>
<p>但是，作为项目开发而言，这样就不是很友好了。首先，如果代码中有 bug，无法修改，如果这个 bug 是关乎用户 token 转账等场景，可能会造成用户的资产永久锁死在合约中。其次，项目发展是一个长期的过程，不可能一开始就能把所有的功能都考虑到。如果后期想要添加功能，那么就只能更换合约，并且需要用户手动操作，将旧合约中的数据（资产）转移到新合约中，这样可能会造成用户的困扰。</p>
<p>那么我们自然想到，合约开发能不能也可以像传统互联网开发那样，有问题随时修改，并且对于用户是无感知的呢？这时就引入了我们要介绍的合约升级的概念。</p>
<h2 id="合约如何升级"><a href="#合约如何升级" class="headerlink" title="合约如何升级"></a>合约如何升级</h2><p>首先，我们来看传统的合约调用逻辑：</p>
<p><img src="/upload_image/2022-07-27-深入理解合约升级1/1.png" alt></p>
<p>用户最初与旧合约进行交互，如果更新了新的合约，那么用户需要更换交互地址，迁移数据。新旧合约分别保存了各自的数据，两者互不关联。那么如果我们想要做成前面说的无感知升级，该怎么操作呢？</p>
<p>我们知道，合约本身是不能更改的，那么我们考虑，能不能用一种代理人的方式，也就是说，我们去调用一个代理合约，代理合约将我们发送的请求，也就是函数调用，转发给实际执行逻辑的合约，当需要更换新合约的时候，只需要在代理合约转发请求时，将请求发送给新的合约地址就可以了。而用户对这一切是不知道的，因为用户自始至终都是与代理合约做交互。来看看一个简单的图示：</p>
<p><img src="/upload_image/2022-07-27-深入理解合约升级1/2.png" alt></p>
<p>如图中所示，我们在实际执行逻辑的合约前面加了一个代理合约，用户一直是与代理合约交互，开始时代理合约将请求转发给旧合约，当需要升级时，部署一个新的合约，同时代理合约会将请求转发给新合约，这样对于用户来说就是无感知的。</p>
<p>但是这里还有一个问题，我们前面说到，在传统合约模式中，用户是需要将数据从旧合约迁移到新合约中的，现在加了一个代理合约，请求是转发过去了，那么数据怎么办呢，用户的 token 不是还在旧合约中吗？此时，我们应该想到，其实代理合约不仅仅是起到转发请求的作用，而且承载了所有的合约数据，包括用户的 token 也都是存放在代理合约中，右边的逻辑合约也就仅仅是实现逻辑而已，不保存任何数据：</p>
<p><img src="/upload_image/2022-07-27-深入理解合约升级1/3.png" alt></p>
<p>这样一来，我们就能随意更换逻辑合约，而不用担心数据迁移问题。也就是说，我们已经做到了和传统互联网开发一样，能够对合约进行升级。这样对于用户体验和项目方维护来说都是一个很大的优点。</p>
<p>那么既然合约升级这么好，为什么不是所有的项目都采用可升级合约呢？前面我们说到，可升级与不可升级之间，各自都是有利有弊的，这取决于项目方的权衡。</p>
<p>对于可升级合约来说，好处是优化用户体验，利于项目方维护。而坏处就是项目方可以随时更改后面的逻辑合约作恶，将用户的 token 转走，这对于用户来说是无能为力的。（现在有很多项目的升级权限都是由多签管理，但是仍然存在风险）</p>
<p>相对应的，对于不可升级合约，一切都写在了代码中，真正实现了 <code>Code is law</code> 的理念，即使项目方自己也不能随意更改合约，操纵用户资产。例如 <code>Uniswap</code> 的合约都是不可升级的，用户在与其进行交互时，是可以放心将资产放在上面的。但是代价就是项目开发时要做到各种测试，包括项目审计也要做很多遍，因为一旦部署，就无法更改了。（这里并不是说使用了可升级合约就可以省去这些安全步骤，安全一定是合约开发的重中之重，只是说可升级合约即使发现了 bug，也可以后期修改）</p>
<p>综合而言，两者都有各自的优缺点，取决于项目方的考虑与权衡。但要注意的是，并不是说不可升级合约就一定是安全的项目方，而可升级的合约就一定是是不安全的项目方。项目方之间差距也很大，例如 <a href="https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#code" target="_blank" rel="noopener">USDC</a> 就是可升级合约，但是 USDC 几乎可以说是不会作恶的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过代理合约模式可以实现合约升级，对于用户是无感知的。同时合约升级也是有利有弊，需要针对具体场景判断选择哪种模式。</p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/RZscMYGkeGTY8z6ccHseY8HKu-ER3pX0mFYoWXRqXQ0" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解合约升级(2) - Solidity 内存布局</title>
    <url>/2022/07/28/Ethereum-2022-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-2-Solidity-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(2) - Solidity 内存布局 </blockquote>

<a id="more"></a>
<p>这篇文章我们来学习一下 Solidity 的内存布局。首先我们需要明白，我们这里谈到的内存是 Solidity 合约中的状态变量，而不是在函数方法中定义的临时变量。前者是存在于以太坊的存储结构中的，而后者只是运行时的临时内存变量。例如：</p>
<pre><code class="line-numbers language-solidity">contract Storage {
    uint256 public a;
    bytes32 public b;

    function foo() public {
        uint256 c;
    }
}
</code></pre>
<p>这段代码中，变量 <code>a</code> 和 <code>b</code> 是状态变量，属于我们讨论的范围，而 <code>c</code> 不属于，因为它是运行时临时变量。</p>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Solidity 中的内存布局，有一个插槽（slot）的概念。每一个合约，都有 <code>2 ^ 256</code> 个内存插槽用于存储状态变量，但是这些插槽并不是实际存在的，也就是说，并没有实际占用了这么多空间，而是按需分配，用到时就会分配，不用时就不存在。插槽数量的上限是 <code>2 ^ 256</code>，每个插槽的大小是 <code>32</code> 个字节。图示如下：</p>
<p><img src="/upload_image/2022-07-28-深入理解合约升级2/1.png" alt></p>
<p>Solidity 中有这么多的数据类型，它们都是怎么存储在这些插槽中的呢？我们来看看。</p>
<h2 id="插槽分配"><a href="#插槽分配" class="headerlink" title="插槽分配"></a>插槽分配</h2><h3 id="固定长度类型"><a href="#固定长度类型" class="headerlink" title="固定长度类型"></a>固定长度类型</h3><p>我们知道，Solidity 中的数据类型有很多，常见的有 <code>uint</code>，<code>bytes(n)</code>， <code>address</code>，<code>bool</code>，<code>string</code> 等等。其中 <code>uint</code> 还有不同长度的，比如 <code>uint8</code>，<code>uint256</code> 等，<code>bytes(n)</code> 也包括 <code>bytes2</code>，<code>bytes32</code> 等。还有 <code>mapping</code> 以及 <code>数组</code> 类型等。前面提到过，一个插槽的大小是 32 个字节，那么像 <code>uint256</code>，<code>bytes32</code> 这些 32 字节大小的类型就可以刚好放在一个插槽中。</p>
<p>来看一个简单的例子：</p>
<pre><code class="line-numbers language-solidity">contract Storage {
    uint256 public a;
    uint256 public b;
    uint256 public c;

    function foo() public {
        a = 1;
        b = 2;
        c = 123;
    }
}
</code></pre>
<p>上面的合约中，<code>a</code>,<code>b</code>,<code>c</code> 三个变量都是 <code>uint256</code> 类型的，恰好每个变量都占用了一个插槽，分别是插槽0，1，2。我们部署合约，调用 <code>foo</code> 函数，读取它们的值来确认一下：</p>
<pre><code class="line-numbers language-Solidity">const {ethers} = require(&quot;ethers&quot;);
const provider = new ethers.providers.JsonRpcProvider()

const main = async () =&gt; {
    // 第一个参数是部署的合约地址
    // 第二个参数是插槽的位置，这里注意，如果是十进制，就直接写数字
    // 如果是十六进制，需要加上引号，例如 &#39;0x0&#39;
    let a = await provider.getStorageAt(
        &quot;0x4ed7c70F96B99c776995fB64377f0d4aB3B0e1C1&quot;,
        0
    )
    console.log(a)
}

main()
</code></pre>
<p>这段代码使用了 ethersjs 库来读取合约插槽的数据，也可以使用其他的方法，例如 Python 可以使用 web3py 库。</p>
<p>我们分别读取0，1，2三个插槽的数据，分别为</p>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000001</p>
</blockquote>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000002</p>
</blockquote>
<blockquote>
<p>0x000000000000000000000000000000000000000000000000000000000000007b</p>
</blockquote>
<p>对应的 10 进制数为 1，2，123，验证正确。</p>
<p>我们再对上面的合约做一点小小的改动：</p>
<pre><code class="line-numbers language-solidity">uint8 public a;
uint8 public b;
uint256 public c;
</code></pre>
<p>同样，我们部署并调用 <code>foo</code> 函数，再读取其插槽值，我们可以看到，插槽 0 的数据变成了：</p>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000201</p>
</blockquote>
<p>而插槽 1 的数据变成了：</p>
<blockquote>
<p>0x000000000000000000000000000000000000000000000000000000000000007b</p>
</blockquote>
<p>插槽 2 直接就没有数据了，这是为什么呢？因为一个插槽的大小是 32 字节，而 <code>a</code> 和 <code>b</code> 都只占用 1 个字节，Solidity 为了节省存储空间，会将它俩放在同一个插槽中，而下一个 <code>c</code> 变量，由于它占用了 32 字节，因此它要占用下一个插槽。</p>
<p>那么我们再做一点小改动，将 <code>b</code> 和 <code>c</code> 调换位置:</p>
<pre><code class="line-numbers language-solidity">uint8 public a;
uint256 public c;
uint8 public b;
</code></pre>
<p>此时我们再去查看插槽数据，会发现，三个变量都各自占据了一个插槽，这是因为，虽然 <code>a</code> 只占据了插槽 0 中的 1 个字节，但是由于下一个变量 <code>c</code> 要占据一整个插槽，所以 <code>c</code> 只能去下一个插槽，那么 <code>b</code> 也就只能去第三个插槽了。</p>
<p>这里带给我们的思考就是，在开发合约时，内存的布局分配也是很重要的，合理地分配内存布局可以节省内存空间，也就节省了 gas 费用。</p>
<p>前面我们提到的 <code>bytes(n)</code> 类型，和 <code>uint</code> 类似，也是同样的道理。同时还有 <code>bool</code> 类型，它只占用 1 个字节。<code>address</code> 类型，占用 20 个字节。因此在开发过程中，可以将一些小字节类型放在一起，从而节省 gas 费用。</p>
<h2 id="非固定长度类型"><a href="#非固定长度类型" class="headerlink" title="非固定长度类型"></a>非固定长度类型</h2><p>上面我们说到的，都是定长的数据类型。而像 <code>string</code>，<code>bytes</code> 这种非固定长度的类型，它们的存储规则是：</p>
<ol>
<li>如果数据长度小于等于 <code>31</code> 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。</li>
<li>如果数据长度超出 <code>31</code> 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</li>
</ol>
<p>来看一个实际的例子验证一下：</p>
<pre><code class="line-numbers language-solidity">contract Storage {
    string public a;
    string public b;

    function foo() public {
        // a是31个字节，b是32个字节
        a = &#39;abcabcabcabcabcabcabcabcabcabca&#39;;
        b = &#39;abcabcabcabcabcabcabcabcabcabcab&#39;;
    }
}
</code></pre>
<p>查看插槽 0 和 1 的值，分别为：</p>
<blockquote>
<p>0x616263616263616263616263616263616263616263616263616263616263613e（最后一个字节存储长度 0x3e，即 62 = 31 * 2）</p>
</blockquote>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000041（最后一个字节存储长度 0x41，即 65 = 32 * 2 + 1）</p>
</blockquote>
<p>我们再去看看 keccak256(slot) 中存储的值，通过</p>
<pre><code class="line-numbers language-solidity">keccak256(abi.encode(1));
</code></pre>
<p>计算出哈希值，这也就是插槽的位置，再去读取其值：</p>
<pre><code class="line-numbers language-solidity">// 第二个参数为插槽的位置，使用 ethersjs 库需要加引号，否则报错
let a = await provider.getStorageAt(
    &quot;0x4ed7c70F96B99c776995fB64377f0d4aB3B0e1C1&quot;,
&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;
)
</code></pre>
<p>结果为：</p>
<blockquote>
<p>0x6162636162636162636162636162636162636162636162636162636162636162</p>
</blockquote>
<p>验证成功，注意我们这里的使用的是数据长度恰好为 32 字节，如果大于 32 字节，那么剩余的长度就会继续往下一个插槽【即 <code>keccak256(abi.encode(1)) + 1</code> 】延伸。</p>
<p>接下来我们看看 <code>mapping</code> 和 <code>数组</code> 类型是怎么存储的。</p>
<p>对于 <code>mapping</code> 类型，规则是：</p>
<ol>
<li>所处的插槽，空置，不存储内容，</li>
<li><code>mapping</code> 中的数据，存储在插槽 <code>keccak256(key.slot)</code> 中，也就是：</li>
</ol>
<pre><code class="line-numbers language-solidity">keccak256(abi.encode(key, slot))
</code></pre>
<p>来看一个例子：</p>
<pre><code class="line-numbers language-solidity">contract Storage {
    mapping(uint256 =&gt; uint256) public a;

    function foo() public {
        a[1] = 123;
        a[2] = 345;
    }
}
</code></pre>
<p>通过 <code>keccak256(abi.encode(1, 0))</code> 和 <code>keccak256(abi.encode(2, 0))</code> 分别计算出， <code>a[1]</code> 和 <code>a[2]</code> 所处的插槽位置为：</p>
<blockquote>
<p>0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</p>
</blockquote>
<blockquote>
<p>0xabbb5caa7dda850e60932de0934eb1f9d0f59695050f761dc64e443e5030a569</p>
</blockquote>
<p>我们进行验证，插槽 0 的值为 0，上述这两个插槽的值分别为：</p>
<blockquote>
<p>0x000000000000000000000000000000000000000000000000000000000000007b</p>
</blockquote>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000159</p>
</blockquote>
<p>即分别为 123 和 345，验证成功。</p>
<p>再来看看数组类型，它所满足的规则是：</p>
<ol>
<li>所处的插槽，存储数组的长度</li>
<li>数组内存储的元素，存储在以 <code>keccak256(slot)</code> 插槽开始的位置</li>
</ol>
<p>同样来看一个例子：</p>
<pre><code class="line-numbers language-solidity">contract Storage {
    uint256[] public a;

    function foo() public {
        a.push(12);
        a.push(34);
    }
}
</code></pre>
<p>运行 <code>foo</code> 函数后，插槽 0 值就变成了 2，这里注意，如果运行了两次 <code>foo</code>，那么就变成了 4，因为数组的长度变成了 4。我们来计算 <code>keccak256(abi.encode(0))</code> 的值为：</p>
<blockquote>
<p>0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</p>
</blockquote>
<p>查询其插槽上的值为 12，再看看下一个插槽【即 <code>keccak256(abi.encode(0)) + 1</code> 】的值为 34，满足规则。</p>
<p>对于组合类型，例如 <code>mapping(uint256 =&gt; uint256[])</code>，那么就按照组合的规则，从外到里进行计算即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Solidity 中的内存布局，都严格遵守既定规则，并不是杂乱无章的。理解了内存布局，对于我们后面学习可升级合约，帮助很大。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html" target="_blank" rel="noopener">docs.soliditylang.org</a><br><a href="https://learnblockchain.cn/books/geth/part7/storage.html" target="_blank" rel="noopener">learnblockchain.cn</a><br><a href="http://aandds.com/blog/solidity-storage-layout.html" target="_blank" rel="noopener">aandds.com</a></p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/5eu3_7f7275rqY-fNMUP5BKS8izV9Tshmv8Z5H9bsec" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解合约升级(3) - call 与 delegatecall</title>
    <url>/2022/07/29/Ethereum-2022-07-29-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-3-call-%E4%B8%8E-delegatecall/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(3) - call 与 delegatecall </blockquote>

<a id="more"></a>
<h2 id="call-与-delegatecall-的区别"><a href="#call-与-delegatecall-的区别" class="headerlink" title="call 与 delegatecall 的区别"></a>call 与 delegatecall 的区别</h2><p><code>call</code> 和 <code>delegatecall</code> 是 Solidity 中调用外部合约的方法，但是它俩却有挺大的区别。假设 A 合约调用 B 合约，当在 A 合约中使用 <code>call</code> 调用 B 合约时，使用的是 B 合约的上下文，修改的是 B 合约的内存插槽值。而在如果在 A 合约中使用 <code>delegatecall</code> 调用 B 合约，那么在 B 合约的函数执行过程中，使用的是 A 合约的上下文，同时修改的也是 A 合约的内存插槽值。这么说有些抽象，我们来看一个简单的示意图：</p>
<p><img src="/upload_image/2022-07-29-深入理解合约升级3/1.png" alt="通过 call 调用" title="通过 call 调用"></p>
<p><img src="/upload_image/2022-07-29-深入理解合约升级3/2.png" alt="通过 delegatecall 调用" title="通过 delegatecall 调用"></p>
<p>从上面的图中我们可以看出，在使用 <code>call</code> 调用时，B 合约使用的上下文数据均是 B 本身的。而当使用 <code>delegatecall</code> 调用时，B 合约使用了 A 合约中的上下文数据。我们来写段代码测试一下：</p>
<pre><code class="line-numbers language-solidity">pragma solidity 0.8.13;


contract A {
    address public b;
    constructor(address _b) {
        b = _b;
    }

    function foo() external {
        (bool success, bytes memory data) = 
            b.call(abi.encodeWithSignature(&quot;foo()&quot;));
        require(success, &quot;Tx failed&quot;);
    }
}

contract B {
    event Log(address sender, address me);
    function foo() external {
        emit Log(msg.sender, address(this));
    }
}
</code></pre>
<p>上面代码中，我们在 A 合约中使用 <code>call</code> 调用 B 合约，通过 <code>Log</code> 事件记录一些信息。先部署 B 合约，然后将其地址作为参数部署 A 合约，接着我们调用 <code>foo</code> 函数，可以获取到 <code>Log</code> 事件的内容为：</p>
<p><img src="/upload_image/2022-07-29-深入理解合约升级3/3.png" alt="通过 call 调用" title="通过 call 调用"></p>
<p>与我们前面的说的规则一致，使用 <code>call</code> 调用时，使用的是 B 本身的上下文。接下来我们将 <code>call</code> 改成 <code>delegatecall</code>：</p>
<pre><code class="line-numbers language-solidity">function foo() external {
    (bool success, bytes memory data) = 
        b.delegatecall(abi.encodeWithSignature(&quot;foo()&quot;));
    require(success, &quot;Tx failed&quot;);
}
</code></pre>
<p>再来看看执行结果：</p>
<p><img src="/upload_image/2022-07-29-深入理解合约升级3/4.png" alt="通过 delegatecall 调用" title="通过 delegatecall 调用"></p>
<p>可以看到当使用了 <code>delegatecall</code> 调用时，使用了 A 合约的上下文。</p>
<p>上面我们还提到，当使用 <code>delegatecall</code> 时，修改的是调用合约的内存插槽值，这是什么意思呢，我们来看一个例子：</p>
<pre><code class="line-numbers language-solidity">pragma solidity 0.8.13;


contract A {
    uint256 public alice;
    uint256 public bob;

    address public b;
    constructor(address _b) {
        b = _b;
    }

    function foo(uint256 _alice, uint256 _bob) external {
        (bool success, bytes memory data) = 
            b.delegatecall(abi.encodeWithSignature(&quot;foo(uint256,uint256)&quot;, 
            _alice, _bob));
        require(success, &quot;Tx failed&quot;);
    }
}

contract B {
    uint256 public alice;
    uint256 public bob;
    function foo(uint256 _alice, uint256 _bob) external {
        alice = _alice;
        bob = _bob;
    }
}
</code></pre>
<p>这段代码中，我们使用 <code>delegatecall</code> 来调用 <code>foo</code> 函数，<code>foo</code> 函数的作用是给 B 合约的两个变量赋值。但是实际调用后的结果是，A 合约的两个变量被赋值，而 B 中的变量仍为空。这就是我们前面说的，<code>delegatecall</code> 会修改调用合约的内存插槽值，我们来看一个图示：</p>
<p><img src="/upload_image/2022-07-29-深入理解合约升级3/5.png" alt="内存插槽" title="内存插槽"></p>
<p>在 A 合约中有三个状态变量，B 合约中有两个状态变量。当 A 合约使用 <code>delegatecall</code> 调用 B 合约时，对 B 合约状态变量的赋值会通过插槽顺序分别影响 A 合约的各个变量。也就是说，对 B 合约插槽 0 的变量 <code>alice</code> 赋值，实际上是把值赋给了 A 合约插槽 0 的变量 <code>alice</code>。同理，对 B 合约的第 n 个插槽赋值，实际上会对 A 合约的第 n 个插槽赋值。注意，这里仅仅和插槽顺序有关，而和变量名无关。如果我们将 B 合约改为：</p>
<pre><code class="line-numbers language-solidity">contract B {
    // 调换了变量声明顺序
    uint256 public bob;
    uint256 public alice;
    function foo(uint256 _alice, uint256 _bob) external {
        // 调换了赋值内容
        bob = _alice;
        alice = _bob;
    }
}
</code></pre>
<p>这段代码中，虽然变量声明以及赋值的顺序调换，但是 <code>foo</code> 的内容仍然是将 <code>_alice</code> 赋值给插槽 0 的变量，将 <code>_bob</code> 赋值给插槽 1 的变量，因此 A 合约的结果不变。</p>
<h2 id="delegatecall-在合约升级方面的应用"><a href="#delegatecall-在合约升级方面的应用" class="headerlink" title="delegatecall 在合约升级方面的应用"></a>delegatecall 在合约升级方面的应用</h2><p>学习理解 <code>delegatecall</code> 是我们后面学习合约升级的基础，合约升级的原理就是代理合约通过 <code>delegatecall</code> 调用逻辑合约，此时逻辑合约的上下文以及数据都是来自于代理合约，那么即使升级，更换了逻辑合约，所有的数据仍然存在于代理合约中，没有影响。可升级合约还有一个限制是，在升级合约时，不能更改已有的状态变量的顺序，如果需要新添变量，只能放在当前所有变量之后，不能在其中插入，原因就是这会改变插槽对应关系，使变量内容混乱。例如，若升级前的插槽为：</p>
<p><img src="/upload_image/2022-07-29-深入理解合约升级3/6.png" alt="内存插槽" title="内存插槽"></p>
<p>此时，变量 a 和 b 的值分别存储在代理合约的插槽 0，1 中。若添加变量 c，将其放在 a 和 b 中间，那么后续对于 c 的修改实际修改的是 b 的插槽，而对于 b 的修改则是在一个新的插槽上操作，造成数据混乱。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>delegatecall</code> 会在被调用合约中使用调用合约的上下文，同时影响的是调用合约的内存插槽，这有时会对合约开发带来一些困扰。在使用时，一定要多考虑各方面的影响。同时，<code>delegatecall</code> 也是代理合约升级模式的基石，要理解合约升级，必须要明白这种调用方式的方方面面。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-5-calling-other-contracts-visibility-state-access/topic/delegatecall/" target="_blank" rel="noopener">blockchain-academy.hs-mittweida.de</a><br><a href="https://www.anquanke.com/post/id/152590" target="_blank" rel="noopener">www.anquanke.com</a><br><a href="http://aandds.com/blog/eth-delegatecall.html" target="_blank" rel="noopener">aandds.com</a></p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/0gmFpVZVlHhwb2YlmaSY8Dyv5r3Z24sKIks38cyQRFk" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解合约升级(5) - 部署一个可升级合约</title>
    <url>/2022/07/31/Ethereum-2022-07-31-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-5-%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(5) - 部署一个可升级合约 </blockquote>

<a id="more"></a>
<p>前面的文章我们基本把合约升级的原理介绍完了，这篇文章我们来实际操作一下，部署一个可升级合约。我们将会使用到 <code>hardhat</code> 框架和 <code>OpenZeppelin</code> 的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable" target="_blank" rel="noopener">可升级合约库</a>。这个库和 OZ 的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts" target="_blank" rel="noopener">普通合约库</a>的区别是，所有的合约中都没有构造函数，作为代替的是 <code>initialize</code> 函数，用来作初始化操作。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先执行下面的命令来做一些初始化的工作：</p>
<ol>
<li><code>mkdir upgradeable_demo &amp;&amp; cd upgradeable_demo</code></li>
<li><code>npm init -y</code></li>
<li><code>npm install --save-dev hardhat</code></li>
<li><code>npx hardhat</code>，创建实例项目，并且按照步骤进行</li>
<li><code>npm install --save-dev @openzeppelin/hardhat-upgrades</code>，安装 hardhat 的升级组件</li>
<li><code>npm install --save-dev @nomiclabs/hardhat-ethers ethers</code>，这两个包主要用于合约部署和测试</li>
<li><code>npm install --save @openzeppelin/contracts-upgradeable</code>，安装可升级合约库</li>
</ol>
<p>接下来我们配置 <code>hardhat</code> 的配置文件：</p>
<pre><code class="line-numbers language-solidity">// hardhat.config.js
require(&quot;@nomiclabs/hardhat-ethers&quot;);
require(&#39;@openzeppelin/hardhat-upgrades&#39;);

/**
 * @type import(&#39;hardhat/config&#39;).HardhatUserConfig
 */
module.exports = {
  solidity: &quot;0.8.4&quot;,
  networks: {
    rinkeby: {
      url: // 这里填写对应网络的 rpc 地址,
      accounts: [这里填写私钥]
    }
  }
};
</code></pre>
<p>然后我们再来编写可升级合约，在 <code>contracts</code> 文件夹下创建 <code>Demo.sol</code> 文件：</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.4;

import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;

contract Demo is Initializable {
    uint256 public a;

    // 初始化函数，后面的修饰符 initializer 来自 Initializable.sol
    // 用于限制该函数只能调用一次
    function initialize(uint256 _a) public initializer {
        a = _a;
    }

    function increaseA() external {
        ++a;
    }
}
</code></pre>
<p>编译合约 <code>npx hardhat compile</code>，没有问题。</p>
<h2 id="Transparent-Proxy"><a href="#Transparent-Proxy" class="headerlink" title="Transparent Proxy"></a>Transparent Proxy</h2><p>接着我们编写部署脚本，在 <code>scripts</code> 文件夹下创建 <code>deploy.js</code> 文件：</p>
<pre><code class="line-numbers language-javascript">async function main() {
    const Demo = await ethers.getContractFactory(&quot;Demo&quot;);
    console.log(&quot;Deploying Demo...&quot;);
    // initializer 后面的参数为初始化函数的名字，这里为 initialize
    // 中括号的参数为初始化函数的参数
    const demo = await upgrades.deployProxy(Demo, [101], { initializer: &#39;initialize&#39; });
    // 这里打印的地址为代理合约的地址
    console.log(&quot;Demo deployed to:&quot;, demo.address);
}

// 这里也可以简化为 main()，后面的都省略也可以
main()
    .then(() =&gt; process.exit(0))
    .catch(error =&gt; {
        console.error(error);
        process.exit(1);
    });
</code></pre>
<p>我们来运行部署脚本，这里我们使用本地测试网络进行部署：</p>
<p>注意，本地测试网络需要运行 <code>npx hardhat node</code>。本地网络无需在配置文件中配置，如果使用真实网络，需要进行配置，并且在 <code>--network</code> 后面指定网络名称即可。</p>
<blockquote>
<p>npx hardhat run scripts/deploy.js --network localhost</p>
</blockquote>
<p>可以观察到一共部署了三个合约，对应的部署顺序分别是</p>
<ol>
<li>逻辑合约</li>
<li><code>ProxyAdmin</code> 合约</li>
<li>代理合约（名为 <code>TransparentUpgradeableProxy</code>）</li>
</ol>
<p>注意，一个项目中只会有一个 <code>ProxyAdmin</code> 合约，管理着所有的代理合约。也就是说，我们在同一个项目中再去部署另外的合约，那么只会有步骤 1、3，<code>ProxyAdmin</code> 只在部署第一个合约时会部署。</p>
<p>这时，假设由于业务场景变化，需要修改合约，将 <code>increaseA</code> 函数修改为：</p>
<pre><code class="line-numbers language-solidity">function increaseA() external {
    a += 10;
}
</code></pre>
<p>再次编译，没有问题。接着编写升级脚本，在 <code>scripts</code> 文件夹下创建 <code>upgrade.js</code> 文件：</p>
<pre><code class="line-numbers language-javascript">async function main() {
    // 这里的地址为前面部署的代理合约地址
    const proxyAddress = &#39;0x...&#39;;

    const Demo = await ethers.getContractFactory(&quot;Demo&quot;);
    console.log(&quot;Preparing upgrade...&quot;);
    // 升级合约
    await upgrades.upgradeProxy(proxyAddress, Demo);
}

main()
    .then(() =&gt; process.exit(0))
    .catch(error =&gt; {
        console.error(error);
        process.exit(1);
    });
</code></pre>
<p>接着运行</p>
<blockquote>
<p>npx hardhat run scripts/upgrade.js --network localhost</p>
</blockquote>
<p>升级合约时， <code>upgradeProxy</code> 中一共有两个步骤：</p>
<ol>
<li>部署新的逻辑合约</li>
<li>调用 <code>ProxyAdmin</code> 合约的 <code>upgrade</code> 函数来更换新合约，两个参数分别是代理合约和新逻辑合约的地址</li>
</ol>
<p>这样我们就完成了可升级合约的部署与升级，注意到我们的部署过程中有 <code>ProxyAdmin</code> 合约，说明这是 <code>TransparentProxy</code> 的合约升级模式。接下来我们看看 <code>UUPS</code> 的模式如何部署及升级。</p>
<h2 id="UUPS"><a href="#UUPS" class="headerlink" title="UUPS"></a>UUPS</h2><p>若要支持 <code>UUPS</code> 的升级模式，需要做以下几点改动：</p>
<ol>
<li>逻辑合约需继承 <code>UUPSUpgradeable</code> 合约</li>
<li>覆写 <code>_authorizeUpgrade</code> 函数</li>
<li>部署脚本需要添加 <code>kind: &#39;uups&#39;</code> 参数</li>
</ol>
<p>此时，逻辑合约变为：</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.4;

import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;
import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;

// 需要继承 UUPSUpgradeable 合约
contract Demo is Initializable, UUPSUpgradeable {
    uint256 public a;

    function initialize(uint256 _a) public initializer {
        a = _a;
    }

    function increaseA() external {
        a += 10;
    }

    // 覆写 _authorizeUpgrade 函数
    function _authorizeUpgrade(address) internal override {}
}
</code></pre>
<p>部署脚本变为：</p>
<pre><code class="line-numbers language-javascript">async function main() {
    const Demo = await ethers.getContractFactory(&quot;Demo&quot;);
    console.log(&quot;Deploying Demo...&quot;);
    // 这里添加了参数 =&gt; kind: &#39;uups&#39;
    const demo = await upgrades.deployProxy(Demo, [101], { initializer: &#39;initialize&#39;, kind: &#39;uups&#39; });
    console.log(&quot;Demo deployed to:&quot;, demo.address);
}

main()
    .then(() =&gt; process.exit(0))
    .catch(error =&gt; {
        console.error(error);
        process.exit(1);
    });
</code></pre>
<p>编译合约并运行部署脚本（注意，这时最好删除 <code>.openzeppelin</code> 文件夹下的对应网络配置文件，因为其包含了我们上面测试的 <code>TransparentProxy</code> 模式的一些运行配置，可能会有影响），可以观察到一共部署了两个合约，分别是：</p>
<ol>
<li>逻辑合约</li>
<li>代理合约（名为 <code>ERC1967Proxy</code>）</li>
</ol>
<p>此时，假设我们需要升级合约，在改动了合约之后，我们可以继续使用上面的 <code>upgrade.js</code> 脚本进行升级，这时的升级步骤是：</p>
<ol>
<li>部署新的逻辑合约</li>
<li>调用<strong>代理合约</strong>的 <code>upgradeTo</code> 函数进行升级，参数是新的逻辑合约地址</li>
</ol>
<p>我们可以看到，两种升级模式有所区别。<code>TransparentProxy</code> 模式在升级的时候，需要调用 <code>ProxyAdmin</code> 的升级函数。而 <code>UUPS</code> 模式在升级时，需要调用代理合约的升级函数。后者相比于前者少部署一个合约。</p>
<h2 id="UUPS-中需要注意的权限管理问题"><a href="#UUPS-中需要注意的权限管理问题" class="headerlink" title="UUPS 中需要注意的权限管理问题"></a>UUPS 中需要注意的权限管理问题</h2><p>这里有一个重点是，由于 <code>TransparentProxy</code> 模式是由 <code>ProxyAdmin</code> 进行管理，也就是说只有 <code>ProxyAdmin</code> 有权限进行升级，那么我们只要保证 <code>ProxyAdmin</code> 合约的管理员权限安全即可保证整个可升级架构安全。而对于 <code>UUPS</code> 模式来说，升级合约的逻辑是需要调用代理合约的，这时的权限管理就需要开发者手动处理。具体来说，就是对于我们覆写的 <code>_authorizeUpgrade</code> 函数，需要加上权限管理：</p>
<pre><code class="line-numbers language-solidity">function _authorizeUpgrade(address) internal 
    override onlyOwner {}
</code></pre>
<p>这里加上了 <code>onlyOwner</code> 用于限制升级权限，否则任何人都可调用代理合约的 <code>upgradeTo</code> 进行升级。但要注意的是，我们这里只是简单加上了 <code>onlyOwner</code> 做为示例的权限管理，在实际开发中，由于升级的逻辑和业务逻辑都在逻辑合约中，因此需要区分业务场景的 <code>owner</code> 和合约升级架构的 <code>owner</code>。这里可能会对开发者带来困扰，因此需要多加注意。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>TransparentProxy</code> 和 <code>UUPS</code> 是目前阶段比较流行的成熟的合约升级解决方案。OZ 建议开发者使用 <code>UUPS</code>，更加轻量级，节省 gas。我个人还是比较倾向于前者，因为我觉得前者架构清晰，权限管理简单。后者将业务逻辑和升级组件都放在逻辑合约中，当需要多次升级合约时，是否节省 gas 仍需探讨。不过建议大家两个都能够熟练掌握，毕竟难度不高，上手也很简单。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786" target="_blank" rel="noopener">forum.openzeppelin.com</a><br><a href="https://forum.openzeppelin.com/t/openzeppelin-upgrades-step-by-step-tutorial-for-hardhat/3580" target="_blank" rel="noopener">forum.openzeppelin.com</a><br><a href="https://www.npmjs.com/package/@openzeppelin/hardhat-upgrades" target="_blank" rel="noopener">www.npmjs.com</a><br><a href="https://blog.logrocket.com/using-uups-proxy-pattern-upgrade-smart-contracts" target="_blank" rel="noopener">blog.logrocket.com</a></p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/kM9ld2u0D1BpHAfXTiaSPGPtDnOd6vrxJ5_tW4wZVBk" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解合约升级(4) - 合约升级原理的代码实现</title>
    <url>/2022/07/30/Ethereum-2022-07-30-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-4-%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(4) - 合约升级原理的代码实现 </blockquote>

<a id="more"></a>
<p>前面的文章我们提到，合约升级的原理是将合约架构分为 <code>代理合约</code> 与 <code>逻辑合约</code>，通过前面对于内存结构以及 <code>delegatecall</code> 的学习，我们已经基本掌握的合约升级的基础。这篇文章我们就从代码层面来看看合约升级到底应该如何实现。</p>
<p><img src="/upload_image/2022-07-30-深入理解合约升级4/1.png" alt></p>
<p>这是我们在第一篇文章中的图例，当我们学习了内存结构以及 <code>delegatecall</code> 之后，我们再来看这幅图，就能够很好地理解了：数据都存放在代理合约的内存插槽中，而由于代理合约使用了 <code>delegatecall</code>，因此函数执行都在逻辑合约中运行，修改的却是代理合约中的数据。这样就可以方便替换逻辑合约，实现合约升级。</p>
<h2 id="合约升级实现过程"><a href="#合约升级实现过程" class="headerlink" title="合约升级实现过程"></a>合约升级实现过程</h2><h3 id="简版-Proxy"><a href="#简版-Proxy" class="headerlink" title="简版 Proxy"></a>简版 Proxy</h3><p>首先我们考虑，对于代理合约而言，如何将请求转发到逻辑合约。最简单的方法就是对于逻辑合约中的每个函数，都在代理合约中包装一层，然后通过 <code>delegatecall</code> 来分别调用各个函数。这种方法是不可行的，因为既然我们都用到了可升级合约，那就说明我们后期会对合约做改动，我们总不能每添加一个函数，都在代理合约中添加一个包装层。一是这样很冗余，二是这样无法实现，因为代理合约也是区块链上的智能合约，它本身是不可变的。</p>
<p>这时我们想到，能不能够利用 Solidity 中的 <code>fallback</code> 与 <code>receive</code> 函数，它们的作用就是接收并处理一切未实现的函数（两者的区别是，<code>receive</code> 接收所有 <code>msg.data</code> 为空的调用，<code>fallback</code> 接收所有未匹配函数的调用）。如果我们将所有的函数调用都通过 <code>fallback</code> 转发给逻辑合约，那么是否就达到目标了呢？我们来看看代码：</p>
<pre><code class="line-numbers language-solidity">// 注：这个实现有问题（后文有描述），不要直接使用！
contract Proxy {
    address public implementation;
    address public admin;

    constructor() public {
        admin = msg.sender;
    }
    function setImplementation(address newImplementation) external {
        require(msg.sender == admin, &quot;must called by admin&quot;);
        implementation = newImplementation;
    }
    function changeAdmin(address newAdmin) external {
        require(msg.sender == admin, &quot;must called by admin&quot;);
        admin = newAdmin;
    }

    function _delegate() internal {
        require(msg.sender != admin, &quot;admin cannot fallback to proxy target&quot;);
        address _implementation = implementation;
        // 下面代码是利用 delegatecall 把请求转发给 _implementation 所指定地址的合约中去
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    fallback () payable external {
        _delegate();
    }
    // Will run if call data is empty.
    receive () payable external {
        _delegate();
    }
}
</code></pre>
<p>这段代码中，我们将 <code>fallback</code> 和 <code>receive</code> 函数都指向了 <code>_delegate</code> 函数，它会将有请求都转发给逻辑合约。乍一看没有什么问题，但是需要注意：</p>
<ol>
<li>此合约中有两个字段，<code>implementation</code> 和 <code>admin</code>，分别存储逻辑合约地址和管理员地址（管理员地址用户更换逻辑合约升级）。它们分别占据了插槽 0 和 1 的位置，那么这就有可能和我们的逻辑合约中的内存发生冲突，如果逻辑合约中有对这俩插槽的修改，那就直接把这两个很重要的变量给改掉了，那就乱套了。</li>
<li>还有一个问题就是代理合约本身也存在一些自身的方法，比如 <code>changeAdmin</code> 等，如果逻辑合约中恰好也有这些方法，那么用户的请求就不会转发到逻辑合约。</li>
</ol>
<h3 id="EIP-1967"><a href="#EIP-1967" class="headerlink" title="EIP-1967"></a>EIP-1967</h3><p>该如何解决这个问题呢？<a href="https://eips.ethereum.org/EIPS/eip-1967" target="_blank" rel="noopener">EIP-1967</a> 提出了一个解决办法，它把 <code>implementation</code> 和 <code>admin</code> 这两个字段放在了两个特殊的插槽中：</p>
<pre><code class="line-numbers language-solidity"># bytes32(uint256(keccak256(&#39;eip1967.proxy.implementation&#39;)) - 1)
0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

# bytes32(uint256(keccak256(&#39;eip1967.proxy.admin&#39;)) - 1)
0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
</code></pre>
<p>这两个插槽是经过哈希计算出来的值，根据概率来看，不可能与逻辑合约中的其他内存位置发生冲突。此时，我们的代码就变成了：</p>
<pre><code class="line-numbers language-solidity">bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
</code></pre>
<p>注意这里指用了 <code>constant</code> 来保存插槽位置，<code>constant</code> 关键字保存的是常量，并不保存在插槽中。这样我们就解决了前面提到的第一个问题。</p>
<p>我们再来看看第二个问题，这个问题看似很好解决，比如我们给代理合约中的函数都起一些不常用的名字就行。例如，把上面的 <code>changeAdmin</code> 改成 <code>changeAdmin12345</code>。但是问题没有这么简单，我们要知道，智能合约匹配请求是根据函数签名 <code>keccak256</code> 值的前 4 个字节来判断的，如果两个函数的哈希值前 4 位相同，那么它们就被判断为同一个函数，例如：</p>
<pre><code class="line-numbers language-solidity"># keccak256(&quot;proxyOwner()&quot;) 前 4 字节为 025313a2
proxyOwner()

# keccak256(&quot;clash550254402()&quot;) 前 4 字节为 025313a2
clash550254402()
</code></pre>
<p>这个问题被称为 <code>Proxy selector clashing</code>。这可能会造成一些问题，如果我们的逻辑合约中恰好有函数的哈希值前 4 位与代理合约中的某个函数相同，那就会造成用户的请求实际上是在代理合约中执行的，而执行结果必然是我们不希望发生的。</p>
<h3 id="Transparent-Proxy"><a href="#Transparent-Proxy" class="headerlink" title="Transparent Proxy"></a>Transparent Proxy</h3><p><a href="https://blog.openzeppelin.com/the-transparent-proxy-pattern/" target="_blank" rel="noopener">Transparent Proxy</a> 提出了解决方案，它主要从两方面解决这个问题：</p>
<ol>
<li>来自普通用户的请求全部转发给逻辑合约，即使代理合约与逻辑合约发生了名称冲突，也要转发</li>
<li>来自管理员 <code>admin</code> 的请求，全部不转发，由代理合约处理</li>
</ol>
<p>主要的代码如下：</p>
<pre><code class="line-numbers language-solidity">contract Proxy {
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    modifier ifAdmin() {
        // 如果调用者是 admin，就执行；否则转发到 Implementation 合约
        if (msg.sender == admin()) {
            _;
        } else {
            _delegate();
        }
    }

    constructor() public {
        address admin = msg.sender;
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            sstore(slot, admin)
        }
    }
    function implementation() public ifAdmin returns (address) {
        return _implementation();
    }

    function _implementation() internal view returns (address impl) {
        bytes32 slot = _IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }

    function setImplementation(address newImplementation) external ifAdmin {
        bytes32 slot = _IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    }
    function admin() public ifAdmin returns (address) {
        return _admin();
    }

    function _admin() internal view returns (address adm) {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }
    function changeAdmin(address newAdmin) external ifAdmin {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            sstore(slot, newAdmin)
        }
    }

    function _delegate() internal {
        address _implementation = _implementation();
        // 下面代码是利用 delegatecall 把请求转发给 _implementation 所指定地址的合约中去
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    fallback () payable external {
        // 来自 admin 的请求不转发
        require(msg.sender != _admin(), &quot;admin cannot fallback to proxy target&quot;);
        _delegate();
    }

    // 来自 admin 的请求不转发
    receive () payable external {
        require(msg.sender != _admin(), &quot;admin cannot fallback to proxy target&quot;);
        _delegate();
    }
}
</code></pre>
<p>可以看到，合约中添加了 <code>ifAdmin</code> 修饰符，用于判断请求的来源。对于代理合约自身的一些函数如 <code>changeAdmin</code> 等，均使用了该修饰符。这样即使出现了签名冲突的情况，只要是来自于普通用户的请求，均直接转发给了逻辑合约执行。这样就解决了前面的第二个问题。</p>
<p>不过，仍然存在一个小问题，就是 <code>admin</code> 用户无法作为普通用户的视角正常调用。这个问题也比较好解决，一般可以准备一个特殊账户作为 <code>admin</code> 用户，仅调用管理员方法即可。也有另一个解决方法，就是使用一个 <code>ProxyAdmin</code> 合约来作为管理员，这样所有的账户都可以正常调用合约了。</p>
<p><code>ProxyAdmin</code> 的合约代码片段如下：</p>
<pre><code class="line-numbers language-solidity">contract ProxyAdmin is Ownable {
    // 管理员EOA地址通过调用该方法来更换逻辑合约
    function upgrade(IProxy proxy, address newImplementation) public onlyOwner {
        proxy.setImplementation(implementation);
    }
    // ......
}

interface IProxy {
    function setImplementation(address newImplementation);
    // ......
}
</code></pre>
<p>此时整个合约的架构为：</p>
<p><img src="/upload_image/2022-07-30-深入理解合约升级4/2.png" alt="可升级合约架构" title="可升级合约架构"></p>
<h3 id="Universal-Upgradeable-Proxy-Standard-UUPS"><a href="#Universal-Upgradeable-Proxy-Standard-UUPS" class="headerlink" title="Universal Upgradeable Proxy Standard (UUPS)"></a>Universal Upgradeable Proxy Standard (UUPS)</h3><p>UUPS 是 OpenZeppelin 在近期推出的一种新的合约升级模式，与上面的 <code>Transparent</code> 代理模式原理相同，都是利用 <code>delegatecall</code> 通过代理合约调用逻辑合约。所不同的是，<code>Transparent</code> 模式是将替换逻辑合约的函数放在代理合约中，而 <code>UUPS</code> 则是将其放在了逻辑合约中。也就是说，前者模式中，每个代理合约中都有一个类似 <code>upgradeTo</code> 这样的函数，用来更换逻辑合约。而在后者模式中，这样的函数是放在了逻辑合约的实现中。</p>
<p><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups" target="_blank" rel="noopener">官方文档</a>中对于两者的对比，主要表述了 <code>UUPS</code> 模式更加轻量级，更加节省 gas，并且更推荐使用这种模式。由于代理合约中不用再包含替换逻辑合约的函数，因此节省了 gas。我个人目前对于这种模式持保留意见，因为对于可升级合约来说，代理合约和逻辑合约是一对多的关系。在之前的模式中，把替换逻辑合约的部分放在代理合约中，这也只需要部署一份代理合约。而新模式中，每个逻辑合约都要包含这部分升级组件，这样是否更加耗费 gas。而且将这部分逻辑放在逻辑合约中，是否会造成逻辑合约变得更加臃肿。毕竟在之前的模式中，开发逻辑合约时只需要关注业务逻辑即可。也许是因为目前我对于 <code>UUPS</code> 模式的理解不够深入，暂时先将疑问抛出，待后续继续深入学习。</p>
<h2 id="可升级合约的一些限制"><a href="#可升级合约的一些限制" class="headerlink" title="可升级合约的一些限制"></a>可升级合约的一些限制</h2><p>要实现合约升级，有一些限制需要我们注意。</p>
<p><strong>第一个</strong>就是我们在<strong>上篇文章</strong>最后提到的，在升级合约，也就是更换逻辑合约的时候，新合约的新增状态变量必须添加在当前所有变量之后，不能在前面的变量中插入，否则会更改内存插槽对应关系。同理，如果合约涉及到继承关系，不能在基类中添加变量（在基类中添加变量就相当于在基类和子类的状态变量之前插入变量）。也不能够更改或删除之前的状态变量。</p>
<p><strong>第二个</strong>是不能使用构造函数 <code>constructor</code>，由于合约的构造函数是在合约初始化的时候就被调用，这时它的一些赋值操作会直接影响到自身的内存。合约升级的前提是代理合约通过 <code>delegatecall</code> 调用逻辑合约来影响代理的内存布局，如果逻辑合约自己使用了构造函数去初始化一些变量，那么对于代理合约而言，内存是没有任何变化的。对于该问题，替代方法是使用 <code>initialize</code> 函数来代替构造函数。在合约部署完成后需要手动调用 <code>initialize</code> 函数。同时要记得，逻辑合约中实现的 <code>initialize</code> 函数中要手动实现调用基类的 <code>initialize</code> 方法。例如：</p>
<pre><code class="line-numbers language-solidity">pragma solidity ^0.6.0;

import &quot;@openzeppelin/upgrades/contracts/Initializable.sol&quot;;

contract BaseContract is Initializable {
    uint256 public y;

    function initialize() public initializer {
        y = 42;
    }
}

contract MyContract is BaseContract {
    uint256 public x;

    function initialize(uint256 _x) public initializer {
        // 手动调用基类中的初始化方法
        BaseContract.initialize();
        x = _x;
    }
}
</code></pre>
<p><strong>第三个</strong>是所有状态变量不能在声明时就赋初始值，例如：</p>
<pre><code class="line-numbers language-solidity">contract MyContract {
    uint256 public hasInitialValue = 42;
}
</code></pre>
<p>这种行为类似于在构造函数中赋值，不可行。需要改为在 <code>initialize</code> 函数中赋值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Openzeppelin 库已经实现了完善的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable" target="_blank" rel="noopener">可升级合约库</a>，我们在开发过程中可以直接使用现有的合约进行部署，避免重复造轮子出现错误。同时也提供了相应的<a href="https://docs.openzeppelin.com/contracts/4.x/upgradeable" target="_blank" rel="noopener">文档</a>以供参考。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://aandds.com/blog/eth-delegatecall.html" target="_blank" rel="noopener">aandds.com</a><br><a href="https://blog.openzeppelin.com/the-transparent-proxy-pattern/" target="_blank" rel="noopener">blog.openzeppelin.com</a><br><a href="https://ethereum.stackexchange.com/questions/81994/what-is-the-receive-keyword-in-solidity" target="_blank" rel="noopener">ethereum.stackexchange.com</a><br><a href="https://docs.openzeppelin.com/contracts/4.x/upgradeable" target="_blank" rel="noopener">docs.openzeppelin.com</a><br><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups" target="_blank" rel="noopener">docs.openzeppelin.com</a><br><a href="https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786" target="_blank" rel="noopener">forum.openzeppelin.com</a></p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/VSyU0JfmVrcqN-F28tX5mzYjxFFAosl8tDAQX3vB5Dg" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 EVM（三）</title>
    <url>/2022/08/29/Ethereum-2022-08-29-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-EVM%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解 EVM（三） </blockquote>

<a id="more"></a>
<p>今天我们来聊聊调用合约方法在字节码层面是怎么实现的。同样地，我们以一个简单的合约作为例子：</p>
<h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

contract Demo {
    constructor() {}

    function func1() public {}

    function func2() public {}
}
</code></pre>
<p>该合约中一共有两个方法，分别是 <code>func1</code> 与 <code>func2</code>。我们这里着重于理解方法调用的过程，因此简单起见就将方法内容置为空。</p>
<p>使用 <code>solc</code> 进行编译：</p>
<blockquote>
<p>solc Demo.sol --bin</p>
</blockquote>
<p>得到的字节码为：</p>
<pre><code>6080604052348015600f57600080fd5b5060818061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806374135154146037578063b1ade4db14603f575b600080fd5b603d6047565b005b60456049565b005b565b56fea264697066735822122069532a763e3f61abcfbb422ae7dc4587126c8f8b2264e73bb837a5924ebb1d4964736f6c634300080f0033
</code></pre><p>利用 <code>0xfe</code> 操作符分割后，得到的各部分分别为：</p>
<pre><code>6080604052348015600f57600080fd5b5060818061001e6000396000f3（init bytecode）

6080604052348015600f57600080fd5b506004361060325760003560e01c806374135154146037578063b1ade4db14603f575b600080fd5b603d6047565b005b60456049565b005b565b56（runtime bytecode）

a264697066735822122069532a763e3f61abcfbb422ae7dc4587126c8f8b2264e73bb837a5924ebb1d4964736f6c634300080f0033（metadata hash）
</code></pre><p><code>init bytecode</code> 是合约部署部分，我们在<a href>上篇文章</a>中已经介绍过了。调用合约方法是与 <code>runtime bytecode</code> 这部分进行交互，我们主要来研究这一块。</p>
<p>我们知道，调用合约方法交易的 <code>data</code> 域就是合约签名与参数的拼接内容。具体来说，就是合约签名的 <code>keccak256</code> 哈希值的前 4 个字节再加上参数内容就构成了 <code>data</code> 部分。</p>
<p>在上面例子中，<code>func1</code> 与 <code>func2</code> 的哈希值前 4 个字节分别是 <code>0x74135154</code> 与 <code>0xb1ade4db</code>，同时由于这两个方法都没有参数，因此不用在后面拼接参数。如果 <code>fun1</code> 的方法签名为：</p>
<pre><code class="line-numbers language-solidity">function func1(uint _a) public {}
</code></pre>
<p>那么就需要添加参数，并且补齐 32 字节：</p>
<pre><code>0x254e43db0000000000000000000000000000000000000000000000000000000000000001
</code></pre><p>其中 <code>0x254e43db</code> 是 <code>func1(uint256)</code> 的哈希值前 4 个字节。</p>
<p>接下来我们就来看看在调用合约方法的过程中，在 EVM 字节码层面会发生什么。我们以调用 <code>func1</code> 方法为例，那么此时交易的 <code>data</code> 域内容就为 <code>0x74135154</code>。</p>
<p>我们先将 <code>runtime bytecode</code> 部分的字节码与其 opcodes 一一对应起来：</p>
<pre><code>0 -&gt; 60 PUSH1
1 -&gt; 80 0x80
2 -&gt; 60 PUSH1
3 -&gt; 40 0x40
4 -&gt; 52 MSTORE
5 -&gt; 34 CALLVALUE
6 -&gt; 80 DUP1
7 -&gt; 15 ISZERO
8 -&gt; 60 PUSH1
9 -&gt; 0f 0xF
10 -&gt; 57 JUMPI
11 -&gt; 60 PUSH1
12 -&gt; 00 0x0
13 -&gt; 80 DUP1
14 -&gt; fd REVERT
15 -&gt; 5b JUMPDEST
16 -&gt; 50 POP
17 -&gt; 60 PUSH1
18 -&gt; 04 0x4
19 -&gt; 36 CALLDATASIZE
20 -&gt; 10 LT
21 -&gt; 60 PUSH1
22 -&gt; 32 0x32
23 -&gt; 57 JUMPI
24 -&gt; 60 PUSH1
25 -&gt; 00 0x0
26 -&gt; 35 CALLDATALOAD
27 -&gt; 60 PUSH1
28 -&gt; e0 0xE0
29 -&gt; 1c SHR
30 -&gt; 80 DUP1
31 -&gt; 63 PUSH4
(32 ~ 35) -&gt; 74135154 func1 方法签名哈希前四字节
36 -&gt; 14 EQ
37 -&gt; 60 PUSH1
38 -&gt; 37 0x37
39 -&gt; 57 JUMPI
40 -&gt; 80 DUP1
41 -&gt; 63 PUSH4
(42 ~ 45) -&gt; b1ade4db func2 方法签名哈希前四字节
46 -&gt; 14 EQ
47 -&gt; 60 PUSH1
48 -&gt; 3f 0x3F
49 -&gt; 57 JUMPI
50 -&gt; 5b JUMPDEST
51 -&gt; 60 PUSH1
52 -&gt; 00 0x0
53 -&gt; 80 DUP1
54 -&gt; fd REVERT
55 -&gt; 5b JUMPDEST
56 -&gt; 60 PUSH1
57 -&gt; 3d 0x3D
58 -&gt; 60 PUSH1
59 -&gt; 47 0x47
60 -&gt; 56 JUMP
61 -&gt; 5b JUMPDEST
62 -&gt; 00 STOP
63 -&gt; 5b JUMPDEST
64 -&gt; 60 PUSH1
65 -&gt; 45 0x45
66 -&gt; 60 PUSH1
67 -&gt; 49 0x49
68 -&gt; 56 JUMP
69 -&gt; 5b JUMPDEST
70 -&gt; 00 STOP
71 -&gt; 5b JUMPDEST
72 -&gt; 56 JUMP
73 -&gt; 5b JUMPDEST
74 -&gt; 56 JUMP
</code></pre><p>来看看这部分字节码都干了些什么。</p>
<h2 id="调用合约方法流程"><a href="#调用合约方法流程" class="headerlink" title="调用合约方法流程"></a>调用合约方法流程</h2><p>0 - 4 行我们已经非常熟悉了，加载空闲内存指针。</p>
<p>5 - 14 行是校验 <code>msg.value</code> 必须为零，我们在上篇文章已经看到过这部分了。由于合约中没有 <code>payable</code> 方法，因此要求所有的合约调用的 <code>callvalue</code> 都要为零，否则会在 14 行 <code>REVERT</code> 失败。</p>
<p>如果传入的 <code>value</code> 为零，则进入正常流程 15 行，在 16 行将栈中无用数据 pop 出。</p>
<p>17 - 18 行将 <code>0x4</code> 放入栈中，它代表正常的方法调用签名长度。此时栈为：</p>
<pre><code>| 4
</code></pre><p>19 行获取到 <code>data</code> 域的长度并放入栈中，<code>0x74135154</code> 的长度为 4 个字节。此时栈为：</p>
<pre><code>| 4 | 4
</code></pre><p>20 行从栈中获取两个数据，并判断第一个数字是否小于第二个数字，小于返回 1，否则返回 0。这里由于 4 = 4，因此返回 0。这部分是什么意思呢？上面我们说到第一次放入栈中的 4 代表正常的方法调用签名长度，也就是方法签名前四个字节的意思。无论我们调用了哪个方法，有没有参数，<code>data</code> 域的长度都至少应该是 4。如果某个交易的 <code>data</code> 域的长度小于 4，说明它并不是正常的方法调用，那么在接下来的流程中肯定就走不到正常的方法名匹配部分，要么交易失败，要么进入到 <code>fallback</code> 的调用流程中。我们这个例子中没有声明 <code>fallback</code> 方法，因此如果这时 <code>LT</code> 操作符返回 1（即 TRUE），交易就会失败。</p>
<p>在这里正常情况下，此时栈中为：</p>
<pre><code>| 0
</code></pre><p>21 - 22 行将 <code>0x32</code> 放入栈中：</p>
<pre><code>| 0 | 0x32
</code></pre><p>23 行 <code>JUMPI(0x32, 0)</code> 操作符根据栈中数据判断是否跳转。由于第二个参数是 0，因此不跳转，继续向下执行。这里假设第二个参数是 1，也就是上一步中的 <code>data</code> 域长度小于 4 字节，流程会跳转到 <code>0x32</code>，也就是 50 行，并最终在 54 行 <code>REVERT</code> 交易失败，验证了我们上面的说法。</p>
<p>24 - 25 行将 <code>0x0</code> 放入栈中：</p>
<pre><code>| 0
</code></pre><p>26 行加载 32 字节长度的 <code>data</code> 域放入栈中，开始位置从栈中获取，这里即为 <code>calldata[0]</code>，当前的 <code>data</code> 域内容为 <code>0x74135154</code>，不够 32 字节因此需要用 0 补齐。此时栈中为：</p>
<pre><code>| 7413515400000000000000000000000000000000000000000000000000000000
</code></pre><p>27 - 28 行将 <code>0xE0</code>，即 224 放入栈中：</p>
<pre><code>| 0x7413515400000000000000000000000000000000000000000000000000000000 | 0xE0
</code></pre><p>29 行 <code>SHR</code> 取出栈中数据，将 <code>7413515400000000000000000000000000000000000000000000000000000000</code> 右移 224 位，前者的长度是 256（即 64 * 4） 位，右移之后变成 <code>0x74135154</code>，刚好是四个字节，这四个字节恰好是方法签名哈希值的前四个字节，是用来匹配合约中的方法的。此时栈为：</p>
<pre><code>| 0x74135154
</code></pre><p>30 行复制一份栈顶数据：</p>
<pre><code>| 0x74135154 | 0x74135154
</code></pre><p>31 - 35 将 <code>func1</code> 的方法签名哈希前四个字节放入栈中：</p>
<pre><code>| 0x74135154 | 0x74135154 | 0x74135154
</code></pre><p>36 行 <code>EQ</code> 判断栈顶两个元素是否相等，这里相等，因此返回 1:</p>
<pre><code>| 0x74135154 | 1
</code></pre><p>37 - 38 将 <code>0x37</code> 放入栈中：</p>
<pre><code>| 0x74135154 | 1 ｜ 0x37
</code></pre><p>39 行 <code>JUMPI(0x37, 1)</code> 判断是否跳转，此时会跳转到 <code>0x37</code>，即 55 行。栈为：</p>
<pre><code>| 0x74135154
</code></pre><p>这里如果第二个参数，也就是 <code>EQ</code> 的结果为 0，说明调用的方法与当前的方法不匹配，则不跳转，继续向下运行，寻找下一个方法签名进行匹配。</p>
<p>此时，我们已经找到了相匹配的合约方法，也就是说已经完成了匹配方法名的过程。接下来就是执行方法体内容了。</p>
<p>跳转到 55 行，56 - 59 将 <code>0x3D</code> 与 <code>0x47</code> 放入栈中：</p>
<pre><code>| 0x74135154 | 0x3D | 0x47
</code></pre><p>其中，<code>0x47</code>，即 71 是 <code>func1</code> 方法体所在的字节码开始位置。</p>
<p>60 行 <code>JUMP</code> 跳转到 71 行执行 <code>func1</code> 方法体，此时栈为：</p>
<pre><code>| 0x74135154 | 0x3D
</code></pre><p>由于 <code>func1</code> 内容为空，因此不需要执行什么操作。</p>
<p>72 行获取栈顶元素 <code>0x3D</code>，即 61，并跳转。</p>
<p>61 - 62 行这里会进行方法调用的结尾工作，通过 <code>STOP</code> 结束。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章我们学习了合约方法调用在字节码层面的实现。我们通过一个简单的合约，了解了合约方法调用过程中，用户的请求是如何匹配到具体的方法的。其实内容也比较简单，就是在栈中与所有的方法签名哈希值一个一个进行比对，如果相同，则跳转到相应的部分执行对应方法内容。这里还是建议大家都亲手去 <a href="https://www.evm.codes/playground" target="_blank" rel="noopener">evm.codes</a> 这个网站去实际操作一下，感受整个流程中内存与栈内容的变化，会加深对整个流程的理解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leftasexercise.com/2021/09/08/a-deep-dive-into-solidity-function-selectors-encoding-and-state-variables/" target="_blank" rel="noopener">A deep-dive into Solidity – function selectors, encoding and state variables</a></p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/dsU7KoQLyqiHrY0bQX2ETq1zkDYiW-3PtzxfzGwRdss" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethers.js 简明使用教程</title>
    <url>/2022/08/12/Ethereum-2022-08-12-Ethers-js-%E7%AE%80%E6%98%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Ethers.js 简明使用教程 </blockquote>

<a id="more"></a>
<p><code>Ethers.js</code> 是一个与 <code>EVM-compatible</code> 区块链交互的 JavaScript 库。用户通过编写 JavaScript 代码就可以与区块链进行交互，包括读写等操作。同时还有一个名为 <code>web3.js</code> 的库也可以与区块链交互，与之相比，<code>Ethers.js</code> 更加轻量级，上手更加简单。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>npm install --save ethers</p>
</blockquote>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><pre><code class="line-numbers language-javascript">// 需要导入 ethers 包
const { ethers } = require(&quot;ethers&quot;);

// 构建 provider，可以理解为与区块链交互的桥梁
// 1. 可使用最基础的 JsonRpcProvider 进行构建 provider
const INFURA_ID = &#39;xxx..&#39;;
const provider = new ethers.providers.JsonRpcProvider(`https://mainnet.infura.io/v3/${INFURA_ID}`);

// 2. 也可使用封装好的特定 provider，例如 AlchemyProvider，InfuraProvider
// 使用 alchemy 的时候，第一个参数若为 null 则代表主网
const ALCHEMY_ID = `xxx...`;
const provider = new ethers.providers.AlchemyProvider(&#39;null&#39;, ALCHEMY_ID);
</code></pre>
<p>接下来我们看看一些常用的函数：</p>
<pre><code class="line-numbers language-javascript">// 获取当前网络最新的区块号 
let blockNumber = await provider.getBlockNumber(); 

// 获取余额，参数为地址，返回值是 bignumber 格式，单位为 wei
let balance = await provider.getBalance(&quot;0x...&quot;);

// 将 wei 格式转化为 ether 格式，bignumber 和 toString 格式都可以作为参数
let balance_in_ether = ethers.utils.formatEther(balance);

// 将 ether 转换为 wei 格式，返回值为 bignumber 格式
let result = ethers.utils.parseEther(&quot;1.0&quot;);

// 获取 gas price，返回值为 bignumber 格式
let gasPrice = await provider.getGasPrice();

// 获取内存 storage slot
// 第一个参数是合约地址，第二个参数是插槽位置
// 插槽位置可以使用十进制或者十六进制，十六进制需要加引号
await provider.getStorageAt(&quot;0x...&quot;, 3);
await provider.getStorageAt(&quot;0x...&quot;, &quot;0x121&quot;);

// 获取地址的 nonce
await provider.getTransactionCount(&quot;0x...&quot;);
</code></pre>
<p>注意上面返回值为 <code>bignumber</code> 格式的数据，如果要在控制台打印，需要使用 <code>toString()</code> 进行转换。同时，由于 JavaScript 中的语法限制，所有 <code>await</code> 的语句都要放在 <code>async</code> 函数中。也就是说，要执行带有 <code>await</code> 的语句，必须为：</p>
<pre><code class="line-numbers language-javascript">const main = async () =&gt; {
    let gasPrice = await provider.getGasPrice();
}

main();
</code></pre>
<h2 id="构建钱包信息"><a href="#构建钱包信息" class="headerlink" title="构建钱包信息"></a>构建钱包信息</h2><pre><code class="line-numbers language-javascript">// 构建钱包有两种方法
// 1. 直接通过 provider 和 私钥 构建
const privateKey1 = `0x...` // Private key of account 1
const wallet = new ethers.Wallet(privateKey1, provider);

// 2. 先通过 私钥 构建钱包，然后连接 provider
wallet = new ethers.Wallet(privateKey1);
walletSigner = wallet.connect(provider);

// 获取钱包地址
let address = await wallet.getAddress();
</code></pre>
<h2 id="发送链上原生货币（例如-ETH，BNB）"><a href="#发送链上原生货币（例如-ETH，BNB）" class="headerlink" title="发送链上原生货币（例如 ETH，BNB）"></a>发送链上原生货币（例如 ETH，BNB）</h2><pre><code class="line-numbers language-javascript">// eth 转账
const tx = await wallet.sendTransaction({
    to: wallet2.getAddress(),
    value: ethers.utils.parseEther(&quot;100&quot;)
});

// 等待交易上链
await tx.wait();
// 打印交易信息
console.log(tx);
</code></pre>
<h2 id="构建合约"><a href="#构建合约" class="headerlink" title="构建合约"></a>构建合约</h2><pre><code class="line-numbers language-javascript">// 可以直接通过 函数签名 构建 abi
// 需要用到哪个函数就写哪个，不需要写出全部的函数签名
const ERC20_ABI = [
    &quot;function name() public view returns (string)&quot;,
    &quot;function symbol() view returns (string)&quot;,
    &quot;function totalSupply() view returns (uint256)&quot;,
    &quot;function balanceOf(address) view returns (uint)&quot;,

    &quot;event Transfer(address indexed from, address indexed to, uint amount)&quot;
];

// 合约地址
const address = &#39;0x...&#39;;
// 通过 地址，abi，provider 构建合约对象
const contract = new ethers.Contract(address, ERC20_ABI, provider);
</code></pre>
<h2 id="调用合约只读方法"><a href="#调用合约只读方法" class="headerlink" title="调用合约只读方法"></a>调用合约只读方法</h2><pre><code class="line-numbers language-javascript">// 读取 name() 的值
const name = await contract.name();
console.log(name.toString());

// 读取 symbol() 的值
const symbol = await contract.symbol();
console.log(symbol);

// 读取 ERC20 合约中 balanceOf 的值
const balance = await contract.balanceOf(&#39;0x....&#39;);
console.log(balance.toString());
</code></pre>
<h2 id="调用合约的写方法"><a href="#调用合约的写方法" class="headerlink" title="调用合约的写方法"></a>调用合约的写方法</h2><pre><code class="line-numbers language-javascript">// 获取钱包的 ERC20 余额
const balance = await contract.balanceOf(wallet.getAddress());

// 合约连接钱包对象
const contractWithWallet = contract.connect(wallet);

// 调用合约的 transfer 方法向其他账户转账
// 注意这里是调用 ERC20 合约的 transfer 函数，而不是原生货币转账
// 如果要调用 approve 函数，则为 contractWithWallet.approve
const tx = await contractWithWallet.transfer(&#39;0x...&#39;, balance);
// 等待交易上链
await tx.wait();

console.log(tx);
</code></pre>
<h2 id="实时监听合约事件"><a href="#实时监听合约事件" class="headerlink" title="实时监听合约事件"></a>实时监听合约事件</h2><pre><code class="line-numbers language-javascript">// Transfer 事件要在 abi 中声明
// 括号中的参数分别对应 Transfer 事件的参数
contract.on(&quot;Transfer&quot;, (from, to, amount, event) =&gt; {
    console.log(`${from} sent ${ethers.utils.formatEther(amount)} to ${to}`);
});

// 这里是指定参数的监听行为
// 例如，我只想监听接收人是 `0x1234....` 的事件，那么就这样指定地址
// 构造一个 filter，然后通过 filter 筛选
filter = contract.filters.Transfer(null, &#39;0x1234....&#39;);

// Receive an event when that filter occurs
contract.on(filter, (from, to, amount, event) =&gt; {
    // The to will always be &quot;address&quot;
    console.log(`I got ${ethers.utils.formatEther(amount)} from ${from}.`);
});
</code></pre>
<h2 id="设置范围，扫描指定区块范围的事件"><a href="#设置范围，扫描指定区块范围的事件" class="headerlink" title="设置范围，扫描指定区块范围的事件"></a>设置范围，扫描指定区块范围的事件</h2><pre><code class="line-numbers language-javascript">// 创建 指定发送人是 myAddress 的 filter
const myAddress = `0x...`;
filterFrom = contract.filters.Transfer(myAddress, null);

// 创建 指定接收人是 myAddress 的 filter
filterTo = contract.filters.Transfer(null, myAddress);
// 扫描指定区块的范围

console.log(await contract.queryFilter(filterFrom, 14692250, 14693250))

// 扫描最近 1000 个区块
console.log(await contract.queryFilter(filterFrom, -1000))

// 扫描所有区块
await daiContract.queryFilter(filterTo)
</code></pre>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><pre><code class="line-numbers language-javascript">// 签名 utf-8
const signature = await wallet.signMessage(&#39;hello world&#39;);
console.log(signature);

// 更常见的 case 是签名 hash，长度为 32 字节
// 注意签名十六进制时，必须要将其转换为数组格式

// This string is 66 characters long
message = &quot;0x4c8f18581c0167eb90a761b4a304e009b924f03b619a0c0e8ea3adfce20aee64&quot;;
// This array representation is 32 bytes long
messageBytes = ethers.utils.arrayify(message);

// To sign a hash, you most often want to sign the bytes
const signature2 = await wallet.signMessage(messageBytes);
console.log(signature2);
</code></pre>
<h2 id="指定调用合约时的一些参数"><a href="#指定调用合约时的一些参数" class="headerlink" title="指定调用合约时的一些参数"></a>指定调用合约时的一些参数</h2><pre><code class="line-numbers language-javascript">// 我们上面在做一些写操作，例如转 ETH，写合约等操作时
// 使用的 gasLimit、gasPrice，都是由链上获取的默认数值
// 如果想要手动指定，需要添加一个额外的参数
// 声明一个对象，填写需要覆盖的字段，例如
let overrides = {
    gasLimit: 230000,
    maxFeePerGas: ethers.utils.parseUnits(&#39;12&#39;, &#39;gwei&#39;),
    maxPriorityFeePerGas: ethers.utils.parseUnits(&#39;3&#39;, &#39;gwei&#39;),
    nonce: (await provider.getTransactionCount(wallet.getAddress()))
}
// 将 overrides 作为最后一个参数
await walletWithSigner.transfer(wallet2.getAddress(), amount, overrides)
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文列出了一些常用的用法，作为基本的使用基本够用了。查询更多方法可以查询 <code>Ethers.js</code> 的<a href="https://docs.ethers.io/v5/" target="_blank" rel="noopener">官方文档</a>。总的来说，<code>Ethers.js</code> 还是比较简单的，上手也比较快。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.ethers.io/v5/" target="_blank" rel="noopener">Documentation</a></p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/hT78s8EI3wYp-IixUC951fQNWTON-EhNcGd2jXEtcdM" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>Ethers.js</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 EVM（一）</title>
    <url>/2022/08/27/Ethereum-2022-08-27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-EVM%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解 EVM（一） </blockquote>

<a id="more"></a>
<p>今天我们来聊聊 EVM，那么什么是 EVM？EVM 其实就是执行 bytecode（字节码）的机器，它的全称是 Ethereum Virtual Machine（以太坊虚拟机），和 Java 的 JVM 很类似。我们平时写合约都是用 Solidity （或者 Vyper）编写的，但是这种语言机器是没有办法理解的，我们需要先使用编译器进行编译，编译后的结果是一串二进制码，EVM 可以理解这些二进制的东西，因此它就可以执行这些代码，从而完成一笔交易。</p>
<h2 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h2><p>我们用一个简单的图示来解释这个过程：</p>
<p><img src="/upload_image/2022-08-27-深入理解 EVM1/1.png" alt></p>
<p>我们从一个很简单的例子开始（文件命名为 Demo.sol）：</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

contract Demo {
    uint256 a;
    constructor() {
      a = 1;
    }
}
</code></pre>
<p>我们平时开发项目用的都是 <code>hardhat</code>，<code>forge</code> 这种框架，他们的底层都是通过 <code>solc</code> 来进行编译。这次我们就直接使用编译工具 <code>solc</code> 来进行编译，可以参考<a href="https://docs.soliditylang.org/en/v0.8.15/installing-solidity.html" target="_blank" rel="noopener">这里</a>进行安装。这里列出 Mac 的安装方法：</p>
<pre><code>brew update
brew upgrade
brew tap ethereum/ethereum
brew install solidity
</code></pre><p>安装完成后，我们来编译试试，使用下面的命令：</p>
<blockquote>
<p>solc Demo.sol --bin</p>
</blockquote>
<p>输出以下内容：</p>
<pre><code>======= Demo.sol:Demo =======
Binary:
6080604052348015600f57600080fd5b506001600081905550603f8060256000396000f3fe6080604052600080fdfea26469706673582212204ca38d4a605f03f1487b9cb337c0853cca3c62a6c42f942ecb021fb7357002b564736f6c634300080f0033
</code></pre><p>我们看到在结果中输出了一串 16 进制字符，这就是上面的合约经过编译过后的字节码。我们前面说过，字节码是一串二进制的字符，这里显示为 16 进制方便阅读。注意到我们在命令中指定了 <code>--bin</code> 参数，因此输出的是 16 进制。</p>
<p>第一眼看见这串字符是不是已经懵了，别慌，我们慢慢来研究。首先，我们需要知道，<strong>EVM 的核心实际上是一个 stack machine（栈机器）</strong>，它会接受操作符和操作数，学过数据结构的朋友应该都了解栈的原理。其次，上面这些字符都是由操作符和操作数组成的。例如开头的 <code>60</code> 代表的是 <code>PUSH1</code>，也就是将后面的一个字节（这里是 <code>80</code>）压入栈中。后面又是一个 <code>60</code>，接着是 <code>40</code>，即代表将 <code>40</code> 压入栈中。后面是 <code>52</code>，代表 <code>MSTORE</code>，它需要消耗两个操作数，需要从栈中获取。也就是说，上面的 <code>6080604052</code>，就代表着：</p>
<pre><code>PUSH1 0x80
PUSH1 0x40
MSTORE
</code></pre><p>MSTORE 的两个操作数分别为 0x40、0x80，即 MSTORE(0x40, 0x80)，也就是在内存中地址 0x40 处存储了数据 0x80。（这一句不明白没关系，我们先往下看）</p>
<p>现在我们已经明白了<strong>字节码的基本逻辑，它就是由操作符和操作数组成的</strong>。其中两个字符代表一个字节，操作符都是一个字节，但是操作数可能有多个字节。像我们前面看到的 <code>PUSH1</code>，是将后面的一个字节压入栈中，如果是 <code>PUSH4</code>，就是将后面的四个字节压入栈中。一般将操作符称为 Opcodes，<a href="https://www.evm.codes/" target="_blank" rel="noopener">这里</a>可以看到所有的 Opcodes。需要注意的是操作符和操作数有可能重复，例如判断 <code>60</code> 是操作符还是操作数，取决于它在字节码中的位置，并不是绝对的。例如 <code>6060</code>，前面的 <code>60</code> 是操作符，后面的就是操作数，代表 <code>PUSH1 60</code>。</p>
<h2 id="字节码构造"><a href="#字节码构造" class="headerlink" title="字节码构造"></a>字节码构造</h2><p>接下来我们看看字节码的构造，我们在上面的字节码中搜索 <code>fe</code>，可以看到其中有两个 <code>fe</code>，同时查询 Opcodes 对照表，可知 fe 是无效操作符（INVALID）。它的作用其实是分隔符，它将字节码分成了三部分：</p>
<ol>
<li>init bytecode（初始化字节码）</li>
<li>runtime bytecode （运行时字节码）</li>
<li>metadata hash（合约的一些 meta 信息哈希）</li>
</ol>
<p><img src="/upload_image/2022-08-27-深入理解 EVM1/2.png" alt></p>
<p>那么我们前面编译的字节码就被分成了三部分：</p>
<pre><code>6080604052348015600f57600080fd5b506001600081905550603f8060256000396000f3（init bytecode）

6080604052600080fd（runtime bytecode）

a26469706673582212204ca38d4a605f03f1487b9cb337c0853cca3c62a6c42f942ecb021fb7357002b564736f6c634300080f0033（metadata hash）
</code></pre><p>我们先来看看最后这里的 metadata hash，它默认是合约 metadata 文件的 IPFS 哈希值，我们可以使用：</p>
<blockquote>
<p>solc Demo.sol --metadata</p>
</blockquote>
<p>来获取到其 metadata：</p>
<pre><code>{
    &quot;compiler&quot;: {
        &quot;version&quot;: &quot;0.8.15+commit.e14f2714&quot;
    },
    &quot;language&quot;: &quot;Solidity&quot;,
    &quot;output&quot;: {
        &quot;abi&quot;: [
            {
                &quot;inputs&quot;: [],
                &quot;stateMutability&quot;: &quot;nonpayable&quot;,
                &quot;type&quot;: &quot;constructor&quot;
            }
        ],
        &quot;devdoc&quot;: {
            &quot;kind&quot;: &quot;dev&quot;,
            &quot;methods&quot;: {},
            &quot;version&quot;: 1
        },
        &quot;userdoc&quot;: {
            &quot;kind&quot;: &quot;user&quot;,
            &quot;methods&quot;: {},
            &quot;version&quot;: 1
        }
    },
    &quot;settings&quot;: {
        &quot;compilationTarget&quot;: {
            &quot;Demo.sol&quot;: &quot;Demo&quot;
        },
        &quot;evmVersion&quot;: &quot;london&quot;,
        &quot;libraries&quot;: {},
        &quot;metadata&quot;: {
            &quot;bytecodeHash&quot;: &quot;ipfs&quot;
        },
        &quot;optimizer&quot;: {
            &quot;enabled&quot;: false,
            &quot;runs&quot;: 200
        },
        &quot;remappings&quot;: []
    },
    &quot;sources&quot;: {
        &quot;Demo.sol&quot;: {
            &quot;keccak256&quot;: &quot;0xf6e99f20fac61b16466088a9996227f35c4ca82119a846ba19a83698e8e126b1&quot;,
            &quot;license&quot;: &quot;UNLICENSED&quot;,
            &quot;urls&quot;: [
                &quot;bzz-raw://3fda90691cfa365f68a59d5b6bb76f8a0189153cebf93143879521ea309751b8&quot;,
                &quot;dweb:/ipfs/QmP2dVkfPWy3tAriX17tar9phGzC8gqYzutmhEur6dwdiw&quot;
            ]
        }
    },
    &quot;version&quot;: 1
}
</code></pre><p>可以看到其中主要包含了编译器版本，ABI，IPFS 等信息。这部分了解即可，我们平时也用不到这些，详细内容可以查看<a href="https://docs.soliditylang.org/en/latest/metadata.html" target="_blank" rel="noopener">文档</a>。</p>
<p>我们前面提到了一些操作数，例如 0x40、0x80，这些数字是什么意思呢。要了解这些，我们就得先明白 EVM 中的内存布局。前面的<a href="https://tiyanguan.github.io/2022/07/28/Ethereum-2022-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-2-Solidity-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">文章</a>中，我们讲解过内存布局，但是当时讲的实际上是 Storage Layout，也就是状态变量的布局结构。而我们现在要讲的是 Memory Layout。区别在于 Storage 的数据是永久存在于区块链上的，类似于计算机的硬盘数据。而 Memory 的数据只有在发起交易的时候才有，交易完毕，数据全部消失，类似于计算机的内存数据。</p>
<h2 id="合约内存"><a href="#合约内存" class="headerlink" title="合约内存"></a>合约内存</h2><p>Memory 的数据结构就是一个简单的<strong>字节数组</strong>，数据可以以 1 字节（8 位）或者 32 字节（256 位）为单位进行存储，读取时只能以 32 字节为单位读取，但是读取时可以从任意字节处开始读取，不限定于 32 的倍数字节。图示：</p>
<p><img src="/upload_image/2022-08-27-深入理解 EVM1/3.png" alt></p>
<p>用于操作内存的一共有 3 个操作符：</p>
<ul>
<li>MSTORE (x, y) - 在内存 x 处开始存储 32 字节的数据 y</li>
<li>MLOAD (x) - 将内存 x 处开始的 32 字节数据加载到栈中</li>
<li>MSTORE8 (x, y) - 在内存 x 处存储 1 字节数据 y（32字节栈值中的最低有效字节）</li>
</ul>
<p>Solidity 中预留了 4 个 32 字节的插槽（slot），分别是：</p>
<ul>
<li>0x00=00 - 0x3f=63 (64 字节): 哈希方法的暂存空间</li>
<li>0x40=64 - 0x5f=95 (32 字节): 当前已分配内存大小 (也称为空闲内存指针)</li>
<li>0x60=96 - 0x7f=127 (32 字节): 零槽，用作动态内存数组的初始值，永远不能写入值</li>
</ul>
<p>这里面最重要的就是中间这一项，也就是空闲指针。它会指向空闲空间的开始位置，也就是说，要将一个新变量写入内存，给它分配的位置就是空闲指针所指向的位置。需要注意的是，Solidity 中的内存是不会被释放（free）的。</p>
<p>对于空闲指针，它的更新遵守了很简单的原则：</p>
<blockquote>
<p>新的空闲指针位置 = 旧的空闲指针位置 + 分配的数据大小</p>
</blockquote>
<p>上图中我们看到，Solidity 的预留空间已经占据了 128 个字节，因此空闲指针的起始位置就只能从 0x80（128字节） 开始。空闲指针本身是存在于 0x40 位置的。由于我们在函数中的操作均需要在内存中进行，因此首要任务就是要通过空闲指针分配内存，所以我们前面才需要使用 <code>6080604052</code>，也就是 <code>MSTORE(0x40, 0x80)</code>，来加载空闲指针。此时是不是已经有些明白为什么所有的合约都是以 <code>6080604052</code> 开头了（有些老版本合约以 <code>6060604052</code> 开头）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章我们就先介绍到这里，我们学习了合约的编译过程，字节码的构造，以及合约的内存分布。可以多看几遍消化消化。下篇文章我们将介绍合约的部署，也就是 init bytecode 部分，了解 EVM 在合约部署时的运行逻辑。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leftasexercise.com/2021/09/08/a-deep-dive-into-solidity-function-selectors-encoding-and-state-variables/" target="_blank" rel="noopener">A deep-dive into Solidity – function selectors, encoding and state variables</a><br><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-d6b" target="_blank" rel="noopener">EVM Deep Dives: The Path to Shadowy Super Coder</a></p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/GNVcUgKAOEiLyClKeqkmD35ctLu6_XomT3ZDIfV3tz8" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 EVM（二）</title>
    <url>/2022/08/28/Ethereum-2022-08-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-EVM%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解 EVM（二） </blockquote>

<a id="more"></a>
<p>上篇<a href="2022-08-28-深入理解%20EVM（二）.md">文章</a>我们简要介绍了一下合约的<strong>字节码构造</strong>以及<strong>内存布局</strong>，今天我们来从字节码层面聊聊合约的部署过程。</p>
<h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><p>我们来看一个例子：</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

contract Demo {
    constructor() {}
}
</code></pre>
<p>这个合约比上篇文章的还要简单，它什么内容都没有，仅仅有一个合约的框架而已，这样我们就可以不用关心一些额外内容比如变量赋值等，只需关心合约部署的最核心步骤。</p>
<p>先使用 <code>solc</code> 进行编译：</p>
<blockquote>
<p>solc Demo.sol --bin</p>
</blockquote>
<p>编译后的字节码为：</p>
<pre><code>6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220c6a9021ede10c2befd51f04c8bcd9294ea47f79868b9ad6d81af3e41d3b2c2bf64736f6c634300080f0033
</code></pre><p>按照 <code>0xfe</code> 操作符分割后的结果为：</p>
<pre><code>6080604052348015600f57600080fd5b50603f80601d6000396000f3（init bytecode）

6080604052600080fd（runtime bytecode）

a2646970667358221220c6a9021ede10c2befd51f04c8bcd9294ea47f79868b9ad6d81af3e41d3b2c2bf64736f6c634300080f0033（metadata hash）
</code></pre><p>其中 <code>init bytecode</code> 部分就是<strong>合约的部署流程</strong>，我们主要着重于这部分。</p>
<p>我们前面说过，这些字节码对应的其实都是 opcodes，也就是操作符和操作数，我们可以通过</p>
<blockquote>
<p>solc Demo.sol --opcodes</p>
</blockquote>
<p>来得到对应的 opcodes：</p>
<pre><code>PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x3F DUP1 PUSH1 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xC6 0xA9 MUL 0x1E 0xDE LT 0xC2 0xBE REVERT MLOAD CREATE 0x4C DUP12 0xCD SWAP3 SWAP5 0xEA SELFBALANCE 0xF7 SWAP9 PUSH9 0xB9AD6D81AF3E41D3B2 0xC2 0xBF PUSH5 0x736F6C6343 STOP ADDMOD 0xF STOP CALLER
</code></pre><p>我们将 <code>init bytecode</code> 部分的 16 进制字节码与其 opcodes 一一对应起来：</p>
<pre><code>0  -&gt; 60 PUSH1
1  -&gt; 80 0x80
2  -&gt; 60 PUSH1
3  -&gt; 40 0x40
4  -&gt; 52 MSTORE
5  -&gt; 34 CALLVALUE
6  -&gt; 80 DUP1
7  -&gt; 15 ISZERO
8  -&gt; 60 PUSH1
9  -&gt; 0f 0xF
10 -&gt; 57 JUMPI
11 -&gt; 60 PUSH1
12 -&gt; 00 0x0
13 -&gt; 80 DUP1
14 -&gt; fd REVERT
15 -&gt; 5b JUMPDEST
16 -&gt; 50 POP
17 -&gt; 60 PUSH1
18 -&gt; 3f 0x3F
19 -&gt; 80 DUP1
20 -&gt; 60 PUSH1
21 -&gt; 1d 0x1D
22 -&gt; 60 PUSH1
23 -&gt; 00 0x0
24 -&gt; 39 CODECOPY
25 -&gt; 60 PUSH1
26 -&gt; 00 0x0
27 -&gt; f3 RETURN
</code></pre><p>我们今天的目标就是把这些字节码搞懂，看看它都干了些什么。</p>
<h2 id="合约部署流程"><a href="#合约部署流程" class="headerlink" title="合约部署流程"></a>合约部署流程</h2><p>开头的 0 → 4 是我们前面讲过的加载空闲内存指针的过程，即 <code>MSTORE(0x40, 0x80)</code>，此时内存中的数据为（第三行的最后为 80）：</p>
<pre><code>0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000000
</code></pre><p>每一行的长度是 64，即 32 个字节。我们前面说过 <code>0x40</code> - <code>0x5f</code> 内存区域是用来存储空闲内存指针的，对照上面结果，确实如此。</p>
<p>接下来，第 5 行的 <code>CALLVALUE</code>，获取创建合约时发送的 ETH 数量，并存入栈中。我们创建该合约并不需要同时发送 ETH，因此值为 0。此时的栈中数据为（左边是栈底，右边是栈顶，下同）：</p>
<pre><code>| 0
</code></pre><p>第 6 行的 <code>DUP1</code>，会取栈顶第一个元素，也就是 0，并且复制一份，再放入栈中。此时，栈中数据为：</p>
<pre><code>| 0 | 0
</code></pre><p>第 7 行 <code>ISZERO</code>，取出栈顶元素，判断是否为 0，若为 0，返回 1，否则返回 0，最后将结果放入栈中。此时，栈为：</p>
<pre><code>| 0 | 1
</code></pre><p>第 8、9 行，将 0xF 放入栈中。此时，栈为：</p>
<pre><code>| 0 | 1 | F
</code></pre><p>第 10 行，<code>JUMPI</code> 会取出栈顶的两个元素，并将其作为参数，即 <code>JUMPI(F, 1)</code>，如果第二个参数是 1，则跳转到第一个参数，也就是 <code>F</code> 位置，如果不是 1，则不跳转。这里需要跳转，<code>F</code> 是 16 进制中的 15，因此需要跳转到 15 行。这个 15 行，也就是从 0 开始第 15 个字节处。每个操作符都消耗一个字节，操作数也同样消耗字节。此时，栈为：</p>
<pre><code>| 0
</code></pre><p>第 15 行是 <code>JUMPDEST</code>，是跳转的目标位，也就是说，凡是 <code>JUMPI</code> 指令进行跳转，跳转的目标必须是它，它本身并没有什么实际作用，仅仅用做标记位。如果跳转至此，没有该操作符，则流程失败。</p>
<p>第 16 行，<code>POP</code> 会弹出栈顶的元素，即弹出 0。此时栈为空：</p>
<pre><code>|
</code></pre><p>第 17、18 行，<code>PUSH1 3F</code>，即将 <code>0x3F</code> 放入栈中。此时，栈为：</p>
<pre><code>| 3F
</code></pre><p>第 19 行，<code>DUP1</code> 复制栈顶元素。此时，栈为：</p>
<pre><code>| 3F | 3F
</code></pre><p>第 20 到 23 行，连续将两个元素 <code>0x1D</code>、<code>0x0</code> 放入栈中。此时，栈为：</p>
<pre><code>| 3F | 3F | 1D | 0
</code></pre><p>第 24 行，<code>CODECOPY</code>，将当前运行环境中的字节码复制到内存中，接收 3 个参数，分别是<strong>目标内存位置</strong>、<strong>要复制数据的起始位置</strong>、<strong>复制长度</strong>。这里是 <code>CODECOPY(0, 1D, 3F)</code>，即从字节码中的 <code>1D</code> 起始，复制长度为 <code>3F</code> 的字节码到内存位置 <code>0</code> 处。</p>
<p>我们来看看这几个参数是什么意思，首先第一个参数是说将结果都放在 0 开始的内存处，这个好理解。第二个参数 <code>1D</code>，换成 10 进制是 <code>29</code>，我们前面看的 <code>init bytecode</code> 部分一共有 27 行（算上 0 行有 28 行），由于我们是按照 <code>0xfe</code> 来将其分割的，因此按照全部字节码来说，<code>0xfe</code> 是位于第 28 行的，而第 29 行开始的部分就是 <code>runtime bytecode</code> 了。也就是说，我们需要从 <code>runtime bytecode</code> 处开始复制代码，长度是 <code>0x3F</code>，即 10 进制的 <code>63</code>。我们再来看整体的字节码，从 <code>runtime bytecode</code> 处的 <code>6080604052…</code> 开始的字节码，一直到最后，长度是 <code>126</code>，恰好是 <code>63</code> 个字节。</p>
<p>也就是说，我们将除了 <code>init bytecode</code> 部分的 <code>runtime bytecode</code> 与 <code>metadata hash</code> 复制到了内存中。此时，内存中数据为：</p>
<pre><code>6080604052600080fdfea2646970667358221220c6a9021ede10c2befd51f04c
8bcd9294ea47f79868b9ad6d81af3e41d3b2c2bf64736f6c634300080f003300
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000000
</code></pre><p>同时，栈中数据为：</p>
<pre><code>| 3F
</code></pre><p>接下来，第 25、26 行，<code>PUSH1 0x0</code> 将 <code>0</code> 放入了栈中。此时，栈为：</p>
<pre><code>| 3F | 0
</code></pre><p>最后，第 27 行，<code>RETURN</code> 从内存中读取数据并返回给 EVM，并结束流程。它接收两个参数，分别是起始位置以及长度，即 <code>RETURN(0, 3F)</code>。前面我们说了 <code>0x3F</code> 是 <code>runtime bytecode</code> 与 <code>metadata hash</code> 的长度，也就说从内存中读取了这两部分的数据，并返回。即返回值为：</p>
<pre><code>6080604052600080fdfea2646970667358221220c6a9021ede10c2befd51f04c
8bcd9294ea47f79868b9ad6d81af3e41d3b2c2bf64736f6c634300080f0033
</code></pre><p>此时，栈中数据已经清空。</p>
<p>现在，我们已经走完了部署的整个流程，可以看到，整个部署的流程主要就是简单的两步：</p>
<ol>
<li>运行构造函数的逻辑</li>
<li>获取 <code>runtime bytecode</code> 与 <code>metadata hash</code> 的内容并返回给 EVM</li>
</ol>
<p>接下来我们回到第 5 行，这里我们获取了 <code>CALLVALUE</code>，前面的流程中值为 0。现在我们假设在创建合约的同时也发送了 ETH，那么这里得到的就是非零值，这里我们假设是在创建合约时同时发送了 1 wei（只要是非零值结果都一样），那么栈中为：</p>
<pre><code>| 1
</code></pre><p>第 6 行 <code>DUP1</code>，复制后栈为：</p>
<pre><code>| 1 | 1
</code></pre><p>第 7 行 <code>ISZERO</code>，由于栈顶非零，因此结果为 0，此时栈中为：</p>
<pre><code>| 1 | 0
</code></pre><p>第 8、9 行，将 <code>0xF</code> 放入栈中。此时，栈为：</p>
<pre><code>| 1 | 0 | F
</code></pre><p>第 10 行，<code>JUMPI(F, 0)</code>，由于第二个参数是 0，因此不跳转，继续向下执行。</p>
<p>第 11、12 行，<code>PUSH1 0x0</code> 将 <code>0</code> 放入栈中：</p>
<pre><code>| 1 | 0
</code></pre><p>第 13 行 <code>DUP1</code>，此时栈为：</p>
<pre><code>| 1 | 0 | 0
</code></pre><p>第 14 行 <code>REVERT</code>，抛出错误，流程以失败结束。</p>
<p>那么我们说的这个 <code>CALLVALUE</code> 0 或者非 0，到底是什么意思呢？</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

contract Demo {
    constructor() {}
}
</code></pre>
<p>看看代码，其实就是因为合约中的构造函数没有 <code>payable</code> 关键字，禁止向合约中发送 ETH。因此在字节码中需要对此进行判断。那么我们就会想到，如果加上了 <code>payable</code> 之后，字节码会怎样呢？</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

contract Demo {
    constructor() payable {}
}
</code></pre>
<p>编译后的字节码：</p>
<pre><code>6080604052603f8060116000396000f3（init bytecode）

6080604052600080fd（runtime bytecode）

a26469706673582212208c516264e3e6785d014f2db856266d96d155fdd72ef5e53ecc896b5837f13cc664736f6c634300080f0033（metadata hash）
</code></pre><p>这时我们看到 <code>init bytecode</code> 部分短了很多，其实就是去掉了判断 <code>CALLVALUE</code> 的部分。我们再将其与 opcodes 一一对应：</p>
<pre><code>0  -&gt; 60 PUSH1
1  -&gt; 80 0x80
2  -&gt; 60 PUSH1
3  -&gt; 40 0x40
4  -&gt; 52 MSTORE
5  -&gt; 60 PUSH1
6  -&gt; 3f 0x3F
7  -&gt; 80 DUP1
8  -&gt; 60 PUSH1
9  -&gt; 11 0x11
10 -&gt; 60 PUSH1
11 -&gt; 00 0x0
12 -&gt; 39 CODECOPY
13 -&gt; 60 PUSH1
14 -&gt; 00 0x0
15 -&gt; f3 RETURN
</code></pre><p>我们再简单过一下流程。</p>
<p>0 → 4: <code>MSTORE(0x40, 0x80)</code>，内存为：</p>
<pre><code>0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000000
</code></pre><p>5 → 6: <code>PUSH1 0x3F</code></p>
<pre><code>| 3F
</code></pre><p>7: <code>DUP1</code></p>
<pre><code>| 3F | 3F
</code></pre><p>8 → 9: <code>PUSH1 0x11</code></p>
<pre><code>| 3F | 3F | 11
</code></pre><p>10 → 11: <code>PUSH1 0x0</code></p>
<pre><code>| 3F | 3F | 11 | 0
</code></pre><p>12: <code>CODECOPY(0, 11, 3F)</code>，此时内存为：</p>
<pre><code>6080604052600080fdfea26469706673582212208c516264e3e6785d014f2db8
56266d96d155fdd72ef5e53ecc896b5837f13cc664736f6c634300080f003300
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000000
</code></pre><p>13 → 14: <code>PUSH1 0x0</code></p>
<pre><code>| 3F | 0
</code></pre><p>15: <code>RETURN(0, 3F)</code>，内存中前 <code>3F</code> 个字节，即</p>
<pre><code>6080604052600080fdfea26469706673582212208c516264e3e6785d014f2db8
56266d96d155fdd72ef5e53ecc896b5837f13cc664736f6c634300080f0033
</code></pre><p>我们看到，由于构造函数中有 <code>payable</code> 关键字，也就是发不发送 ETH 都可以，对应于字节码的整个流程中确实没有了对于 <code>CALLVALUE</code> 的判断。</p>
<h2 id="实际部署合约"><a href="#实际部署合约" class="headerlink" title="实际部署合约"></a>实际部署合约</h2><p>我们从字节码方面走完了整个部署流程，那么我们来实际部署一个合约，来看看具体交易的细节。仍然使用最开始的合约：</p>
<pre><code class="line-numbers language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.15;

contract Demo {
    constructor() {}
}
</code></pre>
<p>通过 <code>Remix</code> 或者其它工具进行部署。我在 <code>Rinkeby</code> 上部署了合约，部署的交易哈希是：</p>
<pre><code>0x039c306e0ac3ad5f8a972185d2094a977b1bef97694e2872f975f70e6db4a241
</code></pre><p>利用 <code>Ethersjs</code> 读取交易详情：</p>
<p><img src="/upload_image/2022-08-28-深入理解 EVM2/1.png" alt="部署交易详情" title="部署交易详情"></p>
<p>从图中注意到两点，一个是 <code>to</code> 字段为空，一个是 <code>data</code> 字段恰好就是我们前面编译合约之后得到的字节码，这也正是<strong>部署合约交易的两个特点</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章我们学习了字节码层面的合约部署流程，我们以最简单的合约为例，逐一走过了整个流程。对于有更复杂操作的合约，原理都一样，只不过是多了一些变量赋值等操作。这里强烈推荐 <a href="https://www.evm.codes/playground" target="_blank" rel="noopener">evm.codes</a> 这个网站，将字节码放进去，我们就可以一步一步观察到实际的内存与栈中的数据，分析字节码会更加直观。</p>
<p>下篇文章我们来聊聊合约方法调用的过程，仍然是从字节码层面分析，相对会更加复杂一点，不过也更加有趣。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/6vqE2DRsMzlPNmh3kYiwTdMBj-9hanmxyDuTHM7tZDU" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>EVM</tag>
      </tags>
  </entry>
</search>
