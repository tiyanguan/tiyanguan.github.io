<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解合约升级(1) - 概括</title>
    <url>/2022/07/27/Ethereum-2022-07-27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-1-%E6%A6%82%E6%8B%AC/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(1) - 概括 </blockquote>

<a id="more"></a>
<p>这篇文章开始，我将用一个系列的文章详细介绍智能合约升级原理，尽量会以 Solidity 初学者的角度来探究，同时也能帮助自己更加巩固对这个知识点的了解。</p>
<h2 id="了解合约升级"><a href="#了解合约升级" class="headerlink" title="了解合约升级"></a>了解合约升级</h2><p>我们知道，区块链上的内容都是不可变的，一旦数据上链之后，那么便是不可修改的。智能合约也是一样，部署在链上之后，合约本身的代码便是不可修改的，如果部署之后发现了合约中有 bug，那就完全没办法，只能另外部署一份合约了。其实这样也是有好处的，因为如果一份合约没有问题的话，那么也就代表它能够一直正确运行，而没有人能够修改合约的运行逻辑，真正达到的 <code>Code is law</code> 的理念。</p>
<p>但是，作为项目开发而言，这样就不是很友好了。首先，如果代码中有 bug，无法修改，如果这个 bug 是关乎用户 token 转账等场景，可能会造成用户的资产永久锁死在合约中。其次，项目发展是一个长期的过程，不可能一开始就能把所有的功能都考虑到。如果后期想要添加功能，那么就只能更换合约，并且需要用户手动操作，将旧合约中的数据（资产）转移到新合约中，这样可能会造成用户的困扰。</p>
<p>那么我们自然想到，合约开发能不能也可以像传统互联网开发那样，有问题随时修改，并且对于用户是无感知的呢？这时就引入了我们要介绍的合约升级的概念。</p>
<h2 id="合约如何升级"><a href="#合约如何升级" class="headerlink" title="合约如何升级"></a>合约如何升级</h2><p>首先，我们来看传统的合约调用逻辑：</p>
<p><img src="/upload_image/2022-07-27-深入理解合约升级1/1.png" alt></p>
<p>用户最初与旧合约进行交互，如果更新了新的合约，那么用户需要更换交互地址，迁移数据。新旧合约分别保存了各自的数据，两者互不关联。那么如果我们想要做成前面说的无感知升级，该怎么操作呢？</p>
<p>我们知道，合约本身是不能更改的，那么我们考虑，能不能用一种代理人的方式，也就是说，我们去调用一个代理合约，代理合约将我们发送的请求，也就是函数调用，转发给实际执行逻辑的合约，当需要更换新合约的时候，只需要在代理合约转发请求时，将请求发送给新的合约地址就可以了。而用户对这一切是不知道的，因为用户自始至终都是与代理合约做交互。来看看一个简单的图示：</p>
<p><img src="/upload_image/2022-07-27-深入理解合约升级1/2.png" alt></p>
<p>如图中所示，我们在实际执行逻辑的合约前面加了一个代理合约，用户一直是与代理合约交互，开始时代理合约将请求转发给旧合约，当需要升级时，部署一个新的合约，同时代理合约会将请求转发给新合约，这样对于用户来说就是无感知的。</p>
<p>但是这里还有一个问题，我们前面说到，在传统合约模式中，用户是需要将数据从旧合约迁移到新合约中的，现在加了一个代理合约，请求是转发过去了，那么数据怎么办呢，用户的 token 不是还在旧合约中吗？此时，我们应该想到，其实代理合约不仅仅是起到转发请求的作用，而且承载了所有的合约数据，包括用户的 token 也都是存放在代理合约中，右边的逻辑合约也就仅仅是实现逻辑而已，不保存任何数据：</p>
<p><img src="/upload_image/2022-07-27-深入理解合约升级1/3.png" alt></p>
<p>这样一来，我们就能随意更换逻辑合约，而不用担心数据迁移问题。也就是说，我们已经做到了和传统互联网开发一样，能够对合约进行升级。这样对于用户体验和项目方维护来说都是一个很大的优点。</p>
<p>那么既然合约升级这么好，为什么不是所有的项目都采用可升级合约呢？前面我们说到，可升级与不可升级之间，各自都是有利有弊的，这取决于项目方的权衡。</p>
<p>对于可升级合约来说，好处是优化用户体验，利于项目方维护。而坏处就是项目方可以随时更改后面的逻辑合约作恶，将用户的 token 转走，这对于用户来说是无能为力的。（现在有很多项目的升级权限都是由多签管理，但是仍然存在风险）</p>
<p>相对应的，对于不可升级合约，一切都写在了代码中，真正实现了 <code>Code is law</code> 的理念，即使项目方自己也不能随意更改合约，操纵用户资产。例如 <code>Uniswap</code> 的合约都是不可升级的，用户在与其进行交互时，是可以放心将资产放在上面的。但是代价就是项目开发时要做到各种测试，包括项目审计也要做很多遍，因为一旦部署，就无法更改了。（这里并不是说使用了可升级合约就可以省去这些安全步骤，安全一定是合约开发的重中之重，只是说可升级合约即使发现了 bug，也可以后期修改）</p>
<p>综合而言，两者都有各自的优缺点，取决于项目方的考虑与权衡。但要注意的是，并不是说不可升级合约就一定是安全的项目方，而可升级的合约就一定是是不安全的项目方。项目方之间差距也很大，例如 <a href="https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#code" target="_blank" rel="noopener">USDC</a> 就是可升级合约，但是 USDC 几乎可以说是不会作恶的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过代理合约模式可以实现合约升级，对于用户是无感知的。同时合约升级也是有利有弊，需要针对具体场景判断选择哪种模式。</p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/RZscMYGkeGTY8z6ccHseY8HKu-ER3pX0mFYoWXRqXQ0" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解合约升级(2) - Solidity 内存布局</title>
    <url>/2022/07/28/Ethereum-2022-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7-2-Solidity-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 深入理解合约升级(2) - Solidity 内存布局 </blockquote>

<a id="more"></a>
<p>这篇文章我们来学习一下 Solidity 的内存布局。首先我们需要明白，我们这里谈到的内存是 Solidity 合约中的状态变量，而不是在函数方法中定义的临时变量。前者是存在于以太坊的存储结构中的，而后者只是运行时的临时内存变量。例如：</p>
<pre><code class="solidity">contract Storage {
    uint256 public a;
    bytes32 public b;

    function foo() public {
        uint256 c;
    }
}
</code></pre>
<p>这段代码中，变量 <code>a</code> 和 <code>b</code> 是状态变量，属于我们讨论的范围，而 <code>c</code> 不属于，因为它是运行时临时变量。</p>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Solidity 中的内存布局，有一个插槽（slot）的概念。每一个合约，都有 <code>2 ^ 256</code> 个内存插槽用于存储状态变量，但是这些插槽并不是实际存在的，也就是说，并没有实际占用了这么多空间，而是按需分配，用到时就会分配，不用时就不存在。插槽数量的上限是 <code>2 ^ 256</code>，每个插槽的大小是 <code>32</code> 个字节。图示如下：</p>
<p><img src="/upload_image/2022-07-28-深入理解合约升级2/1.png" alt></p>
<p>Solidity 中有这么多的数据类型，它们都是怎么存储在这些插槽中的呢？我们来看看。</p>
<h2 id="插槽分配"><a href="#插槽分配" class="headerlink" title="插槽分配"></a>插槽分配</h2><h3 id="固定长度类型"><a href="#固定长度类型" class="headerlink" title="固定长度类型"></a>固定长度类型</h3><p>我们知道，Solidity 中的数据类型有很多，常见的有 <code>uint</code>，<code>bytes(n)</code>， <code>address</code>，<code>bool</code>，<code>string</code> 等等。其中 <code>uint</code> 还有不同长度的，比如 <code>uint8</code>，<code>uint256</code> 等，<code>bytes(n)</code> 也包括 <code>bytes2</code>，<code>bytes32</code> 等。还有 <code>mapping</code> 以及 <code>数组</code> 类型等。前面提到过，一个插槽的大小是 32 个字节，那么像 <code>uint256</code>，<code>bytes32</code> 这些 32 字节大小的类型就可以刚好放在一个插槽中。</p>
<p>来看一个简单的例子：</p>
<pre><code class="solidity">contract Storage {
    uint256 public a;
    uint256 public b;
    uint256 public c;

    function foo() public {
        a = 1;
        b = 2;
        c = 123;
    }
}
</code></pre>
<p>上面的合约中，<code>a</code>,<code>b</code>,<code>c</code> 三个变量都是 <code>uint256</code> 类型的，恰好每个变量都占用了一个插槽，分别是插槽0，1，2。我们部署合约，调用 <code>foo</code> 函数，读取它们的值来确认一下：</p>
<pre><code class="Solidity">const {ethers} = require(&quot;ethers&quot;);
const provider = new ethers.providers.JsonRpcProvider()

const main = async () =&gt; {
    // 第一个参数是部署的合约地址
    // 第二个参数是插槽的位置，这里注意，如果是十进制，就直接写数字
    // 如果是十六进制，需要加上引号，例如 &#39;0x0&#39;
    let a = await provider.getStorageAt(
        &quot;0x4ed7c70F96B99c776995fB64377f0d4aB3B0e1C1&quot;,
        0
    )
    console.log(a)
}

main()
</code></pre>
<p>这段代码使用了 ethersjs 库来读取合约插槽的数据，也可以使用其他的方法，例如 Python 可以使用 web3py 库。</p>
<p>我们分别读取0，1，2三个插槽的数据，分别为</p>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000001</p>
</blockquote>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000002</p>
</blockquote>
<blockquote>
<p>0x000000000000000000000000000000000000000000000000000000000000007b</p>
</blockquote>
<p>对应的 10 进制数为 1，2，123，验证正确。</p>
<p>我们再对上面的合约做一点小小的改动：</p>
<pre><code class="solidity">uint8 public a;
uint8 public b;
uint256 public c;
</code></pre>
<p>同样，我们部署并调用 <code>foo</code> 函数，再读取其插槽值，我们可以看到，插槽 0 的数据变成了：</p>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000201</p>
</blockquote>
<p>而插槽 1 的数据变成了：</p>
<blockquote>
<p>0x000000000000000000000000000000000000000000000000000000000000007b</p>
</blockquote>
<p>插槽 2 直接就没有数据了，这是为什么呢？因为一个插槽的大小是 32 字节，而 <code>a</code> 和 <code>b</code> 都只占用 1 个字节，Solidity 为了节省存储空间，会将它俩放在同一个插槽中，而下一个 <code>c</code> 变量，由于它占用了 32 字节，因此它要占用下一个插槽。</p>
<p>那么我们再做一点小改动，将 <code>b</code> 和 <code>c</code> 调换位置:</p>
<pre><code class="solidity">uint8 public a;
uint256 public c;
uint8 public b;
</code></pre>
<p>此时我们再去查看插槽数据，会发现，三个变量都各自占据了一个插槽，这是因为，虽然 <code>a</code> 只占据了插槽 0 中的 1 个字节，但是由于下一个变量 <code>c</code> 要占据一整个插槽，所以 <code>c</code> 只能去下一个插槽，那么 <code>b</code> 也就只能去第三个插槽了。</p>
<p>这里带给我们的思考就是，在开发合约时，内存的布局分配也是很重要的，合理地分配内存布局可以节省内存空间，也就节省了 gas 费用。</p>
<p>前面我们提到的 <code>bytes(n)</code> 类型，和 <code>uint</code> 类似，也是同样的道理。同时还有 <code>bool</code> 类型，它只占用 1 个字节。<code>address</code> 类型，占用 20 个字节。因此在开发过程中，可以将一些小字节类型放在一起，从而节省 gas 费用。</p>
<h2 id="非固定长度类型"><a href="#非固定长度类型" class="headerlink" title="非固定长度类型"></a>非固定长度类型</h2><p>上面我们说到的，都是定长的数据类型。而像 <code>string</code>，<code>bytes</code> 这种非固定长度的类型，它们的存储规则是：</p>
<ol>
<li>如果数据长度小于等于 <code>31</code> 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。</li>
<li>如果数据长度超出 <code>31</code> 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</li>
</ol>
<p>来看一个实际的例子验证一下：</p>
<pre><code class="solidity">contract Storage {
    string public a;
    string public b;

    function foo() public {
        // a是31个字节，b是32个字节
        a = &#39;abcabcabcabcabcabcabcabcabcabca&#39;;
        b = &#39;abcabcabcabcabcabcabcabcabcabcab&#39;;
    }
}
</code></pre>
<p>查看插槽 0 和 1 的值，分别为：</p>
<blockquote>
<p>0x616263616263616263616263616263616263616263616263616263616263613e（最后一个字节存储长度 0x3e，即 62 = 31 * 2）</p>
</blockquote>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000041（最后一个字节存储长度 0x41，即 65 = 32 * 2 + 1）</p>
</blockquote>
<p>我们再去看看 keccak256(slot) 中存储的值，通过</p>
<pre><code class="solidity">keccak256(abi.encode(1));
</code></pre>
<p>计算出哈希值，这也就是插槽的位置，再去读取其值：</p>
<pre><code class="solidity">// 第二个参数为插槽的位置，使用 ethersjs 库需要加引号，否则报错
let a = await provider.getStorageAt(
    &quot;0x4ed7c70F96B99c776995fB64377f0d4aB3B0e1C1&quot;,
&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;
)
</code></pre>
<p>结果为：</p>
<blockquote>
<p>0x6162636162636162636162636162636162636162636162636162636162636162</p>
</blockquote>
<p>验证成功，注意我们这里的使用的是数据长度恰好为 32 字节，如果大于 32 字节，那么剩余的长度就会继续往下一个插槽【即 <code>keccak256(abi.encode(1)) + 1</code> 】延伸。</p>
<p>接下来我们看看 <code>mapping</code> 和 <code>数组</code> 类型是怎么存储的。</p>
<p>对于 <code>mapping</code> 类型，规则是：</p>
<ol>
<li>所处的插槽，空置，不存储内容，</li>
<li><code>mapping</code> 中的数据，存储在插槽 <code>keccak256(key.slot)</code> 中，也就是：</li>
</ol>
<pre><code class="solidity">keccak256(abi.encode(key, slot))
</code></pre>
<p>来看一个例子：</p>
<pre><code class="solidity">contract Storage {
    mapping(uint256 =&gt; uint256) public a;

    function foo() public {
        a[1] = 123;
        a[2] = 345;
    }
}
</code></pre>
<p>通过 <code>keccak256(abi.encode(1, 0))</code> 和 <code>keccak256(abi.encode(2, 0))</code> 分别计算出， <code>a[1]</code> 和 <code>a[2]</code> 所处的插槽位置为：</p>
<blockquote>
<p>0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</p>
</blockquote>
<blockquote>
<p>0xabbb5caa7dda850e60932de0934eb1f9d0f59695050f761dc64e443e5030a569</p>
</blockquote>
<p>我们进行验证，插槽 0 的值为 0，上述这两个插槽的值分别为：</p>
<blockquote>
<p>0x000000000000000000000000000000000000000000000000000000000000007b</p>
</blockquote>
<blockquote>
<p>0x0000000000000000000000000000000000000000000000000000000000000159</p>
</blockquote>
<p>即分别为 123 和 345，验证成功。</p>
<p>再来看看数组类型，它所满足的规则是：</p>
<ol>
<li>所处的插槽，存储数组的长度</li>
<li>数组内存储的元素，存储在以 <code>keccak256(slot)</code> 插槽开始的位置</li>
</ol>
<p>同样来看一个例子：</p>
<pre><code class="solidity">contract Storage {
    uint256[] public a;

    function foo() public {
        a.push(12);
        a.push(34);
    }
}
</code></pre>
<p>运行 <code>foo</code> 函数后，插槽 0 值就变成了 2，这里注意，如果运行了两次 <code>foo</code>，那么就变成了 4，因为数组的长度变成了 4。我们来计算 <code>keccak256(abi.encode(0))</code> 的值为：</p>
<blockquote>
<p>0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</p>
</blockquote>
<p>查询其插槽上的值为 12，再看看下一个插槽【即 <code>keccak256(abi.encode(0)) + 1</code> 】的值为 34，满足规则。</p>
<p>对于组合类型，例如 <code>mapping(uint256 =&gt; uint256[])</code>，那么就按照组合的规则，从外到里进行计算即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Solidity 中的内存布局，都严格遵守既定规则，并不是杂乱无章的。理解了内存布局，对于我们后面学习可升级合约，帮助很大。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html" target="_blank" rel="noopener">docs.soliditylang.org</a><br><a href="https://learnblockchain.cn/books/geth/part7/storage.html" target="_blank" rel="noopener">learnblockchain.cn</a><br><a href="http://aandds.com/blog/solidity-storage-layout.html" target="_blank" rel="noopener">aandds.com</a></p>
<h2 id="合约升级系列文章"><a href="#合约升级系列文章" class="headerlink" title="合约升级系列文章"></a>合约升级系列文章</h2><ol>
<li><a href>深入理解合约升级(1) - 概括</a></li>
<li><a href>深入理解合约升级(2) - Solidity 内存布局</a></li>
<li><a href>深入理解合约升级(3) - call 与 delegatecall</a></li>
<li><a href>深入理解合约升级(4) - 合约升级原理的代码实现</a></li>
<li><a href>深入理解合约升级(5) - 部署一个可升级合约</a></li>
</ol>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://mirror.xyz/xyyme.eth/5eu3_7f7275rqY-fNMUP5BKS8izV9Tshmv8Z5H9bsec" target="_blank" rel="noopener">原文链接</a></h2>]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>合约升级</tag>
      </tags>
  </entry>
</search>
