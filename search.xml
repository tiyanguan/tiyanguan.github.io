<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UML 类图</title>
    <url>/2018/02/02/Design-Pattern-2018-02-02-UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> UML 类图 </blockquote>

<a id="more"></a>
<h2 id="类的图示（Class）"><a href="#类的图示（Class）" class="headerlink" title="类的图示（Class）"></a>类的图示（Class）</h2><p><img src="/upload_image/uml01.png" alt="Java 类图" title="图1-1 Person 类图"></p>
<h3 id="类图分三层"><a href="#类图分三层" class="headerlink" title="类图分三层"></a>类图分三层</h3><ol>
<li>类的名称，如果是抽象类就用斜体显示。</li>
<li>类的特性，通常是字段和属性。</li>
<li>类的操作，通常是方法或行为。</li>
</ol>
<h3 id="Java-四种访问权限在类图中的表示"><a href="#Java-四种访问权限在类图中的表示" class="headerlink" title="Java 四种访问权限在类图中的表示"></a>Java 四种访问权限在类图中的表示</h3><p>访问范围由大到小为：public、protected、default（即什么都不写）、private；‘+’表示 public，‘#’表示 protected，‘-’表示 private，什么都不写就表示 default 了。</p>
<h3 id="分析图-1-1-Person-类图"><a href="#分析图-1-1-Person-类图" class="headerlink" title="分析图 1-1 Person 类图"></a>分析图 1-1 Person 类图</h3><p>第一行：类的名称为：Person；如果为抽象类，则<i>“Person”</i>采用斜体。<br>第二行：类的属性为：name ；“:”冒号前面表示属性的名字，后面表示属性的类型，还可以给属性赋初值。<br>第三行：类的方法：“&lt;&lt;Getter&gt;&gt;”或“&lt;&lt;Setter&gt;&gt;”表示方法的注释，可有可无，只是起到一个标记作用而已；冒号前面是方法的名字，注意方法的名字后面都是要带<b>括号</b>的“()”;冒号后面是方法的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的图示（interface）"><a href="#接口的图示（interface）" class="headerlink" title="接口的图示（interface）"></a>接口的图示（interface）</h2><p>接口的 UML 图有两种表示方法：<br>1、名称上面 &lt;&lt;interface&gt;&gt; 用这个标识它是一个接口<br>2、「棒棒糖」表示法，圆圈旁边为接口名称，接口方法在实现类中出现</p>
<h2 id="UML-关系图"><a href="#UML-关系图" class="headerlink" title="UML 关系图"></a>UML 关系图</h2><p><img src="/upload_image/uml02.png" alt="UML 类图" title="UML 类图"></p>
<h2 id="继承关系「即泛化关系」"><a href="#继承关系「即泛化关系」" class="headerlink" title="继承关系「即泛化关系」"></a>继承关系「即泛化关系」</h2><blockquote>
<p>继承关系用<b>空心三角形 + 实线</b>来表示<br>注意指向：子类指向父类（即空心三角形在父类这边）<br>助解：因为父类可以有多个子类，所以就会聚集成一个三角形，而子类则是一个线头的点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承了 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String StudentNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><blockquote>
<p>实现接口用<b>空心三角形 + 虚线</b>来表示<br>注意指向：子类指向接口（即空心三角形在接口这边）<br>助解：因为接口可以有多个实现，所以也会聚集成一个三角形，而子类则是一个线头的点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Say</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"person say ..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>关联关系表示一类对象与另一类对象之间有联系，通常将一个类的对象作为另一个类的成员变量来表示关联关系</p>
<blockquote>
<p>关联关系用<b>实线箭头</b>表示<br>注意指向：箭头由引用类指向被引用类，表示引用类 要引用 被引用类的东西<br>助解：比如企鹅需要知道气候，而企鹅和气候是两个类，那么现在企鹅类中用到了气候类，所以企鹅依赖气候<br>因为企鹅需要知道气候的变化，即当一个类需要知道另一个类时，可以用关联关系<br>关联关系有：单向关联、双向关联、自身关联、多重性关联</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 气候类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 企鹅类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 企鹅需要知道气候，所以这里引用了气候类，表示企鹅这个类引用了气候类,即一个类中有另一个类的引用</span></span><br><span class="line">    <span class="keyword">private</span> Weather weather;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。</p>
<blockquote>
<p>依赖关系用<b>虚线箭头</b>表示<br>注意指向：箭头由依赖方指向被被依赖方，表示依赖方 依赖于 被依赖方提供的东西<br>助解：动物生存依赖氧气、水，注意这里是动物的生存依赖氧气、水，不是动物本身依赖，动物要是挂了就不需要了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 汽车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver 类的方法使用了 Car 类对象作为方法的参数，即要想开车，必须先有车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        car.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联关系-vs-依赖关系"><a href="#关联关系-vs-依赖关系" class="headerlink" title="关联关系 vs 依赖关系"></a>关联关系 vs 依赖关系</h2><p>依赖关系：是一种 使用关系。一个类 A 使用到了另一个类 B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是 B 类的变化会影响到 A。例如：客户使用产品需要提供者，产品的变更会影响客户的使用，但一个客户需要的产品可以有多个提供者。即一个类可能同时依赖多个类。</p>
<p>关联关系：是一种 结构关系。它指明一个事物的对象与另一个事物的对象之间的联系。关联关系比依赖关系更强，不存在依赖关系的偶然性，关系也不是临时性的，而一般是长期性的。例如：商品和订单，订单中包含商品信息。</p>
<p>小结：</p>
<ul>
<li>依赖关系是一种 使用关系，即类 A 在做某个动作的时候依赖到了其他对象类 B。</li>
<li>关联关系是一种 结构关系，即类 A 中存在类 B，指明了类 A 对象和 类 B 对象之间的联系。</li>
</ul>
<h2 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h2><p>聚合是一种弱的「拥有」关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分</p>
<blockquote>
<p>聚合关系用<b>空心的菱形 + 实线箭头</b>表示<br>注意指向：空心的菱形放在聚合的群体那边，箭头指向群体中的每个个体<br>助解：大雁和雁群，因为大雁聚合形成雁群，则空心菱形表示聚合形成堆了，而箭头表示单个点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大雁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goose</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 雁群</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GooseGroup</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 雁群类中有大雁的集合</span></span><br><span class="line">    <span class="keyword">private</span> Goose[] gooseList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合成关系「即组合关系」"><a href="#合成关系「即组合关系」" class="headerlink" title="合成关系「即组合关系」"></a>合成关系「即组合关系」</h2><p>合成是一种强的「拥有」关系，提现了严格的部分和整体的关系，部分和整体的生命周期一样</p>
<blockquote>
<p>合成关系用<b>实心的菱形 + 实线箭头</b>表示<br>注意指向：实心的菱形放在合成的整体那边，箭头指向部分，即用来合成整体的部件<br>助解：鸟和翅膀，部分和整体且生命周期一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翅膀</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wing</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Wing wing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成鸟类的同时生成翅膀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wing = <span class="keyword">new</span> Wing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考列表：<br>《大话设计模式》<br>[深入浅出UML类图]<a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="noopener">http://www.uml.org.cn/oobject/201211231.asp</a><br>[UML基础系列：类图]<a href="http://www.cnblogs.com/lsgxeva/p/7720224.html" target="_blank" rel="noopener">http://www.cnblogs.com/lsgxeva/p/7720224.html</a></p>
<p>感觉不错：<br>[Java类与类之间的5种关系及uml表示]<a href="https://blog.csdn.net/pj36536/article/details/53101764" target="_blank" rel="noopener">https://blog.csdn.net/pj36536/article/details/53101764</a><br>[UML类图与类的关系详解]<a href="https://blog.csdn.net/sinat_30397435/article/details/79018467" target="_blank" rel="noopener">https://blog.csdn.net/sinat_30397435/article/details/79018467</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(二)</title>
    <url>/2018/09/12/English-2018-09-12-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%BA%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(二) —— 主谓宾 </blockquote>

<a id="more"></a>
<p>1、他整天没地方去也没事儿干。<br>He goes nowhere and has nothing to do every day.</p>
<p>2、她天天在哪儿吃午饭？<br>Where does she have lunch every day?</p>
<p>3、你怎么不常和他们一块儿来？<br>Why don’t you often come with them?</p>
<p>4、王芳有姐姐吗？<br>Does WangFang have any sisters?</p>
<p>5、为什么他总听你的而不听我的？我不知道。<br>Why does he always listen to you but doesn’t listen to me? I don’t know.</p>
<p>6、他了解你多少？你非常了解他吗？<br>How much does he know you? Do you know him very well?</p>
<p>7、你们每周怎么去那儿?<br>How do you get there every week?</p>
<p>8、李梅不知道那事儿，但我知道。<br>LiMei doesn’t know that but me.</p>
<p>9、每天下班后，Tod 都载我回家。<br>Tod picks me up home after work every day.</p>
<p>10、这些小狗都叫什么？它的名字是 TianTian,那只叫 LeLe。<br>What are these dogs’ names? Its name is TianTian, that is called LeLe.</p>
<p>11、他准时上学并及时做作业。<br>He goes to school on time and does his homework in time.</p>
<p>12、没人相信他，因为他经常撒谎。他太丢人了。<br>Nobody believes him because he often tell lies. He is very shameful.</p>
<p>13、你妈把我的手表放什么里边了？<br>what does your mother put my watch in?</p>
<p>14、我像他，但却不喜欢他。<br>I am like hime, but I don’t like him.</p>
<p>15、你这么辛苦工作是为了什么？<br>what do you work hard for?</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>on time 准时<br>in time 及时</p>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(一)</title>
    <url>/2018/09/11/English-2018-09-11-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(一) —— 主系表 </blockquote>

<a id="more"></a>
<p>1、我姐姐在那儿吗？她和谁在一起呢？</p>
<blockquote>
<p>我的：Is my sister at there? whom is my sister with?<br>答案：Is my sister there? whom is she with?</p>
</blockquote>
<p>解析：there 在这里是名词，表示哪个地方的意思，所以不用 at。问句中用她来指代我姐姐。</p>
<p>2、我妈妈没在家，她和街坊出去了。</p>
<blockquote>
<p>我的：My mother is not at home, she is with neighborhood out.<br>答案：My mother is not at home, she is out with some neighbors.</p>
</blockquote>
<p>解析：out 在 这里是形容词，表示外面的。</p>
<p>3、那本书怎么样？它在你的手里吗？</p>
<blockquote>
<p>我的：How is that book? Is it in your hand?<br>答案：</p>
</blockquote>
<p>4、这是给我的，那些是给谁的？</p>
<blockquote>
<p>我的：This is for me, whom are those for?<br>答案：</p>
</blockquote>
<p>5、Sam Sterm 根本就没在这儿，他每天在二楼办公。</p>
<blockquote>
<p>我的：Sam Sterm is not here at all, he is at second floor everday.<br>答案：Sam Sterm is not here at all, he is at work on the 2nd floor ever day.</p>
</blockquote>
<p>解析：在工作用 at work 表示，在二楼用 at 2nd floor 表示，everday 是形容词每天的，而不是每天，这个是副词。</p>
<p>6、他是干什么的？他不是经理吗？</p>
<blockquote>
<p>我的：What is he? Is not he a manager?<br>答案：</p>
</blockquote>
<p>7、你的小狗在哪儿？它在什么里边？</p>
<blockquote>
<p>我的：Where is your dog? What is it in?<br>答案：</p>
</blockquote>
<p>8、这是谁的办公室？里边有人吗？哪间办公室是你的？</p>
<blockquote>
<p>我的：Whom is this office? Who is in the office? Which is your  office?<br>答案：Whose office is this? Is anyone in? Which office is yours?</p>
</blockquote>
<p>9、我的电话出了毛病，手机在哪儿？</p>
<blockquote>
<p>我的：My phone is wrong, where is cell phone?<br>答案：Something is wrong with my telephone,where is the cellphone?</p>
</blockquote>
<p>10、电视开着呢，把它关上吧！</p>
<blockquote>
<p>我的：The TV is on, turn it off!<br>答案：</p>
</blockquote>
<p>11、我的备份没在你的电脑里吗？</p>
<blockquote>
<p>我的：Is not my copy in your computer?<br>答案：</p>
</blockquote>
<p>12、这是干什么用的？</p>
<blockquote>
<p>我的：What is this for?<br>答案：</p>
</blockquote>
<p>13、我的手机昨天就在这儿放着呢!</p>
<blockquote>
<p>我的：My cellphone was right here yesterday!<br>答案：</p>
</blockquote>
<p>14、这个书包是谁的？那是谁的书包？我的在这儿！她的呢？  </p>
<blockquote>
<p>我的：Whose bag is this? Whose bag is that? My bag is here! Where is her bag?<br>答案：Whose is this bag? Whose bag is that? Mine is here! where is hers?</p>
</blockquote>
<p>15、这本字典不像我的，但那本像。  </p>
<blockquote>
<p>我的：This dictionary is not like mine,bug that is like.<br>答案：This dictionary is not like mine,bug that one is.</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、注意区分以下两种形式：<br>Whose is this bag？这个包是谁的？ This bag is whose.<br>Whose bag is this？这是谁的包？   This is whose bag.</p>
<p>2、区分 我、你、他 这些代词的各种形式：  </p>
<table>
<thead>
<tr>
<th>主格</th>
<th>宾格</th>
<th>属格</th>
<th>属格(名词性)</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>me</td>
<td>my</td>
<td>mine</td>
</tr>
<tr>
<td>you</td>
<td>your</td>
<td>your</td>
<td>yours</td>
</tr>
<tr>
<td>he</td>
<td>him</td>
<td>his</td>
<td>his</td>
</tr>
<tr>
<td>she</td>
<td>her</td>
<td>her</td>
<td>hers</td>
</tr>
<tr>
<td>it</td>
<td>its</td>
<td>its</td>
<td>its</td>
</tr>
<tr>
<td>they</td>
<td>them</td>
<td>their</td>
<td>theirs</td>
</tr>
</tbody>
</table>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://zhidao.baidu.com/question/140269" target="_blank" rel="noopener">英语代词有哪些？</a></p>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(五)</title>
    <url>/2019/03/27/English-2019-03-27-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%BA%94/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(五) —— there be </blockquote>

<a id="more"></a>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、地上有水吗？那儿有多少水？</p>
<p>2、办公室里有几台电脑？</p>
<p>3、什么里面有邮票？</p>
<p>4、Tom 的书包里有面包吗？</p>
<p>5、这里不该有学生，他们这时候应该在教室里学习。</p>
<p>6、去年家里哪儿有旧书？</p>
<p>7、什么在桌上？桌上有什么？</p>
<p>8、明年我校将有 40 个班和 100 个老师。</p>
<p>9、那儿一定有餐厅吗？</p>
<p>10、过去这个村庄前边有一条小河。</p>
<p>11、为什么二月份只有 28 天？</p>
<p>12、从前有座山，山上有座庙。</p>
<p>13、哪儿有好老师我就到哪儿去学。</p>
<p>14、咱们学校什么时候有过实验室呀？</p>
<p>15、只有不良的教育，没有不好的学生。</p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol>
<li><p>Is there any water on the ground? How much water is there?</p>
</li>
<li><p>How many computers are there in the office?</p>
</li>
<li><p>what are there any stamps in?</p>
</li>
<li><p>Is there any bread in Tom’s bag?</p>
</li>
<li><p>Here shouldn’t be any students. They should be studying in the classroom now.</p>
</li>
<li><p>Where were there any old books at home last year?</p>
</li>
<li><p>What is on the desk? what is there on the desk?</p>
</li>
<li><p>There will be 40 classes and 100 teachers in our school next year.</p>
</li>
<li><p>Must there be any restaurants?</p>
</li>
<li><p>There used to be a river in front of this village.</p>
</li>
<li><p>Why are there only 28 days in Feb.?</p>
</li>
<li><p>There was a hill long before, and there was a temple on it.</p>
</li>
<li><p>I’ll go to study where there are some good teachers.</p>
</li>
<li><p>When have there been any laboratories in our school?</p>
</li>
<li><p>There is only a poor education, but there aren’t any poor students.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(四)</title>
    <url>/2019/03/26/English-2019-03-26-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E5%9B%9B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(四) —— 不定式 </blockquote>

<a id="more"></a>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、一言难尽！（一句话说不清楚)</p>
<p>2、他昨天忘记带语文作业了。</p>
<p>3、你喜欢和谁在一起？谁喜欢和你在一起？</p>
<p>4、谁要做这件荒唐的事儿？</p>
<p>5、在家读书和写作是我今天的计划。</p>
<p>6、我还没决定要和谁一起去。</p>
<p>7、他们知道何时出发吗？</p>
<p>8、什么时候出发无所谓，问题是去什么地方。</p>
<p>9、困难的是如何能准时到达那里。</p>
<p>10、听到要回家乡过年使她非常高兴。</p>
<p>11、和他在一起工作使我们情绪非常高涨。</p>
<p>12、天变凉了，睡在这儿太冷。</p>
<p>13、我决定当一名出色的律师。</p>
<p>14、难道你没发现她要生气？</p>
<p>15、男人爱潇洒，女人爱漂亮。</p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol>
<li><p>It is hard to say .(with one word)</p>
</li>
<li><p>He forgot to bring his Chinese homework yesterday.</p>
</li>
<li><p>Whom do you like to be with? Who likes to be with you?</p>
</li>
<li><p>Who wants to do sth. fantastic?</p>
</li>
<li><p>To read and write at home is my plan today.</p>
</li>
<li><p>I haven’t decided yet whom to go with.</p>
</li>
<li><p>Do they know when to set out?</p>
</li>
<li><p>When to set out doesn’t matter, The question is where to go.</p>
</li>
<li><p>What is hard is how to get there on time.</p>
</li>
<li><p>It makes her very happy to hear to spend the New Year in her hometown.</p>
</li>
<li><p>To work with him makes us in high spirits.</p>
</li>
<li><p>The weather is getting cool, to sleep here is very cold.</p>
</li>
<li><p>I decide to be an excellent lawyer.</p>
</li>
<li><p>Don’t you find her to be angry?</p>
</li>
<li><p>Men like to be handsome. Woman like to be pretty.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(三)</title>
    <url>/2018/09/21/English-2018-09-21-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(三) —— 过去时 </blockquote>

<a id="more"></a>
<p>1、你去年经常拜访他们吗？<br>Did you ofter visit them last year?</p>
<p>2、三年前你对这种工作有多少经验？<br>我的：How much experience did you have for this job three years ago?<br>答案：How much experience in this kind of work did you have three years age?  </p>
<p>3、我没及时告诉她，因为我病了。<br>我的：I don’t tell her in time, because i was ill.<br>答案：I din’t tell her in time, because i was ill.</p>
<p>4、我上周就认知他了，可他却一点儿也不了解我。<br>我的：I knew him last week, but he don’t know me little.<br>答案：I knwe him last wekk, but he didn’t know me at all.</p>
<p>5、昨天你和王先生在哪儿？<br>where were you with Mr. Wang yesterday?</p>
<p>6、你见过那个新来的老板了吗？<br>我的：Do you have seen the new boss?<br>答案：Have you seen that new boss?</p>
<p>7、去年她像妈妈，可今年谁也不像。(此处 like 当介词)<br>我的：She was like her mother last year, but she isn’t like anyone this year.<br>答案：She was like her mother last year, but she is like no noe this year.</p>
<p>8、 谁问有关我学习的事儿来着？<br>我的：Who was asked me about my study？<br>答案：Who has asked something about my study?</p>
<p>9、爸爸昨晚没有责怪我。<br>Our father did’t scold me last night.</p>
<p>10、昨天你在哪儿听到的那个消息？我是从报纸上看到的。<br>where did you hear that news yesterday？I read it from the paper.</p>
<p>11、我的电脑又出毛病了。<br>我的：My computer has broken again.<br>答案：Something was wrong again with my computer.</p>
<p>12、昨天我很紧张，你呢？<br>I was very nervous yesterday, and how were you?</p>
<p>13、你们的值日生昨天擦黑板了吗？<br>Did your students on duty clean the blackboard yesterday?</p>
<p>14、今天上午李先生出什么事了？<br>我的：What did happend with Mr.Li this forenoon？<br>答案：What happended to Mr. Li this morning?</p>
<p>15、由于贫穷他去年就辍学了，我们去看看他吧。<br>我的：Because of poverty he droped out school last year, we are looking  at him tomorrow.<br>答案：He quit school last year because of being poor, Let’s go to see him tomorrow.</p>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(六)</title>
    <url>/2019/03/28/English-2019-03-28-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E5%85%AD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(六) —— 定语 </blockquote>

<a id="more"></a>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、王芳手里的那本旧书太贵了。</p>
<p>2、桌子上边的纸箱里装满了碎玻璃。</p>
<p>3、树上的鸟儿成双对。</p>
<p>4、昨天的工作没完成，明天的计划又来了。</p>
<p>5、戴着眼镜的人是来自北京的教授。</p>
<p>6、他喜欢的收音机旧的都没法听了。</p>
<p>7、像 Tim 的那个男孩儿昨天来了吗？</p>
<p>8、家里的电脑比这台容量大。</p>
<p>9、像这种带有更多插图的书都在阅览室里。</p>
<p>10、你告诉我的事儿对我而言非常重要。</p>
<p>11、现在还有带橡皮的铅笔吗？</p>
<p>12、和我哥哥在一起的人是我姐夫。</p>
<p>13、你去过他提到的那个城市吗?</p>
<p>14、没有谁的季节是农民最苦的日子。</p>
<p>15、她脸上的泪水感动了那里的人。</p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol>
<li><p>That old book in wangfang’s hand is very expensive.</p>
</li>
<li><p>The paper box on the desk is full of broken glass.</p>
</li>
<li><p>The birds in trees are in pairs.</p>
</li>
<li><p>The work yesterday was not finished, and the plan tomorrow is coming.</p>
</li>
<li><p>The person with glasses is the professor from Beijing.</p>
</li>
<li><p>The radio he likes is too old to listen to.</p>
</li>
<li><p>Did that boy like Tim come yesterday?</p>
</li>
<li><p>The computer (at) home has more capacity than this one here.</p>
</li>
<li><p>The book with more pictures like this are all in the reading-room.</p>
</li>
<li><p>Sth. you told me is vey important for me.</p>
</li>
<li><p>Are there any pencils with a rubber at present?</p>
</li>
<li><p>The man with my brother is my brother-in-law.</p>
</li>
<li><p>Have you been to that city he mentioned?</p>
</li>
<li><p>The season without any water is the hardest days for the farmers.</p>
</li>
<li><p>Tears on her face moved the people there.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求实英语(七)</title>
    <url>/2019/03/29/English-2019-03-29-%E6%B1%82%E5%AE%9E%E8%8B%B1%E8%AF%AD-%E4%B8%83/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 求实英语(七) —— 祈使句 </blockquote>

<a id="more"></a>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、她胆子小，别吓唬她！</p>
<p>2、递给我那本书，我该学习了。</p>
<p>3、别不好意思，再虚心点儿！</p>
<p>4、在你走之前，先到我这儿来一下！</p>
<p>5、别这么看着我！我很紧张。</p>
<p>6、呆在这儿！哪儿也别去！</p>
<p>7、做个好孩子，别跟 Tom 学！</p>
<p>8、不要放弃你的事业！</p>
<p>9、别嫌弃你妈妈，她为你不容易。</p>
<p>10、好好做人，当个人民的好律师。</p>
<p>11、少说多干！</p>
<p>12、别犹豫了！快走吧！</p>
<p>13、这道菜看着挺好，吃着会怎么样？</p>
<p>14、那个男孩子咋一看倒是挺潇洒。</p>
<p>15、为什么这首歌听起来像京戏？</p>
<p>16、你不像你哥哥，至少长得不像。</p>
<p>17、看上去他一本正经，实际上他什么也不是。</p>
<p>18、那块布料手感怎么样？</p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><ol>
<li><p>Don’t frighten her! She is shy.</p>
</li>
<li><p>Pass me that book! It’s time for me to study.</p>
</li>
<li><p>Don’t by shy! Be more modest!</p>
</li>
<li><p>Come to me before you go!</p>
</li>
<li><p>Don’t look at me in this way! I am very nervous.</p>
</li>
<li><p>Be here! Don’t go anywhere!</p>
</li>
<li><p>Be a good child! Don’t do anything like Tom!</p>
</li>
<li><p>Don’t quit your cause!</p>
</li>
<li><p>Don’t dislike your mother! She is not easy for you.</p>
</li>
<li><p>Behave yourself! Be a competent lawyer for the people.</p>
</li>
<li><p>Speak less and do more!</p>
</li>
<li><p>Don’t hesitate! Hurry up to go!</p>
</li>
<li><p>This dish looks nice, how does it taste?</p>
</li>
<li><p>That boy looks handsome at first glance.</p>
</li>
<li><p>Why does the song sound like Beijing opera?</p>
</li>
<li><p>You are not like your brother, and you don’t look like him at least.</p>
</li>
<li><p>He looks serious , but he is nothing in fact.</p>
</li>
<li><p>How does that cloth feel?</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客搭建总结</title>
    <url>/2018/02/02/Hexo-2018-02-02-Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Hexo 博客搭建总结 </blockquote>

<a id="more"></a>
<p>近期终于下定决定自己搭建一个博客出来了。利用 Hexo+Github+Next， 前后历时差不多一周左右的时间吧，终于把大致框架搭建出来了，剩下的就是小的修修补补了。由于我对前端处于白痴阶段，所以很小的问题都能把我困住，基本上是踩着别人的肩膀一步步走过来的，在此分享下一个白痴搭建的过程，希望你能绕开我走过的坑，少一些为寻找某一个问题而苦苦搜寻的过程，最后祝大家都能顺利搭建成功。如果遇到其他问题留言吧，我乐意帮忙。</p>
<p>下面是我博客搭建过程中踩过的各位大牛的肩膀，希望对你有帮助，在此也真心的感谢他们，不管好坏对错，最后都帮到我了，在我因为一个问题苦苦挣扎寻找的时候，他们的博客或者论坛出现了，帮助我顺利走向下一步，再次谢谢他们。下面是我对他们博客论坛的一些个人过滤，每个里面都有其精华所在，供大家参考。</p>
<p>1、官方文档<br>这个没得说，最最最重要的是它由简体中文版！注意右上角可以切换语言的哦。把它当成一个手册吧，全而细，但我没那个耐心读一遍，索引就跟字典的作用似的。<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a>。</p>
<p>2、博客框架搭建<br>下面这两篇是关于 Hexo 从零开始到搭建完整，比较系统，但细节处理不是特别完美，适合动手搭建整体框架的时候参考，都写的大而详细，里面可能有小瑕疵，注意拉到最后面看评论区，说不定你遇到的坑别人已经踩出来了，还有结合官方文档，综合多方面信息，博主要是在命令里面少打一个空格，对于什么都不懂的你可能执行不下去了，然后就可能放弃掉了。真的很可惜，我们好不容易下次决定还就这么夭折了，那可都是生命啊，请为它们的流逝赋予意义。<a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">Hexo 从零开始到搭建完整</a>，<a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Hexo 搭建博客教程</a>。</p>
<p>3、Next 主题搭建<br>是当前比较好用，且被使用次数最高的主题，如果你采用的是这个主题，那么下面这个内容真的是大而全的帮你设置各种小功能，强烈推荐。<a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">Next 主题搭建</a>。</p>
<p>4、这个是 Next 主题官网的一个配置参考，有些东西看官方的肯定是好的，大全而且还细，但时我没有那个耐心，所以宁愿 Google 答案，也不愿意去看一大堆的文档。<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83" target="_blank" rel="noopener">主题配置参考</a>。</p>
<p>5、Next 主题修缮<br>这个对我帮助挺大的，相见恨晚啊，基本上把我踩过的坑都覆盖到了，讲的很详细，重点读一下，对于白痴的我来说，写的很好，前提是你的博客框架搭建好修缮的过程中用。<a href="http://supermaryy.com/2016/07/02/%E4%BD%BF%E7%94%A8hexo%E8%B8%A9%E5%9D%91%E8%AE%B0/" target="_blank" rel="noopener">Next 主题修缮</a>。</p>
<p>6、<a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">添加分类及标签</a></p>
<p>7、这个是关于主题的，这个问题困扰了我好久，为什么别人的主页跟我的就是不一样的呢，而且 Next 默认的那个主题比较丑，众里寻他千百度，就是这篇博客帮我解决了这个问题，其实 Next 支持三种主题，默认的只是其中一种。<a href="https://runnerliu.github.io/2017/04/01/hexoNexT/" target="_blank" rel="noopener">Hexo 应用 NexT 主题</a>。</p>
<p>8、<a href="https://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">Hexo博客添加评论、打赏、RSS 等功能</a></p>
<p>9、<a href="https://gaodaxiu0406.github.io/2017/08/21/%E4%B8%BAHEXO%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%AF%8F%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E9%87%8F%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">为文章添加热度</a></p>
<p>10、<a href="http://blog.sciencenet.cn/blog-3247241-1139774.html" target="_blank" rel="noopener">不蒜子统计无法显示的原因</a></p>
<p>11、<a href="http://www.yangyong.xyz/2018/01/03/add-hexo-next-post-views/" target="_blank" rel="noopener">博客主页显示文字阅读次数</a></p>
<p>12、<a href="https://www.bluelzy.com/articles/use_valine_for_your_blog.html" target="_blank" rel="noopener">Hexo 添加评论系统 Valine</a></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>还有些我在搭建过程中参考的博客给搞丢了，不过应该都比较好找，比如添加评论区，打赏，是由统计访问点击量啥的，都可以留言问我。尽管我没有了原来的链接，但是我知道怎么去搜索，这个很关键，在搭建博客过程中，我遇到那些问题，都不到输入什么关键词去查询答案，真的很悲催，我就这么悲催过来了，不希望你们再走我悲催的老路。关键是这些弯路走的没必要。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法笔记</title>
    <url>/2018/02/02/Hexo-2018-02-02-Markdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Markdown 语法笔记 </blockquote>

<a id="more"></a>
<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>方式一：使用两个或两个以上 <code>=</code> 或 <code>-</code> 标记<code>一级</code>和<code>二级</code>标题。</p>
<blockquote>
<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code>  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>方式二：使用 <code>#</code>，表示 <code>1-6</code> 级标题。</p>
<blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p>
</blockquote>
<p>效果：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h2 id="2-段落"><a href="#2-段落" class="headerlink" title="2.段落"></a>2.段落</h2><p>段落的<strong>前后</strong>要有<code>空行</code>。在段内强制换行的方式是使用<code>两个或两个以上空格加上回车</code>「<code>注：引用中换行省略回车</code>」。</p>
<h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3.区块引用"></a>3.区块引用</h2><p>在段落的<code>每行</code>或者<code>只在第一行</code>使用符号 <code>&gt;</code>，还可使用多个嵌套引用。</p>
<blockquote>
<p>> 区块引用<br>>&gt; 嵌套引用  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>区块引用  </p>
<blockquote>
<p>嵌套引用</p>
</blockquote>
</blockquote>
<h2 id="4-代码区块"><a href="#4-代码区块" class="headerlink" title="4.代码区块"></a>4.代码区块</h2><p><a href="https://yanchongsheng.github.io/2018/03/15/Hexo%20Next%20%E4%BB%A3%E7%A0%81%E5%9D%97/" target="_blank" rel="noopener">Hexo Next 代码块</a></p>
<h2 id="5-强调"><a href="#5-强调" class="headerlink" title="5.强调"></a>5.强调</h2><p>在强调内容两侧分别加上 <code>*</code> 或者 <code>_</code>。</p>
<blockquote>
<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><em>斜体</em>，_斜体_<br><strong>粗体</strong>，<strong>粗体</strong></p>
</blockquote>
<h2 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h2><p>使用 <code>*</code>、<code>+</code>、<code>-</code> 标记无序列表。注意：标记后面最少有一个<code>空格</code>或<code>制表符</code>。若不在引用区块中，必须和前方段落之间存在空行。</p>
<blockquote>
<p>* 第一项<br>- 第三项<br>+ 第二项  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<ul>
<li>第一项</li>
</ul>
<ul>
<li>第三项</li>
</ul>
<ul>
<li>第二项</li>
</ul>
</blockquote>
<p>有序列表的标记方式是将上述的符号换成数字，并辅以「.」。  </p>
<blockquote>
<p>1. 第一项<br>2. 第二项<br>3. 第三项  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<ol>
<li>第一项  </li>
<li>第二项  </li>
<li>第三项  </li>
</ol>
</blockquote>
<h2 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7.分割线"></a>7.分割线</h2><p>分割线最常使用就是三个或以上「*」，还可以使用「-」或 「_」。</p>
<blockquote>
<p>***<br>---<br>___  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<hr>
</blockquote>
<blockquote>
<hr>
</blockquote>
<blockquote>
<hr>
</blockquote>
<h2 id="8-链接"><a href="#8-链接" class="headerlink" title="8.链接"></a>8.链接</h2><p>链接可以由两种形式生成：行内式和参考式。</p>
<h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><blockquote>
<p>[行内式展示内容](<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> “行内式鼠标悬浮展示内容”)</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><a href="https://github.com/" title="行内式鼠标悬浮展示内容" target="_blank" rel="noopener">行内式展示内容</a></p>
</blockquote>
<h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><blockquote>
<p>[参考式展示内容 1][1]<br>[参考式展示内容 2][2]<br>[1]:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> “参考式鼠标悬浮展示内容 1”<br>[2]:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> “参考式鼠标悬浮展示内容 2”  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>[参考式展示内容 1][1]<br>[参考式展示内容 2][2]<br>[1]:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> “参考式鼠标悬浮展示内容 1”<br>[2]:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> “参考式鼠标悬浮展示内容 2”  </p>
</blockquote>
<h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9.图片"></a>9.图片</h2><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个「！」,也分为行内式和参考式。</p>
<blockquote>
<p>![图片的替代文字](/upload_image/1.jpg “图片标题”)</p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><img src="/upload_image/1.jpg" alt="图片的替代文字" title="图片标题"></p>
</blockquote>
<h2 id="10-反斜杠「-」"><a href="#10-反斜杠「-」" class="headerlink" title="10.反斜杠「\」"></a>10.反斜杠「\」</h2><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。即显示符号本身。</p>
<h2 id="11-符号「-」"><a href="#11-符号「-」" class="headerlink" title="11.符号「`」"></a>11.符号「`」</h2><p>起到标记作用。即加个阴影背景。</p>
<blockquote>
<p>`ctrl + a`  </p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><code>ctrl + a</code></p>
</blockquote>
<h2 id="12-尖括号"><a href="#12-尖括号" class="headerlink" title="12.尖括号"></a>12.尖括号</h2><p>在 Markdown 中「尖括号」会被默认为 HTML 语句，这将导致尖括号本身及尖括号中的内容都不会被显示。所以就必须得使用转义字符才能够表示出「尖括号」。使用 <code>&amp;lt;</code> 代替 <code>&lt;</code>，使用 <code>&amp;gt;</code> 代替 <code>&gt;</code>。</p>
<blockquote>
<p><code>&amp;lt;&amp;lt;</code>西游记<code>&amp;gt;&amp;gt;</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p>&lt;&lt;西游记&gt;&gt;</p>
</blockquote>
<h2 id="13-键盘键"><a href="#13-键盘键" class="headerlink" title="13.键盘键"></a>13.键盘键</h2><blockquote>
<p><code>&lt;kbd&gt;Ctrl+[&lt;/kbd&gt; and &lt;kbd&gt;Ctrl+]&lt;/kbd&gt;</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><kbd>Ctrl+[</kbd> and <kbd>Ctrl+]</kbd></p>
</blockquote>
<h2 id="14-删除线"><a href="#14-删除线" class="headerlink" title="14.删除线"></a>14.删除线</h2><blockquote>
<p><code>~~删除线~~</code></p>
</blockquote>
<p>效果：</p>
<blockquote>
<p><del>删除线</del></p>
</blockquote>
<h2 id="15-反引号"><a href="#15-反引号" class="headerlink" title="15.反引号"></a>15.反引号</h2><h3 id="一个反引号"><a href="#一个反引号" class="headerlink" title="一个反引号"></a>一个反引号</h3><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用「反引号」将代码包起来，它们会解释成 <code>&lt;code&gt;</code>标签。  </p>
<h3 id="两个反引号"><a href="#两个反引号" class="headerlink" title="两个反引号"></a>两个反引号</h3><p>如果代码的「内容中」有反引号，请用两个反引号包裹，与前后两个反引号之间加空格。代码中的&amp;、&lt;、&gt;符号都会自动转义。</p>
<h3 id="三个反引号"><a href="#三个反引号" class="headerlink" title="三个反引号"></a>三个反引号</h3><p>如果引用的语句为多行，可以将三个反引号<code>`</code>置于这段代码的首行和末行。</p>
<h2 id="16-其它「表格」"><a href="#16-其它「表格」" class="headerlink" title="16.其它「表格」"></a>16.其它「表格」</h2><p>列表的使用(非traditonal markdown)用 <code>|</code> 表示表格<strong>纵向边界</strong>，表头和表内容用 <code>-</code> 隔开，并可用 <code>:</code> 进行对齐设置，两边都有 <code>:</code> 则表示居中，若不加 <code>:</code> 则默认左对齐。</p>
<table>
<thead>
<tr>
<th>一个普通标题</th>
<th>一个普通标题</th>
<th>一个普通标题</th>
</tr>
</thead>
<tbody>
<tr>
<td>短文本</td>
<td>中等文本</td>
<td>稍微长一点的文本</td>
</tr>
<tr>
<td>稍微长一点的文本</td>
<td>短文本</td>
<td>中等文本</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐标题</th>
<th style="text-align:right">右对齐标题</th>
<th style="text-align:center">居中对齐标题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">短文本</td>
<td style="text-align:right">中等文本</td>
<td style="text-align:center">稍微长一点的文本</td>
</tr>
<tr>
<td style="text-align:left">稍微长一点的文本</td>
<td style="text-align:right">短文本</td>
<td style="text-align:center">中等文本</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Markdown 只是帮助我们排版的工具，重要的还是内容，它是一篇文章的灵魂。好看的皮囊千篇一律，有趣的灵魂万里挑一。Markdown 就是赋予你灵魂一个好看的皮囊，但如果你没有有趣的灵魂，其他的全是扯淡。所以 Markdown 看一遍就行了，大致了解，然后动手写，不会的去查然后调整一下就好了，适应一段时间你就完全脱离了。使用 Markdown 的最高境界永远都是：笔下是语法，心中格式化。你达到了吗？</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">Markdown 基本语法</a><br><a href="http://xianbai.me/learn-md/article/syntax/emphasis.html" target="_blank" rel="noopener">Markdown 入门参考</a><br><a href="https://laravel-china.org/topics/621/you-will-be-able-to-master-these-markdown-grammars" target="_blank" rel="noopener">Markdown 语法精讲</a><br><a href="https://coding.net/help/doc/project/markdown.html#i" target="_blank" rel="noopener">Markdown 语法介绍</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 搜索功能</title>
    <url>/2018/03/14/Hexo-2018-03-14-HexoNext%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 它侧身于生活的污泥中，虽不甘心，却又畏首畏尾 </blockquote>

<a id="more"></a>
<p>Hexo Next 添加搜索功能过程，本博客采用「Local Search」！</p>
<h2 id="对主题版本的要求"><a href="#对主题版本的要求" class="headerlink" title="对主题版本的要求"></a>对主题版本的要求</h2><p>要使用搜索功能对你的主题版本可能有最低要求，我采用的是 Next 主题，最近更新的，为防止后面出现各种莫名其妙的问题，建议最好把主题版本更新一下。</p>
<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><h3 id="安装-hexo-generator-searchdb-，在站点的根目录下执行以下命令："><a href="#安装-hexo-generator-searchdb-，在站点的根目录下执行以下命令：" class="headerlink" title="安装 hexo-generator-searchdb ，在站点的根目录下执行以下命令："></a>安装 hexo-generator-searchdb ，在站点的根目录下执行以下命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h3 id="编辑-站点配置文件，新增以下内容到任意位置："><a href="#编辑-站点配置文件，新增以下内容到任意位置：" class="headerlink" title="编辑 站点配置文件，新增以下内容到任意位置："></a>编辑 站点配置文件，新增以下内容到任意位置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">      path: search.xml</span><br><span class="line">      field: post</span><br><span class="line">      format: html</span><br><span class="line">      limit: 10000</span><br></pre></td></tr></table></figure>
<h3 id="编辑-主题配置文件，启用本地搜索功能："><a href="#编辑-主题配置文件，启用本地搜索功能：" class="headerlink" title="编辑 主题配置文件，启用本地搜索功能："></a>编辑 主题配置文件，启用本地搜索功能：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">      enable: true</span><br></pre></td></tr></table></figure>
<h2 id="重新生成静态文本"><a href="#重新生成静态文本" class="headerlink" title="重新生成静态文本"></a>重新生成静态文本</h2><p>hexo clean -&gt; hexo generate -&gt; hexo server  -&gt; 查看效果 -&gt; 收工</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/" target="_blank" rel="noopener">Hexo 博客添加搜索功能</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>必知的写作排版指南</title>
    <url>/2018/07/26/Hexo-2018-07-26-%E5%BF%85%E7%9F%A5%E7%9A%84%E5%86%99%E4%BD%9C%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 必知的写作排版指南 </blockquote>

<a id="more"></a>
<h2 id="1、空格"><a href="#1、空格" class="headerlink" title="1、空格"></a>1、空格</h2><p>汉字和英文、数字、符号之间都必须加一个空格。</p>
<ul>
<li>中英文之间加空格<blockquote>
<p>正例：我感觉自己 very 帅。<br>反例：我感觉自己very帅。</p>
</blockquote>
</li>
<li>汉字与数字之间加空格<blockquote>
<p>正例：我永远都是 18 岁。<br>反例：我永远都是18岁。</p>
</blockquote>
</li>
<li>数字与单位之间加空格<blockquote>
<p>正例：我有一只身高 120 cm 的猫。<br>反例：我有一只身高 120cm 的猫。</p>
</blockquote>
</li>
<li>全是英文的句子中，标点符号与单词之间需要加空格。<blockquote>
<p>正例：Where there is a will, there is a way.<br>反例：Where there is a will,there is a way.</p>
</blockquote>
</li>
<li>全角标点与其他字符之间不加空格<blockquote>
<p>正例：有志者，事竟成。<br>反例：有志者， 事竟成。</p>
</blockquote>
</li>
<li>中文与链接之间增加空格<blockquote>
<p>正例：我觉得 <a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a> 这个网站很赞。<br>反例：我觉得<a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a>这个网站很赞。</p>
</blockquote>
</li>
<li>括号、引号前后加空格，中间内容无空格<blockquote>
<p>示例 1：5.04 ounces (143 grams)<br>示例 2：Did you say “I love that” ?</p>
</blockquote>
</li>
</ul>
<h2 id="2、标点"><a href="#2、标点" class="headerlink" title="2、标点"></a>2、标点</h2><p>什么是全角、半角？<br>全角、半角主要是针对标点符号来说的，全角占两个字节，半角占一个字节。中文标点符号是全角，英文标点符号是半角。即：中文标点符号的宽度是英文标点符号宽度的 2 倍。  </p>
<ul>
<li>中文 排版中所有的标点都应该使用 全角中文标点符号  <blockquote>
<p>正例：有志者，事竟成。<br>反例：有志者,事竟成.</p>
</blockquote>
</li>
<li>英文 排版中所有的标点都应该使用 半角英文标点符号<blockquote>
<p>正例：Where there is a will, there is a way.<br>反例：Where there is a will，there is a way。</p>
</blockquote>
</li>
<li>使用直角引号<blockquote>
<p>正例：这个是「直角引号」的效果。<br>反例：这个是“普通引号” 的效果。</p>
</blockquote>
</li>
<li>引号再使用引号使用直角双引号<blockquote>
<p>正例：在「直角引号里使用『引号』的情况」。<br>反例：在“普通引号里使用‘引号’的情况”。  </p>
</blockquote>
</li>
<li>不重复使用标点符号<blockquote>
<p>正例：德国队竟然输给了韩国队！<br>反例：德国队竟然输给了韩国队！！！  </p>
</blockquote>
</li>
</ul>
<p>注：<a href="https://www.zhihu.com/question/19716567" target="_blank" rel="noopener">各种输入法怎样快速打出「直角引号」符号</a></p>
<h2 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h2><ul>
<li>英文名字首字母尽量大写<blockquote>
<p>Facebook</p>
</blockquote>
</li>
<li>专有名词使用正确的大小写<blockquote>
<p>GitHub</p>
</blockquote>
</li>
<li>首行不要缩进，改用「空出一行」代替首行缩进<blockquote>
<p>空行代替缩进来区分自然段</p>
</blockquote>
</li>
</ul>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a><br><a href="https://zhuanlan.zhihu.com/p/20506092" target="_blank" rel="noopener">写给大家看的中文排版指南</a><br><a href="http://stormzhang.com/2017/03/16/chinese-copywriting/" target="_blank" rel="noopener">每个人都需要的中文排版指南</a><br><a href="https://www.zhihu.com/question/19716567" target="_blank" rel="noopener">各种输入法怎样快速打出「」符号</a>  </p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 代码块</title>
    <url>/2018/03/15/Hexo-2018-03-15-HexoNext%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Hexo Next 代码块 </blockquote>

<a id="more"></a>
<h2 id="1、编辑主题配置文件-config-yml"><a href="#1、编辑主题配置文件-config-yml" class="headerlink" title="1、编辑主题配置文件 _config.yml"></a>1、编辑主题配置文件 _config.yml</h2><p>「注意是主题配置文件」此处用来设置代码块的背景色。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight_theme: night eighties</span><br></pre></td></tr></table></figure></p>
<h2 id="2、编辑站点配置文件-config-yml"><a href="#2、编辑站点配置文件-config-yml" class="headerlink" title="2、编辑站点配置文件_config.yml"></a>2、编辑站点配置文件_config.yml</h2><p>「注意亲测会报错」：在网上 Google 的答案中要求将 auto_detect 设置为 true，但是我设置以后使用 hexo generate 生成静态代码的时候会报错 TypeError: Cannot set property ‘lastIndex’ of undefined 所以最后还是乖乖设置成了 false ，对实际效果也没有任何影响，对于该配置需谨慎使用。</p>
<hr>
<p>「注意是站点配置文件」auto_detect 主要用来支持代码自动检测。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="3、编辑-Markdown-文章"><a href="#3、编辑-Markdown-文章" class="headerlink" title="3、编辑 Markdown 文章"></a>3、编辑 Markdown 文章</h2><p><code>注意</code>：「```」之后需要指定你代码块中所使用的开发语言，也可以不指定，即让系统自动识别你代码块中的开发语言是哪个，系统可能会识别失败或错误，所以最好还是指定。<code>注意</code>：符号「```」,是 Esc 下面那个，不是单引号「’’’」。</p>
<p><img src="/upload_image/codeblock.png" alt="Markdown 代码块" title="Markdown 代码块"><br>效果图：<br><img src="/upload_image/codeblock1.png" alt="Markdown 效果图" title="Markdown 效果图"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(三)</title>
    <url>/2018/09/12/Linux-2018-09-12-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(三) —— Linux 网络 </blockquote>

<a id="more"></a>]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(二)</title>
    <url>/2018/09/06/Linux-2018-09-06-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%BA%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(二) —— Linux 系统安装 </blockquote>

<a id="more"></a>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>磁盘分区又叫系统分区，是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。从字面意思来讲，磁盘分区指的就是把大的硬盘按照我的需求划分成几个分区，不同类目录与文件可以存储进不同的分区。</p>
<h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><ol>
<li>主分区：最多只能有 4 个。  </li>
<li><p>扩展分区「是从主分区的 4 个分区之中拿出 1 个分区作为扩展分区」：</p>
<blockquote>
<ul>
<li>扩展分区最多只能有 1 个（注意：针对一块硬盘来讲，一个硬盘最多只能有一个扩展分区）。</li>
<li>主分区加扩展分区最多只能有 4 个。</li>
<li>扩展分区本身不能写入数据也不能格式化，唯一的作用就是用来包含逻辑分区。</li>
</ul>
</blockquote>
</li>
<li><p>逻辑分区「即扩展分区中的逻辑分区」：可以正确的写入数据和格式化。按照硬盘的限制，一块硬盘最多只能分 4 个分区，即 4 个主分区。这种限制不是 Linux 系统的限制而是硬盘本身的限制，只要硬盘结构不发生变化，这种限制会一直存在。</p>
</li>
</ol>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>硬盘正确分区以后还不能写入数据，硬盘还必须经过格式化以后才可以写入数据。</p>
<p>格式化 (高级格式化) 又称逻辑格式化，它是指根据用户选定的文件系统（如 fat16、fat32、NTFS、ext2、ext3、ext4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。</p>
<p>在 windows 中可以识别的文件系统有 fat16、fat32、NTFS，在 linux 中可以识别的文件系统有 ext2、ext3、ext4，centOS 默认使用的是 ext4。</p>
<p>硬盘的格式化最主要的目的就是为了在硬盘当中写入文件系统，写入文件系统最主要的工作就是按照文件系统的规则把硬盘分成等大小的数据块，然后建立 iNode 表，我们把表里的编号称为 i 节点号又名 iNode 号。</p>
<p>当在查找文件的时候，是通过 iNode 表找到 i 节点号来找到这个文件的条款，从而知道这个文件保存在哪几个数据块之中，从而找到这几个数据块拿出文件，拼凑成我们的文件。这个格子就叫做数据块，又名 block。</p>
<p>在 centos 当中，默认的文件系统是 ext4，它在进入格式化的时候，它需要把硬盘划分为一个又一个等大小的数据块，这个数据块默认的标准大小为 4kb。假如有一个数据是 10kb，需要占用 3 个格子，最后一个格子只放了 2kb 数据，剩余的 2kb 空闲空间是不能再被其它文件所占用的，这 3 个格子不一定在一块。windows 中有一个磁盘碎皮整理，它的原理就是将保存的同一个文件的格子尽量放到一起，这样更有利于数据的读取。</p>
<h2 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h2><p>如果是 windows，在进行了分区、格式化之后，给分区分配盘符然后就可以直接使用了。但是 Linux 不行，Linux 在进行了分区、格式化，格式化完成之后，要想给分区分配盘符之前，<strong>还必须给每一个分区起一个设备文件名，或者说给每一个分区起一个硬件设备文件名。</strong></p>
<p>在 Linux 中所有的硬件设备都是文件。</p>
<p><img src="/upload_image/Hardware_Name.png" alt="硬件设备文件名" title="硬件设备文件名"></p>
<p>「/」表示 Linux 中的最高一级目录，也就是根目录。在根目录下有一个 dev 的一级子目录，在 dev 目录中放入的所有的文件都是<strong>硬件文件</strong>。我们将<strong>硬件文件名</strong>，称为<strong>硬件的设备文件名</strong>。</p>
<p>为什么 Linux 需要「硬件设备文件名」而 windows 不需要？<br>在 windows 中，硬盘分区、格式化之后，然后可以直接分配盘符是因为我们可以在 windows 的图形界面中直接看到这个硬盘在哪（注意：一台机器可能有多个硬盘），所以可以直接分配盘符（windows 有完善的图形界面）。但是 Linux 最早出现的时候，是没有图形界面的，为了让系统知道我要给哪一个硬盘分配盘符，所以被迫需要给每一个硬盘或者硬件设备指定设备文件名。</p>
<p><strong>硬件设备文件名是固定的，系统自动检测的，我们能看懂就行。</strong> 关于硬盘，我们现在主要使用的是 SATA 硬盘接口，IDE、SCSI 硬盘接口基本被淘汰了。</p>
<h2 id="分区设备文件名"><a href="#分区设备文件名" class="headerlink" title="分区设备文件名"></a>分区设备文件名</h2><p>硬盘有了「硬件设备文件名」，还要给分区也要分配文件名，这就是「分区设备文件名」。「分区设备文件名」是在硬盘「硬件设备文件名」之后，直接加分区号就可以了。即硬盘有设备文件名，分区也应该有设备文件名，区别是一个是硬件设备文件名，一个是分区设备文件名。</p>
<p>分区设备文件名：分区文件名是在硬盘文件名之后直接加分区号，1 表示这个硬盘当中的第一个分区，依次类推。<strong>注意分区号有主分区号和逻辑分区号。</strong></p>
<p>逻辑分区是从 5 开始的，1234 只能给主分区或者扩展分区使用，即使一个硬盘中没有分够 4 个主分区，逻辑分区也不能占用 1234 这 4 个分区号，即不管如何分区 5 都表示逻辑分区的第一个分区。</p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>windows 中分配盘符的操作在 Linux 中叫做挂载，我们把给分区分配盘符的过程称为挂载，我们把盘符叫做挂载点。在 Linux 中是使用空的目录名称作为盘符，而不是使用 CDEF 作为盘符，理论上任何一个目录都可以作为盘符，实际上有些目录是不可以的。</p>
<p>对于 Linux 来讲有两个必须分区：根分区、swap 分区（交换分区，大小一般为内存的 2 倍，一般不超过 2GB）。这两个是必须分区，如果不分区，则 Linux 不能安装，只要有这两个分区，Linux 就可以正常使用。还有一个推荐分区，/boot（启动分区，大小一般为 200M)。</p>
<p>根分区用于存放剩余数据，swap 分区可以理解为虚拟内存，即当我真正的内存不够用的时候可以拿交换分区的硬盘空间来当内存来用，理论上讲 swap分 区应该是内存的两倍，但是最大不超过 2GB，因为虚拟内存到底不是真正的内存，如果给它给的再大，它也不能取代内存，当它达到 2GB 的时候，如果再给大，只会占用我们更多的硬盘空间，但是对我们的系统不会产生更多的影响，所以最大不超过 2GB。</p>
<p>Boot 分区是专门用来保存启动时候的数据，任何操作系统启动的时候都需要一些硬盘空间，如果不给 boot 分区，万一根分区写满了，系统可能就启动不了了，为了解决这个问题，一般都会给 boot 单独分区。Boot 分区 200MB 足够，不用太大，写完之后不再往 boot 分区写入任何数据，它永远都会有一定的空余空间，就算把根分区写满了，也不会影响 Linux 启动。</p>
<h2 id="Linux-文件系统结构"><a href="#Linux-文件系统结构" class="headerlink" title="Linux 文件系统结构"></a>Linux 文件系统结构</h2><p><img src="/upload_image/File_System_Structure.png" alt="Linux 文件系统结构" title="Linux 文件系统结构"></p>
<p>从 Linux 系统上看，boot、home 都是根分区的子目录。但是从硬盘上来看，它们每一个目录都可以有自己独立的硬盘空间，即每一个目录都可以有自己独立的分区，而每个分区又对应某块硬盘空间，所以每个目录都可以有自己独立的硬盘空间。</p>
<p>挂载点就是分区的盘符，swap 分区即交换分区没有盘符，swap 分区不是给用户用的，是由 Linux 操作系统或者内核直接调用的，所以它根本不需要盘符，有了盘符反而不正确了。swap 对系统性能的影响极小，所以分的空间不用太大。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>分区：把大硬盘分为小的逻辑分区；<br>格式化：格式化的目的是为了写入文件系统，当然在写入文件系统的时候会附带的把硬盘当中的数据清空；<br>分区设备文件名：给每个分区定义设备文件名；<br>挂载：给每个分区分配挂载点，这个挂载点必须是目录，而且必须是空的目录才可以进行挂载点分配。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(四)</title>
    <url>/2018/09/17/Linux-2018-09-17-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%9B%9B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(四) —— Linux 常用命令 </blockquote>

<a id="more"></a>
<h2 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h2><p>1、命令格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    命令 [-选项] [参数]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">    1. 个别命令使用不遵循此格式</span><br><span class="line">    2. 当有多个选项时，可以写在一起</span><br><span class="line">    3. 简化选项与完整选项，eg：-a 等于 --all</span><br></pre></td></tr></table></figure></p>
<p>关于选项：在大多数的命令中，选项前面会有一个小横杆，用来标记这是一个选项；选项的作用：使用命令的时候用来做不同的操作，使命令结果呈现不同的形式或者信息内容，就可以加上不同的选项来实现，即选项是用来调整命令功能的。我们使用的选项都是简化选项，完整选项需要两个「-」 来调用，选项的顺序一般都是可以调整的。[] 里的内容是选择性加入的。加了选项是调整功能，加了参数是指定操作对象。</p>
<p>2、目录处理命令 ls<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 list；命令所在路径：/bin/ls；作用：显示目录文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ls [选项] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a  a 表示 all</span><br><span class="line">    -l  l 表示 long</span><br><span class="line">    -d  d 表示 directory，显示当前目录本身，而不显示目录下的数据</span><br><span class="line">    -h  h 表示 human，人性化显示文件大小</span><br><span class="line">    -i  i 表示 iNode，显示 i 结点号</span><br></pre></td></tr></table></figure></p>
<p>在 Linux 中，以「.」开头的是隐藏文件。隐藏文件的初衷是为了告诉用户这是一个系统文件，没有特殊情况一般不要修改它。在 Linux 中要想把一个文件隐藏，则需要给它改名，改成以点开头的文件名即可隐藏。</p>
<p>3、ls -l 显示结果分析<br><img src="/upload_image/ls_Analyse_Result.png" alt="ls -l" title="ls -l"></p>
<ol>
<li>x 表示执行权限，是 execute 的缩写；可执行文件 .exe 的缩写也来源于这个单词。</li>
<li>引用计数，代表这个文件曾经被引用或者调用过几次。这个引用计数对文件和目录来讲只在硬链接中才有作用。</li>
<li>文件大小默认单位是字节。可以使用 -h 选项来调整。</li>
<li>上图中的时间表示该文件最后被修改的时间；如果没有被修改过，则就是它的创建时间。需要注意的是 Linux 中没有创建时间这个概念，它只有文件的最后一次访问时间，文件的状态修改时间，文件的数据修改时间这三个时间。</li>
<li>i 节点，在 Linux 系统中每个文件或者目录都有它自己的一个唯一标识编号，系统靠这个 i 节点号搜索或者查找文件或者目录。</li>
</ol>
<p>4、目录处理命令 mkdir<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 make directories；命令所在路径：/bin/mkdir；作用：创建新目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mkdir [选项] 目录名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -p  p 表示 parents，如果新创建的目录的父目录不存在，则自动递归创建父目录</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可同时创建多个目录，多个目录之间以空格进行分割</span><br><span class="line">    mkdir /tmp/test1 /tmp/test2 /tmp/test3</span><br></pre></td></tr></table></figure></p>
<p>目录在 windows 中又称为文件夹。不要轻易在根目录下创建新的目录或者文件。可以在 /tmp 目录下进行练习，该目录是用来存放临时文件的。</p>
<p>5、目录处理命令 cd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change directory；命令所在路径：shell 内置命令；作用：切换目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cd [目录]</span><br></pre></td></tr></table></figure></p>
<p>「.」 表示当前目录，「..」表示当期目录的上一级目录。</p>
<p>注意：在 Dos 窗口下 cd.. 中间是可以不加空格的，但是在 Linux 中，中间必须有空格。</p>
<p>6、目录处理命令 pwd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 print working directory；命令所在路径：/bin/pwd；作用：显示当前所在目录的绝对路径</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></p>
<p>7、目录处理命令 rmdir<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 remove empty directories；命令所在路径：/bin/rmdir；作用：删除空目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rmdir [空目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可同时删除多个空目录，多个空目录之间以空格进行分割</span><br><span class="line">    rmdir /tmp/test1 /tmp/test2 /tmp/test3</span><br></pre></td></tr></table></figure></p>
<p>注意：rmdir 只能删除空的目录！！！要想使用 rmdir 删除目录，必须先把该目录下的所有子目录和文件都删除掉，才可以使用。实际操作中此命令用的并不是很多。</p>
<p>8、目录处理命令 cp<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 copy；命令所在路径：/bin/cp；作用：复制文件或目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cp [选项] [原文件或目录] [目标目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  复制目录，copy directories recursively</span><br><span class="line">    -p  保留文件属性，same as --preserve=mode,ownership,timestamps</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 将 /tmp 下 test1、test2、test3 目录一次性复制到 /root 下，并保持目录属性</span><br><span class="line">    cp -rp /tmp/test1 /tmp/test2 /tmp/test3 /root</span><br></pre></td></tr></table></figure></p>
<p>在 cp 复制文件的时候是不需要加选项的；但是要复制目录的话要增加选项 -r；cp 可以同时复制多个文件或者目录。</p>
<p>当把一个文件或目录复制到另一个地方的时候，相当于在另一个地方创建了一个新的文件或目录，所以复制出来的文件或目录的最后更改时间就是当前时间。如果希望复制出来的文件或目录的最后更改时间跟源文件一样，则使用 -p 选项。</p>
<p>在 Linux 中，复制文件或者目录的同时，可以更改目录或者文件的名字。</p>
<p>9、目录处理命令 mv<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 move；命令所在路径：/bin/mv；作用：剪切文件、改名</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mv [原文件或目录] [目标目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # /tmp 下 test1、test2、test3 目录一次性剪切到 /root 目录</span><br><span class="line">    # 当一次剪切多个目录或文件的时候就不能改名了，改名操作只支持一次一个，不支持一次多个文件或目录进行改名</span><br><span class="line">    mv /tmp/test1 /tmp/test2 /tmp/test3 /root</span><br><span class="line">改名：</span><br><span class="line">    mv 要改名的文件名 新的文件名</span><br></pre></td></tr></table></figure></p>
<p>在 Linux 中剪切和改名是同一个命令。在执行复制剪切等命令的时候，如果你的位置是在当前目录的话，可以省略绝对路径，但是在不清楚当前目录的情况下要写绝对路径。mv 命令是不需要加 -r 选项的，直接使用 mv 可以同时剪切一个或多个目录或者文件的，而且在剪切的同时可以改名。</p>
<p>10、目录处理命令 rm<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 remove；命令所在路径：/bin/rm；作用：删除文件或目录</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rm [选项] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  删除目录，recursive</span><br><span class="line">    -f  强制删除，force</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 同时删除目录 test1 test2 文件 h1.txt h2.txt</span><br><span class="line">    rm -rf test1 test2 h1.txt h2.txt</span><br></pre></td></tr></table></figure></p>
<p>注意：Linux 中是没有回收站这一说的，文件一旦删除，就没有了。</p>
<p>在删除文件的时候每次都会询问你是否删除，如果你不想有这个提示的话，则可以加 -f 选项。</p>
<p>小结：mkdir 创建一个新的目录，选项 -p 递归创建目录；cd 切换目录；pwd 查看当前的工作目录；rmdir 删除一个空目录；cp 复制文件 -r 复制目录 -p 复制的时候保持文件的属性；mv 剪切或者给一个文件改名；rm 删除文件 -r 删除目录 -f 删除目录或者文件的同时不希望询问确认。</p>
<h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><p>1、文件处理命令 touch<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/touch；作用：创建空文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    touch [文件名]</span><br></pre></td></tr></table></figure></p>
<p>注意：在 Linux 的命令里面，如果这个命令的参数没有详细的指定它的绝对路径，就表示要在当前目录下执行这个操作。要想在其他目录下执行这个操作，一定要指明它的绝对路径。</p>
<p>在 Linux 的文件命名里，除了「/」不能使用外，其它特殊符号都是合法的文件名，其后缀名是可以随便起的，这跟 windows 不一样。注意空格这个特殊符号，在 Linux 中并不建议将空格作为文件名组成部分，由于 Linux 系统把空格作为分隔符，要想使用空格作为文件名则必须用引号扩起来，这样虽然可以用空格作为文件名，但是对以后该文件的查找、修改、复制等操作造成麻烦，所以不建议这样使用。</p>
<p>2、文件处理命令 cat<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/cat；作用：一次性显示整个文件内容</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cat [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n  显示行号，number</span><br></pre></td></tr></table></figure></p>
<p>cat 命令适合看简短的文件。cat 不适合浏览比较长的文件。cat 命令会一次性列出文件所有内容</p>
<p>3、文件处理命令 tac<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/tac；作用：一次性显示整个文件内容（反向列示）</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    tac [选项] [文件名]</span><br></pre></td></tr></table></figure></p>
<p>4、文件处理命令 more<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/more；作用：分页显示文件内容</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    more [文件名]</span><br><span class="line"></span><br><span class="line">快捷键：</span><br><span class="line">    空格或 f   翻页</span><br><span class="line">    Enter     换行</span><br><span class="line">    q 或 Q    退出</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    more /etc/services</span><br></pre></td></tr></table></figure></p>
<p>more 命令是一个常用的分页显示文件内容的命令。该命令不可以往上翻。</p>
<p>5、文件处理命令 less<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/less；作用：分页显示文件内容（可向上翻页）</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    less [文件名]</span><br></pre></td></tr></table></figure></p>
<p>使用 less 命令，不仅可以像 more 命令一样进行浏览，还可以往上翻，使用 PgUp 表示一页一页往上翻，使用向上的剪头表示一行一行往上翻。还可以进行搜索：直接在 less 的浏览状态里面按一个「/」+ 你要搜索的关键词，就会把行里所有包含这个关键词的进行反白显示，同时如果在你当前查看的页里没有你要得到的搜索的关键词所在行的信息，可以按 n 表示 next 接着往下找。</p>
<p>6、文件处理命令 head<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/head；作用：显示文件前面几行</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    head [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n   指定行数</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    head -n 20 /etc/services</span><br></pre></td></tr></table></figure></p>
<p>如果只想看文件的前几行，则可以使用此命令。如果不用 -n 指定要显示的行数，则默认显示的是前 10 行。</p>
<p>7、文件处理命令 tail<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">      命令所在路径：/usr/bin/tail；作用：显示文件后面几行</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    tail [选项] [文件名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n   指定行数</span><br><span class="line">    -f   动态显示文件末尾内容</span><br></pre></td></tr></table></figure></p>
<p>显示文件最后面几行内容，默认是 10 行。-f 动态显示文件末尾的内容。使用该命令以后它会显示文件最末尾的位置，但是它并没有回到命令行，如果这时你这个文件的内容进行了变化，在这个命令操作状态下它也会实时变化的。一般来说用的也不会太多，一般用来监控一些日志。</p>
<p>小结：touch 创建一个文件；cat 查看文件的内容（浏览一些短文件），-n 用来显示行号；tac 反向显示文件内容（反向显示并不支持 -n 这个选项）；more 分页显示文件内容（主要指一些长的文件，不可以向上翻）；less 分页显示文件内容（可以向上/下翻，使用 「/ + 要搜索的关键词」在浏览的过程中遍历整个的文件进行搜索，可以用 n 键查找下一个匹配的位置）；head 查看一个文件的前几行，-n 指定要查看前几行，默认为 10 行；tail 查看一个文件的最后几行，-n 指定要查看后几行，-f 动态显示文件最后的内容，默认为 10 行。</p>
<p>8、文件处理命令 ln<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 link；命令所在路径：/bin/ln；作用：生成链接文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ln [选项] [原文件] [目标文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -s  创建软链接，s 代表 symbolic，make symbolic links instead of hard links，即创建符号链接而不是硬链接</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 创建 /etc/issue 的软链接 /root/issue.soft</span><br><span class="line">    ln -s /etc/issue /root/issue.soft</span><br><span class="line"></span><br><span class="line">    # 创建文件 /etc/issue 的硬链接 /root/issue.hard</span><br><span class="line">    ln /etc/issue /root/issue.hard</span><br></pre></td></tr></table></figure></p>
<p>9、软链接特征<br>类似 windows 快捷方式。作用：方便快捷的让你找到你最常使用的一些东西，便于规划，方便管理。  </p>
<ol>
<li>在 Linux 系统里面，它前面的 10 个文件权限的标识全部都是 lrwxrwxrwx，意味着所有的人都有全部的操作权限，每个用户在对这个软链接进行操作的时候，到底他能具有什么样的权限，是由这个文件对应的源文件的权限最终决定的。</li>
<li>软链接文件大小很小，因为它只是一个符号链接。</li>
<li>有一个箭头指向到它所对应的源文件（硬链接是没有箭头指向的）。</li>
</ol>
<p>10、硬链接特征</p>
<ol>
<li>拷贝「cp -p」+ 同步更新。cp -p 是拷贝文件并且保留文件的属性不变；同步更新即不管是修改原文件还是硬链接文件，两者的内容始终会自动保持一致，即同步更新。</li>
<li>通过 i 结点识别，硬链接的 i 节点与源文件的 i 节点一样。</li>
<li>不能跨分区。</li>
<li>不能针对目录使用。</li>
</ol>
<p>软链接与硬链接的区别：硬链接就类似于拷贝，但是可以同步更新，源文件即使不在了，硬链接照样可以访问，因为是类似拷贝的。如果软链接源文件不在了，则它会报错找不到源文件。一个文件一定有一个 i 节点，但是一个 i 节点不一定只对应一个文件，硬链接就是一个特殊案例，一个 i 节点映射到了多个文件。注意硬链接在 Linux 中用的非常少！</p>
<h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><p>1、权限管理命令 chmod<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change the permissions mode of a file；命令所在路径：/bin/chmod；作用：改变文件或目录权限</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chmod [选项] [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录]</span><br><span class="line">    chmod [选项] [mode] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -R   递归修改</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 可以同时做多个授权，中间用「,」逗号分隔</span><br><span class="line">    chmod u+rwx,g+rw,o=r test.txt</span><br></pre></td></tr></table></figure></p>
<p><strong>一个文件或目录的权限只有两个人可以更改：一个是该文件或目录的所有者，另一个就是管理员 root。</strong></p>
<p>权限数字表示：r=4，w=2，x=1。</p>
<p>2、文件目录权限总结<br><img src="/upload_image/File_Directories_Permission.png" alt="文件目录权限总结" title="文件目录权限总结"></p>
<p>注意：读写执行权限对目录的含义！！！要想删除一个文件，你必须有这个文件所在的目录的写权限。对于目录，r（查看目录内容）、x（进入目录）权限一般都是一起出现的。</p>
<p>3、权限管理命令 chown<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change file ownership；命令所在路径：/bin/chown；作用：改变文件或目录的所有者</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chown [用户] [文件或目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 改变文件 test.txt 的所有者为 root</span><br><span class="line">    chown root test.txt</span><br></pre></td></tr></table></figure></p>
<p><strong>在 Linux 系统中，改变一个文件或者目录的所有者，只有管理员 root 可以做这样的操作。</strong><br>可以使用 useradd 命令来添加一个用户，使用 passwd 为该用户设置一个密码。</p>
<p>4、权限管理命令 chgrp<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 change file group ownership；命令所在路径：/bin/chgrp；作用：改变文件或目录的所属组</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    chgrp [用户组] [文件或目录]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 改变文件 test.txt 的所属组为 family</span><br><span class="line">    chgrp family test.txt</span><br></pre></td></tr></table></figure></p>
<p><strong>在 Linux 系统中，改变一个文件或者目录的所属组，只有管理员 root 可以做这样的操作。</strong></p>
<p>添加用户组命令：groupadd。</p>
<p>所有者：谁创建的文件谁就是文件的所有者；所属组：一个用户可以属于多个组，但是他总有个缺省组（缺省，即系统默认状态，意思与「默认」相同），每个用户创建文件的时候，它（该文件）的所属组就是该用户的缺省组，每个用户只能有一个缺省组。所以在创建一个文件的时候，它的所有者就是他自己即文件的创建者，它的所属组就是这个文件创建者的缺省组（了解即可）。</p>
<p>5、权限管理命令 umask<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 the user file-creation mask（mask 掩码的意思）；命令所在路径：Shell 内置命令；作用：显示、设置文件的缺省权限</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    umask [-S]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S   以 rwx 形式显示新建文件缺省权限（注意 S 大写）</span><br></pre></td></tr></table></figure></p>
<p>在 Linux 权限管理有一个最基本的定义：缺省创建的文件是不能具有可执行权限的。所以在 Linux 系统中任何新建的文件都会把可执行权限去掉。这样做的目的是为了安全。<strong>注意只针对文件，对目录没有这样的限制。</strong></p>
<p>直接执行 umask 命令会得到一个 4 位的数字：0022。第一个 0 表示特殊权限，022 代表正常的权限，其实 022 是权限掩码，真正的缺省权限是 777-022=755 即默认的权限 rwxr-xr-x。而 Linux 系统中任何新建的文件都会把可执行权限去掉，所以你新建的任何一个文件的权限就是：rw-r–r–。</p>
<p>要想更改缺省权限，则需要先写出你要更改权限的数字，eg：rwxr-xr– 即 754，然后用 777-754=023，最后 umask 023 将缺省创建的权限改为 rwxr-xr–。虽然缺省创建的权限是可以更改的，但是并不建议这样去做。</p>
<h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><p>注意：尽量减少搜索这个操作，因为搜索它会占用大量的系统资源。在服务器高峰期里面，是不建议用搜索这个命令的。原则：不要在服务器使用高峰期的时候使用 find 命令来进行查找；在查找的过程中搜索的范围越小越好；搜索的条件越精准越好。</p>
<p>1、文件搜索命令 find<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/find；作用：文件搜索</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    find [搜索范围] [匹配条件]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 在目录 /etc 中查找文件 init</span><br><span class="line">    find /etc -name init</span><br><span class="line"></span><br><span class="line">    # -iname 不区分大小写</span><br><span class="line">    find /etc -iname init</span><br><span class="line"></span><br><span class="line">    # （注意数据块概念）在根目录下查找大于 100MB 的文件；+n 大于</span><br><span class="line">    # -n 小于，n 等于</span><br><span class="line">    find / -size +204800</span><br><span class="line"></span><br><span class="line">    # 在 /etc 下查找大于 80MB 且小于 100MB 的文件</span><br><span class="line">    # -a 两个条件同时满足，and</span><br><span class="line">    # -o 两个条件满足任意一个即可，or</span><br><span class="line">    find /etc -size +163840 -a -size -204800</span><br><span class="line"></span><br><span class="line">    # 在根目录下查找所有者为 root 的文件</span><br><span class="line">    find / -user root</span><br><span class="line"></span><br><span class="line">    # 在根目录下查找所属组为 root 的文件</span><br><span class="line">    find / -group root</span><br><span class="line"></span><br><span class="line">    # 在 /etc 下查找 5 分钟内被修改过属性的文件和目录</span><br><span class="line">    # -amin 访问时间 access；-cmin 文件属性 change；-mmin 文件内容 modify</span><br><span class="line">    # +n 大于多长时间，-n 多长时间以内，n 等于</span><br><span class="line">    find /etc -cmin -5</span><br><span class="line"></span><br><span class="line">    # -type 根据文件类型查找</span><br><span class="line">    # f 文件；d 目录；l 软链接文件</span><br><span class="line">    find /etc -type f</span><br><span class="line"></span><br><span class="line">    # -inum 根据 i 节点查找</span><br><span class="line">    find /etc -inum 12345</span><br><span class="line"></span><br><span class="line">    # 在当前目录中查找 iNode 为 666 的文件或目录并删除</span><br><span class="line">    find . -inum 666 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<p>注意利用 -name 搜索的话，它只会搜索文件名是 init的文件，而不像 windows 里面那样只要文件名包含 init 就都会被搜素到，可以理解为这是一种非常精准的搜索。要想像 windows 一样，可以做一个模糊的搜索即只要是包含 init 这 4 个连续的字母，就可以被搜素到，则：find /etc -name <em>init</em>，「<em>」号表示通配符，意思是只要文件名里有 init 就会被搜索到。init</em> 表示以 init 开头的；init??? 表示 init 以后有 3 个字符，问号匹配单个字符。Linux 中常用的两种通配符：* 号可以匹配任意字符，? 号可以匹配某个单个字符。</p>
<p>注意：在 Linux 系统中，一个数据块默认是 512 字节即 0.5kb；数据块是 Linux 系统中存储文件的最小单位。而 -size 的大小是用数据块换算的，所以 100MB 的文件所对应的就是 204800 个数据块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 /etc 下查找 inittab 文件并显示其详细信息</span><br><span class="line"># 「-exec/-ok 命令 &#123;&#125; \;」对搜索结果执行操作</span><br><span class="line">find /etc -name inittab -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>前面还是正常写 find 要执行的查找的命令，找到这个结果以后，可以使用 -exec/-ok 直接连接一个命令即对 find 查找的结果做一些操作，再加上固定格式「{} \;」。{} 表示的是 find 查找的结果，表示对 find 查找的结果做一个替换，因为 find 查找的结果可能有多个，所有使用 {} 表示。「\」表示转义符，「;」表示结束。<br>注意：「;」分号，不要丢掉，而且「\」和「;」之间没有空格分隔！！！ -exec 和 -ok 的区别：-exec 直接执行，-ok 会一个个询问你是否执行（即会有询问确认环节）。</p>
<p>find -inum 使用场景，确定一个文件是否有硬链接。查看一个文件是否有硬链接：首先查看该文件的 i 节点，然后在整个它所在的分区里面（硬链接不能跨分区）做一个搜索，找 i 节点是你这个指定数字的文件，它就会把它的硬链接文件找到。</p>
<p>小结：find 命令 -name 根据文件名来查找；-iname 查找的时候不区分大小写；使用的通配符：* 匹配任意字符，? 匹配单个字符；-size 根据文件大小来查找，+ 大于多少，- 小于多少；-user 根据所有者来查找；-group 根据所属组来查找；-amin 根据访问时间来查找；-cmin 根据文件属性的更改查找；-mmin 根据文件内容更改来查找；-type 根据文件类型来查找，f 文件，d 目录，l 软链接；-inum 根据 i 节点来查找；-a 连接两个条件，表示两个条件都满足；-o 表示两个条件只有满足一个就可以；-exec 或者-ok 对搜索的结果直接进行操作，二者的区别只有一个就是 -ok 会询问确认，固定格式「{} \;」。</p>
<h2 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h2><p>1、文件搜索命令 locate<br><a href="https://blog.csdn.net/feifeilyj/article/details/52238209" target="_blank" rel="noopener">centos locate 命令安装</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/locate；作用：在文件资料库中查找文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    locate 文件名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    locate inittab</span><br></pre></td></tr></table></figure></p>
<p>该命令在查找的时候不像 find 来遍历你所搜索的范围，而是建立了一个文件资料库（该资料库会定期更新），它在找的时候不是在硬盘上找，而是在资料库里面找你有搜索的文件，所以速度很快。虽然使用 locate 命令查找的速度非常快，但是新建的文件使用该命令是找不到的，因为 locate 的文件资料库并没有更新。手动更新文件资料库命令：updatedb。</p>
<p>注意：/tmp 临时文件目录，并不在文件资料库所收录的文件范围之中，如果你要找的文件在 /tmp 目录下面，使用该命令是找不到的。如果希望 locate 命令在查找的时候不区分大小写，可以使用选项「-i」。</p>
<p>2、文件搜索命令 which<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/which；作用：搜索命令所在目录及别名信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    which 命令</span><br></pre></td></tr></table></figure></p>
<p>which 提供了一种快速查找一个命令所在的绝对路径的方法。除了可以找到命令所在的目录还可以找到该命令的别名，查看该命令本身是否有别名相关的信息。    实际上在 Linux 系统中，本身是没有询问确认的机制，之所以现在在 Linux 系统中有询问确认的选项，是因为它加了一个 -i 的选项，eg：在使用 rm 命令的时候，系统在找的时候找到的是一个别名而不是一个命令，它的别名等于「rm -i」，「-i」这个选项实际上就是一个询问确认的选项，所以这是别名的作用。</p>
<p>3、文件搜索命令 whereis<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/whereis；作用：搜索命令所在目录及帮助文档路径</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    whereis [命令名称]</span><br></pre></td></tr></table></figure></p>
<p>whereis 除了可以找到命令所在的绝对路径，还可以找到这个命令它相关的帮助文档所在的位置，这个帮助文档就是 man 命令所展示的文件。</p>
<p>4、文件搜索命令 grep<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/grep；作用：在文件中搜寻字符匹配的行并输出，属于精确匹配</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    grep [选项] [指定字串] [文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i   不分区大小写</span><br><span class="line">    -v   显示排除指定字串的行</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 列出在 /etc/issue 文件中包含 hello 字串的行，且忽略大小写</span><br><span class="line">    grep -i hello /etc/issue</span><br><span class="line"></span><br><span class="line">    # 列出 /etc/issue 文件中所有不包含 Hello 字串的行</span><br><span class="line">    grep -v Hello /etc/issue</span><br></pre></td></tr></table></figure></p>
<p>「-v  #」表示把 # 号所在的行都去掉，不管 # 号在什么位置，只要该行有 # 号，就都去掉。这样做是不太合理的，可能 # 位于中间，前面是有有效代码的。所以要想把行首以 # 开始的注释行去掉，要在 # 前面加一个表示行首的「^」即「^#」。使用 grep 命令查找文件中除注释以外的内容：<code>grep -v ^# 文件名</code>，需要注意的是针对 Shell 脚本的首行 # 号，应该做特殊处理。</p>
<p>小结：locate 快速定位到一个文件所在的路径（文件资料库），updatedb 更新文件资料库（有个别目录下的文件并不被收录到文件资料库中 /tmp），-i 不区分大小写；which 或者 whereis 查找命令所在的绝对路径；grep 在文件内容中查找，-i 不区分大小写，-v 排除查找。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(一)</title>
    <url>/2018/09/06/Linux-2018-09-06-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(一) —— Linux 系统简介 </blockquote>

<a id="more"></a>
<h2 id="Unix-发展史"><a href="#Unix-发展史" class="headerlink" title="Unix 发展史"></a>Unix 发展史</h2><p>Unix 与 Linux 的关系就像是父子关系，Unix 是父亲，Linux 是儿子。肯.汤普森在 1969 年开发出了 Unix 系统。1971 年，肯.汤普森的同事丹尼斯.里奇发明了 C 语言，随后 Unix 系统绝大部分源代码用 C 语言重写，为提高 Unix 系统的可移植性打下基础。</p>
<h2 id="Unix-主要发行版本"><a href="#Unix-主要发行版本" class="headerlink" title="Unix 主要发行版本"></a>Unix 主要发行版本</h2><p><img src="/upload_image/Unix_Major_Version.png" alt="Unix 主要发行版本" title="Unix 主要发行版本"></p>
<h2 id="Linux-发展史"><a href="#Linux-发展史" class="headerlink" title="Linux 发展史"></a>Linux 发展史</h2><p>Linux 系统诞生于 1991 年，由芬兰大学生李纳斯(Linux Torvalds) 和后来陆续加入的爱好者共同完成。Unix 和 Linux 的内核都是用 c 语言写的。Linux 是开源软件。</p>
<h2 id="Linux-发行版和-Linux-内核的区别？"><a href="#Linux-发行版和-Linux-内核的区别？" class="headerlink" title="Linux 发行版和 Linux 内核的区别？"></a>Linux 发行版和 Linux 内核的区别？</h2><p>内核版是 Linux 官方发布的，仅仅是单纯的内核。在拿到内核以后，每个产商可以加入自己的桌面、应用程序等再进行开发，称为发行版。Linux 内核官网：<a href="http://www.kernel.org。" target="_blank" rel="noopener">www.kernel.org。</a></p>
<h2 id="Linux-主要发行版本"><a href="#Linux-主要发行版本" class="headerlink" title="Linux 主要发行版本"></a>Linux 主要发行版本</h2><p>Linux 主要分为两个系列：redhat 系列和 debian 系列。其本质是一样的，因为两者采用系统的内核。最主要的区别就是软件安装的方式不一样。Redhat 系列主要分为 HEL 和 federo 两个系列，其中 federo 是个人版，HEL 是企业版。对于 Linux 的企业版和个人版跟 windows 是不一样的，对于 windows 而言 windows7 是个人版，windows2008 是企业版，它们的区别是 windows7 可以看成是 windows2008 的一个阉割版，windows2008 才是完整的。但是 Linux 不同，个人版和企业版的区别在于，个人版是开发版，可能有的功能没有进行过测试，更像是一个实验体，而企业版是稳定版。</p>
<p><img src="/upload_image/Linux_Major_Version.png" alt="Linux 主要发行版本" title="Linux 主要发行版本"></p>
<h2 id="开源软件的特点"><a href="#开源软件的特点" class="headerlink" title="开源软件的特点"></a>开源软件的特点</h2><ol>
<li>使用的自由：绝大多数开源软件免费（注意的是开源和免费并不是等同的，开源软件也可以出售，但是卖给你的是源代码，并不是编译之后的代码给你）。</li>
<li>研究自由：可以获得软件源代码（开放源代码带来的好处——安全，足够多的眼睛可以发现更多的问题，可以容易的看到大神级人物的代码风格和注释）。</li>
<li>散步及改良自由：可以自由传播、改良甚至销售。</li>
</ol>
<h2 id="Linux-的应用领域"><a href="#Linux-的应用领域" class="headerlink" title="Linux 的应用领域"></a>Linux 的应用领域</h2><ol>
<li>基于 Linux 的企业服务器：企业服务器。</li>
<li>嵌入式应用：Android 平台就是一个典型的 Linux 嵌入式应用、智能家电如机顶盒、游戏机、数码相机等。</li>
<li>电影娱乐业：用于电影、图片的后期处理。</li>
</ol>
<h2 id="Linux-为什么选择命令行？"><a href="#Linux-为什么选择命令行？" class="headerlink" title="Linux 为什么选择命令行？"></a>Linux 为什么选择命令行？</h2><p>Linux 选用命令行界面主要是考虑到系统的稳定性和安全性，如果装了图形界面，对系统资源的占用是比较庞大的，所以比较不好用。而 windows 考虑的是易用性，windows 系统主要考虑的是系统的易用性。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>1、<a href="http://www.netcraft.com" target="_blank" rel="noopener">www.netcraft.com</a> 是一个典型的扫描和踩点网站。只要输入你要查询的网站，就可以获取网站后台服务器所采用的操作系统。该网站是一个全球著名的信息统计网站。从攻击的角度叫踩点，从防御的角度叫扫描。</p>
<p>2、<a href="http://www.top500.org" target="_blank" rel="noopener">www.top500.org</a> 会统计全球范围内运算能力排在前 500 的服务器或者叫群组。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(六)</title>
    <url>/2018/09/25/Linux-2018-09-25-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%85%AD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(六) —— Vim 编辑器 </blockquote>

<a id="more"></a>
<h2 id="Vim-简介"><a href="#Vim-简介" class="headerlink" title="Vim 简介"></a>Vim 简介</h2><hr>
<p>Vim 在早期的 Linux 版本中又叫 Vi（visual interface），Vim 是 Vi 的升级版。Vim 是一个功能强大的全屏幕文本编辑器，是 Linux/Unix 上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。<strong>Vim 没有菜单，只有命令。</strong></p>
<p>Vim 有三种工作模式。可以使用 vim 加上任何一个已经存在或者你想创建的文件名就可以进入 Vim 默认的命令模式。vi 和 vim 都是命令，两个的效果一模一样，一个是早期的，一个是 Vi 的增强版（全名 Vi improved 简称 Vim） 。Vim 命令默认进入的是命令模式，在该模式下，你敲的任何一个字符系统都会当成命令来处理。要想进入文本的插入模式，你需要输入插入命令，比较常用的有 i、a、o 就会进入到插入模式，要想退出插入模式，则可以使用 Esc 键，表示退出插入模式，但是此时进入到的是命令模式，此时你输入的任何内容都会被当成命令。在命令模式里面按「：」冒号就会进入到编辑模式，此时输入的就是编辑模式的命令了，即你输入的内容都会被当成是编辑模式的命令。比如设置行号命令：set number（简写：set nu）。编辑模式的命令执行完成以后它会自动的回到命令模式，所以冒号后面输入的内容才是编辑模式的命令。保存退出命令模式：「:wq」。</p>
<p><img src="/upload_image/Vim_Model.png" alt="Vim 工作模式" title="Vim 工作模式"></p>
<h2 id="命令模式和编辑模式常用命令"><a href="#命令模式和编辑模式常用命令" class="headerlink" title="命令模式和编辑模式常用命令"></a>命令模式和编辑模式常用命令</h2><hr>
<p><img src="/upload_image/Insert_Command.png" alt="插入命令" title="插入命令"><br>注意：在使用小 a 的时候光标会自动往后跳一格，例如：we 光标现在在 w 上，按 a 以后光标自动跳到 e 上，然后在 e 的前面插入，实际上就是在 w 的后面插入。</p>
<p><img src="/upload_image/Position_Command.png" alt="定位命令" title="定位命令"><br>注意：上图中前面有冒号的表示编辑模式命令，没有冒号的表示命令模式命令。</p>
<p><img src="/upload_image/Delete_Command.png" alt="删除命令" title="删除命令"></p>
<p><img src="/upload_image/Copy_Move_Command.png" alt="复制和剪切命令" title="复制和剪切命令"></p>
<p><img src="/upload_image/Replace_Cancel_Command.png" alt="替换和取消命令" title="替换和取消命令"></p>
<p><img src="/upload_image/Explore_Replace_Command.png" alt="搜索和搜索替换命令" title="搜索和搜索替换命令"><br>Linux 中的查找是严格区分大小写的，但是可以使用「:set ic」(注意冒号)设置不区分大小写；可以使用「:set noic」(注意冒号)设置区分大小写。「:%s 表示全局替换」「g 表示替换的时候不询问」「c 表示替换的时候要询问」</p>
<p><img src="/upload_image/Save_Exit_Command.png" alt="保存和退出命令" title="保存和退出命令"></p>
<p>其他 Vim 常用操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">J          // 合并光标所在行及下一行为一行(在命令模式下)</span><br><span class="line">U          // 撤销对当前行的所有操作</span><br><span class="line">/string    // 向光标下搜索 string 字符串</span><br><span class="line">?string    // 向光标上搜索 string 字符串</span><br><span class="line">N          // 向上搜索前一个搜索动作</span><br><span class="line">yw         // 复制从光标开始到词尾的字符</span><br><span class="line">nyw        // 复制从光标开始的 n 个单词</span><br><span class="line">y^         // 复制从光标到行首的内容</span><br><span class="line">y$         // 复制从光标到行尾的内容</span><br><span class="line">f          // 在当前行查找字符，fx 找到光标后第一个为 x 的字符，3fd 找到第三个为 d 的字符</span><br><span class="line">F          // 同 f 反向查找</span><br><span class="line">:!命令     // 执行外部命令</span><br><span class="line"></span><br><span class="line"># 命令模式下移动光标</span><br><span class="line">h 向左、j 向下 、k 向上、l 向右</span><br><span class="line">空格键向右、Backspace 向左、Enter 移动到下一行首、- 移动到上一行首</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：以下为 vim 必须掌握的常用命令：dd 剪切当前行，ndd 剪切当前行以下 n 行；x 删除光标所在处字符；yy 复制当前行，nyy 复制当前行以下 n 行；小写 p 粘贴在当前光标所在行的行下，大写 P 粘贴到行上；R 从光标所在处开始替换字符，按 Esc 结束；u 取消上一步操作！Ctrl+r 反向撤销；ZZ 保存退出的快捷键；当如果不知道自己处在什么模式时可以按 2 次 Esc 键即可回到命令模式。</strong></p>
<h2 id="Vim-使用技巧"><a href="#Vim-使用技巧" class="headerlink" title="Vim 使用技巧"></a>Vim 使用技巧</h2><hr>
<p>「:r 文件名」可以导入一个文件的内容到当前 vim 编辑的文件之中。eg：「:r /etc/issue」导入的位置为刚才你光标所在的位置。</p>
<p>「:!命令」可以在不退出 vim 的情况下，执行系统响应的操作命令。eg：「:!which ls」</p>
<p>「:r!命令」将一个命令的执行结果导入到当前的 vim 文件里面。eg：「:r!date」</p>
<p>自定义快捷键「:map 快捷键 触发命令」。eg：「:map ^p I#<esc>」^p 表示 ctrl + p 的快捷键，该快捷键代表的命令是：跳到行首并进入插入模式，插入 # 号，然后退出。eg：「:map ^b 0x」表示用快捷键 ctrl + b 表示删除行首字母。<strong>^ 表示 ctrl 的意思，如：^c 就表示 ctrl + c。</strong></esc></p>
<p><strong>注意：设置快捷键的方式是，使用 ctrl + v + 所需字母；或者先按 ctrl + v，再按 ctrl + 所需字母，效果是一样的。这种是构造 ctrl + 字母的快捷键的方法。</strong></p>
<p>连续行注释：「n1,n2s/^/#/g」表示从 n1 行开始到 n2 行，每行的行首都增加 # 号，并且替换的时候不询问。  去掉连续行注释：「n1,n2s/^#//g」表示从 n1 行开始到 n2 行，每行的行首的 # 号都替换为空，并且替换的时候不询问。  如果注释符是「//」则需要转义：「:n1,n2s/^/\/\//g」表示从 n1 行开始到 n2 行，每行的行首都增加 // 号，并且替换的时候不询问。注意：「^」表示行首的意思。注意：在 Linux 中「\/」中「\」表示转义符的意思「/」它才是真正的符号。</p>
<p>替换命令：「:ab 旧内容 新内容」即「:ab a b」这个命令可以简单的理解为：当你输入 a，它会自动的帮你转换成 b。eg: 「:ab sb hello」 当前输入 sb 的时候，会自动的替换成 hello。</p>
<p>注意：以上定义的快捷键重启以后都不存在，要想永久生效，你需要将其定义在每个用户的宿主（家）目录中的配置文件里面。以 root 为例：vi /root/.vimrc (注意这个配置文件叫 .vimrc)这里面只能放一些<strong>编辑模式</strong>的命令，比如：设置行号、设置快捷键、ab 命令（前面可以没有冒号「:」）。</p>
<p>/root/.vimrc 文件中自定义永久有效的快捷键<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim 自动设置行号</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line"># ctrl + p 表示 I#&lt;Esc&gt;</span><br><span class="line">map ^p I#&lt;Esc&gt;</span><br><span class="line"></span><br><span class="line"># 设置 ab 命令</span><br><span class="line">ab sb hello</span><br></pre></td></tr></table></figure></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://www.jianshu.com/p/6aa2e0e39f99" target="_blank" rel="noopener">Vim速查表</a><br><a href="http://www.pchou.info/linux/2016/11/10/vim-skill.html" target="_blank" rel="noopener">vim 使用技巧</a><br><a href="https://zhinan.sogou.com/guide/detail/?id=316512949354&amp;utm_source=wechat_search&amp;utm_medium=organic" target="_blank" rel="noopener">Vim 的使用方法</a><br><a href="https://mp.weixin.qq.com/s/PxLzWlzqhhNrFMlm0hg2_A" target="_blank" rel="noopener">增强 Vim 编辑器</a><br><a href="https://mp.weixin.qq.com/s/k9PBlG5D6ylzTXfrj2ZI6g" target="_blank" rel="noopener">Vim 命令、操作、快捷键全集</a></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(五)</title>
    <url>/2018/09/19/Linux-2018-09-19-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%BA%94/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(五) —— Linux 常用命令 </blockquote>

<a id="more"></a>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>1、帮助命令 man<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 manual；命令所在路径：/usr/bin/man；作用：获得帮助信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    man [命令或配置文件]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看命令的帮助信息</span><br><span class="line">    man ls</span><br><span class="line"></span><br><span class="line">    # 查看配置文件的帮助信息</span><br><span class="line">    man services</span><br></pre></td></tr></table></figure></p>
<p>manual 英文意思手册，指南；使用 man 命令相当于调用了一个 less 的浏览方式。</p>
<p>如何看命令的帮助信息？1、知道命令是干什么用的，通过查看帮助信息的第一行即 NAME 行。2、知道命令的选项是干什么用的，通过「/+关键字」的方式可以快速定位到你要找的内容，通过 n 键向下继续查找。</p>
<p>如何查看配置文件的帮助信息？1、这个配置文件是干什么用的，通过查看帮助信息的第一行即 NAME 行；2、这个配置文件的格式是什么样的，在 Linux 中任何配置文件都是有规律的，即格式，可以在配置文件的帮助文档中查看到。</p>
<p>注意在使用 man 来查看配置文件帮助的时候，不可以写成「man + 配置文件绝对路径」！！！此时你得到的并不是帮助信息，而是配置文件的内容。查看配置文件帮助的时候只要使用「man + 配置文件名称」即可。通过查看第一行即 NAME 行，它会告诉你这个配置文件是一个什么样的文件。</p>
<p>man 命令的帮助类型：「1」表示命令的帮助，「5」表示配置文件的帮助。eg：如 passwd 既对应一个命令又对应一个配置文件，使用 man 会优先显示命令的帮助。要想查看配置文件的帮助，则 <code>man 5 passwd</code> 加一个数字 5 声明你要查看配置文件的帮助。</p>
<p>执行指令 man services 等查看配置文件帮助文档的时候出现「没有 services 的手册页条目」。解决办法：安装 man 帮助文档包。指令为：<code>yum install man-pages</code>。</p>
<p>「whatis + 命令名称」它可以直接读取到这个命令 NAME 部分的信息。</p>
<p>「apropos + 配置文件的名称」只想查看一个配置文件的简短信息。</p>
<p><code>命令 --help</code> 只想查看命令的选项，不想看到其他的描述语言。</p>
<p>命令 info 即 infomation，也可以获得帮助信息，其作用跟 man 大同小异，只是在帮助信息的显示有所差别，包括方式上支持一些跳转。</p>
<p>2、帮助命令 help<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：Shell 内置命令；作用：获得 Shell 内置命令的帮助信息</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看 umask 命令的帮助信息</span><br><span class="line">    help umask</span><br></pre></td></tr></table></figure></p>
<p>Shell 其实就是一个命令解释器，找不到命令所在路径的命令都是 Shell 内置命令，eg：cd、umask。这些命令不能使用 man 来查看帮助，它会列出 Shell 所有的帮助信息。可以使用 help 来获取 Shell 内置命令的帮助信息。</p>
<p>3、Linux 中的命令大致可分为两类，内部命令和外部命令。内部命令：也称 Shell 内嵌命令；外部命令：存放在一个文件中，使用时需要去文件中查找，这些文件被定义在 $PATH 中。<strong>type 命令可以查看命令类型，以区别是内部命令还是外部命令，格式 <code>type 命令名称</code>。</strong></p>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>1、用户管理命令 useradd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/sbin/useradd；作用：添加新用户</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    useradd 用户名</span><br></pre></td></tr></table></figure></p>
<p>useradd 命令只有 root 用户可以使用。</p>
<p>useradd 命令在添加的时候只是添加了用户的基本信息，例如家目录、相关的命令解释器的分配等，并没有给它设置一个验证密码。</p>
<p>2、用户管理命令 passwd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/passwd；作用：设置用户密码</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    passwd 用户名</span><br></pre></td></tr></table></figure></p>
<p>注意：更改密码的时候只有管理员可以随意更改密码，普通用户必须要满足密码原则才可以更改密码成功。每个普通用户只能用 passwd 更改自己的密码，而管理员 root 可以用 passwd 更改任何人的密码。</p>
<p>3、用户管理命令 who<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/who；作用：查看登录用户信息</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/Command_who_show.png" alt="who 命令显示内容" title="who 命令显示内容"><br>who 命令显示内容解释：登录用户名（一个用户可以多次登录）、登录的终端（tty 表示本地终端，即在 Linux 机器本身上登录，tty 又叫本地登录）（pts 表示远程终端，即远程登录）、登录时间、括号里的内容是登录的主机的 IP 地址，如果没有写就表示本机登录。</p>
<p>4、用户管理命令 w<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/w；作用：查看登录用户详细信息</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/Command_w_show.png" alt="w 命令显示内容" title="w 命令显示内容"></p>
<p>w 命令的第一行信息解释：当前系统时间、系统连续运行多久、当前一共有几个用户登录、负载均衡指数（这个指数有 3 个数值，分别记录了过去的 1 分钟、5 分钟和 15 分钟，系统的一个负载情况，一般来讲系统的负载值主要指的就是 cup 和内存的负载情况）。IDLE 表示该用户登录过来已经空闲多久了；PCPU 指的是该用户当前登录过来执行的操作占用的 cpu 的时间（下面的数字指的是当前执行的命令占用的 cpu 时间，因为进程在执行的时候是排队依次执行，每个进程在一个 cpu 循环周期里面会分配一定的 cpu 时间，如果一个进程在 cpu 循环周期里多次，它就会占用多个 cpu 时间）；WHAT 指的是他当前执行了什么操作；JCPU 累计占用的 cpu 时间。</p>
<h2 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h2><p>1、压缩命令 gzip<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/gzip；作用：压缩文件；压缩后文件格式：.gz</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    gzip [文件]</span><br></pre></td></tr></table></figure></p>
<p>解压命令 gunzip<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/gunzip；作用：解压缩 .gz 的压缩文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    gunzip [选项] 压缩文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S    指定后缀以取代 .gz，suffix</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/gzip_gunzip.png" alt="gzip&amp;gunzip" title="gzip&amp;gunzip"></p>
<p>注意：gzip 只能压缩文件，不能压缩目录。而且使用 gzip 压缩是不保留源文件的，使用 gunzip 解压缩也是不保留源文件的。解压缩命令：gunzip（即在 gzip 压缩命令中间加入 un）或者使用 gzip -d 命令，两种命令的效果是一样的。gzip 的压缩比约为 5:1。</p>
<p>2、压缩解压命令 tar<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/tar；作用：打包目录；压缩后文件格式：.tar.gz</span><br><span class="line"></span><br><span class="line">格式：tar [选项] [压缩后文件名] [文件或目录]    </span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c  打包，create</span><br><span class="line">    -x  解包，extract</span><br><span class="line">    -v  显示详细信息，verbose</span><br><span class="line">    -f  指定文件名，file</span><br><span class="line">    -z  打包的同时用 gzip 或 gunzip 压缩或解压</span><br></pre></td></tr></table></figure></p>
<p>tar 本身的意思是打包，它可以把一个目录打包成一个文件，同时也可以在打包的同时做一个压缩。tar -cvzf 的压缩比约为 5:1。<strong>使用此组命令会保留源文件。</strong></p>
<p><strong>注意：在使用 tar 的压缩解压命令的时候，-f 后面一定要紧跟它要指定的文件，否则可能会报错。如果 -f 后面没有紧跟它要指定的文件，则 tar 命令的选项中不能加「-」，否则会报错 <code>Cannot stat: No such file or directory</code>。</strong></p>
<p>3、压缩命令 zip<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/zip；作用：压缩文件或目录；压缩后文件格式：.zip</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    zip [选项] [压缩后文件名] [文件或目录]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r  压缩目录</span><br></pre></td></tr></table></figure></p>
<p>解压命令 unzip<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/unzip；作用：解压 .zip 的压缩文件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    unzip [压缩文件]</span><br></pre></td></tr></table></figure></p>
<p>一般来讲，Linux 里面的压缩包的格式 windows 的压缩软件几乎都支持。但反过来就要看具体情况了。默认在使用的过程中，只有一种压缩格式 windows 和 Linux 双方都不需要再额外装什么软件都可以进行解压缩处理的就是 .zip 格式。<strong>使用 zip 命令：会保留源文件，可以压缩目录。</strong> 压缩比没有 gzip 那么可观，所以使用的会比较少。使用 unzip 命令进行解压缩的时候，不分压缩文件是目录还是文件，都可以进行解压缩。</p>
<p>4、压缩命令 bzip2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/bzip2；作用：压缩文件；压缩后文件格式：.bz2</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    bzip2 [选项] [文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -k  产生压缩文件后保留原文件，keep</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 压缩</span><br><span class="line">    bzip2 -k test</span><br><span class="line"></span><br><span class="line">    # 跟 tar 命令结合使用，采用 bzip2 的方式压缩</span><br><span class="line">    tar -cjf test.tar.bz2 test</span><br></pre></td></tr></table></figure></p>
<p>这是一个 gzip 的升级版本。值得注意的是 bzip2 的压缩比是非常惊人的，一般往往用来压缩大的文件。还可以跟 tar 一起来使用：即用 tar 命令里的 z（z 表示 tar 命令中的压缩方式）替换为 j（j 表示 bzip2 的压缩方式）。注意 bzip2 只能处理文件，不能处理目录。</p>
<p>解压命令 bunzip2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/bunzip2；作用：解压缩</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    bunzip2 [选项] [压缩文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -k    解压缩后保留原文件，keep</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 解压</span><br><span class="line">    bunzip2 -k test.bz2</span><br><span class="line"></span><br><span class="line">    # 跟 tar 命令结合使用，解压 bzip2 方式的压缩</span><br><span class="line">    tar -xjf test.tar.bz2</span><br></pre></td></tr></table></figure></p>
<p>如果该目录下有跟解压后的文件同名的文件则该命令会拒绝解压缩，不会像其他命令询问你是否覆盖等。要想解压则必须先删除或更改同名文件。在解压缩 .tar.bz2 文件的时候同样适用 tar 命令，注意把 z 替换为 j 即可。</p>
<p>小结：</p>
<ol>
<li>.gz 类型的压缩文件 gzip 进行压缩 gunzip（或 gzip -d）进行解压缩。不能压缩目录，不能保留源文件。</li>
<li>.tar 类型的文件 可以生成打包文件 tar -cf 打包，-xf 解包，可以利用此命令进行压缩目录。</li>
<li>.tar.gz 类型的压缩文件 tar -zcf 打包并压缩，tar -zxf 解包并解压缩。</li>
<li>.zip 类型的压缩文件 zip 压缩文件 zip -r 压缩目录，unzip 解压缩文件或者目录（压缩比不是特别高，windows 和 Linux 通过格式）。</li>
<li>.bz2 类型的压缩文件 bzip2 进行压缩，bunzip2（或者是 bzip2 -d）进行解压缩。</li>
<li>.tar.bz2 类型的压缩文件 tar -cjf 生成压缩包，tar -xjf 进行解压缩。</li>
</ol>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p>1、网络命令 write<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/write；作用：给用户发信息，以 Ctrl + D 保存 结束</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    write 用户名</span><br></pre></td></tr></table></figure></p>
<p>注意：在 write 命令的输入界面，按退格键是不行的，需要按 Ctrl + 退格键或者按 Delete 键，表示退格的意思。内容输入结束后按回车，然后使用 Ctrl + D 保存并结束。<strong>特别注意的是只能给在线用户发送，如果用户不在线消息是发不出去的。</strong></p>
<p>2、网络命令 wall<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 write all；命令所在路劲：/usr/bin/wall；作用：发广播信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    wall 消息</span><br></pre></td></tr></table></figure></p>
<p>给当前所有在线用户发送信息。在使用该命令发送广播信息的时候，自己也会受到一条发的广播信息。本地终端也会收到广播信息。<strong>注意只有在线用户可以收到消息。</strong></p>
<p>3、网络命令 ping<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/ping；作用：测试网络连通性</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ping [选项] IP地址</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c   指定发送次数</span><br></pre></td></tr></table></figure></p>
<p>现在使用最多的远程探测命令，工作机制：给远程主机发送一个信息包，判断你是否存在即看看你是否回应我，只要你回应，就证明咱们两个之间网络是通的。注意在使用 ping 命令的时候，重点看 package loss 即丢包率这个属性。如果丢包率非常高，即使你 ping 通了，证明你的网状态其实也非常差 。</p>
<p>4、网络命令 ifconfig<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    英文原意 interface configure；命令所在路径：/sbin/ifconfig；作用：查看和设置网卡信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    ifconfig 网卡名称 IP地址</span><br></pre></td></tr></table></figure></p>
<p>Linux 系统中默认有两块网卡，eth0 代表的是本地的真实网卡，lo 回环网卡，用来本机通信和测试的，地址也是固定的，都是 127.0.0.1，不插网线甚至网卡驱动不安装，都可以 ping 通。</p>
<p><img src="/upload_image/ifconfig_command_show.png" alt="ifconfig" title="ifconfig"></p>
<ol>
<li>eth0:网卡接口名称；flags：标志位，UP 表示网卡启用激活状态； mtu：maximum transmission unit，网卡最大传输单元为 1500 字节；</li>
<li>inet：IPv4 地址； netmask：子网掩码；broadcast：广播地址；</li>
<li>inet6：IPv6 地址；</li>
<li>ether(HWaddr)：以太网地址；txqueuelen 1000  (Ethernet)：以太网传输队列长度；网卡的硬件地址即我们所说的 MAC 地址，它是用十六进制表示的，48 位的地址，表示我的网卡的物理地址。MAC 地址是固化在网卡的只读存储器中的一个地址，位于网卡的芯片上，理论上来讲一般是不能改的。</li>
<li>RX packets 13245  bytes 1989908 (1.8 MiB)：此次网卡激活后接搜到的报文数量，总大小；</li>
<li>RX errors：接收时错误的个数；dropped：丢包个数；overruns：溢出个数；frame：帧。</li>
<li>TX packets 162  bytes 18461 (18.0 KiB)：传输的报文数量，总大小；</li>
<li>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0：传输时错误、丢包、溢出、搬运、碰撞的个数。</li>
</ol>
<p>5、网络命令 mail<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/mail；作用：查看发送电子邮件</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mail [用户名]</span><br></pre></td></tr></table></figure></p>
<p>mail 命令比 write 命令有一个好处，就是不管对方在不在线，都可以给对方发送邮件。Linux 的纯字符界面也可以进行邮件的收发，它利用的并不是真正的搭建好的邮件服务器，而是如果是本机用户给本机用户发信，它利用的是本地的内存。</p>
<p>mail 命令编辑完邮件后点击 Ctrl + D 保存结束。使用 mail 命令直接按回车，用来接受邮件，N 表示 new，即这是新收到的邮件还未阅读。想看第几分信，邮件前面有一个序列号，输入序列号回车就能看到这份邮件的具体内容，使用 h 键可以回到刚才的邮件列表，发现 N 消失了，表示邮件已读，要想删除邮件则「d 邮件序列号」，再按 h 查看邮件发现没有邮件了，q 键退出。</p>
<p>学习 mail 命令主要是有的时候系统会给 root 发一些系统信息的邮件，当你在用 root 登录以后系统会提示你有新的邮件需要接受，这个时候就需要我们知道怎么样来收到系统发给你（root）的信息。系统给 root 发送的信息都是非常重要的，例如日志的统计信息、系统的报错信息，当我们发现 root 有这样的邮件的时候，千万不可以忽略它，应该仔细的查看它，因为这说明你对的系统当中可能出现了一些问题，有可能会影响到你的系统的安全。</p>
<p>6、网络命令 last<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/last；作用：列出目前与过去登入系统的用户信息</span><br></pre></td></tr></table></figure></p>
<p>该命令会统计我的计算机的所有用户的登陆的时间信息，包括计算机重启时间也会被记录下来。这是一个重要的日志查询点，可以查看系统是否有异常登陆重启等信息。该命令是一个非常有效，非常重要，非常常用的日志查询命令，在服务器上可能会多次使用这样的命令。只想知道用户最后一次登陆的时间，不想知道所有的登陆信息，则可以使用另外一条命令：lastlog。last 统计的是只要有人登陆它就会记录，包括你多次登陆的信息。而 lastlog 会先把所有的用户都列出来，包括一些不能登陆的系统用户。</p>
<p>7、网络命令 lastlog<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/lastlog；作用：检查某特定用户上次登录的时间</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # -u 指的是用户的 UID，查看特定用户的最后一次登陆的时间</span><br><span class="line">    lastlog -u 500</span><br></pre></td></tr></table></figure></p>
<p>8、网络命令 traceroute<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/traceroute；作用：显示数据包到主机间的路径</span><br></pre></td></tr></table></figure></p>
<p>作用：探测到达某一个指定网站（某一个主机）的路径。这条命令非常有用，可以事先探测好你访问某网站的路径，然后当你访问该网站出现问题的时候，可以对照然后得出哪里出现了问题。我们 traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了返回信息，所以我们得不到什么相关的数据包返回数据。</p>
<p>9、网络命令 netstat<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/netstat；作用：显示网路相关信息</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    netstat [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -t   查询 TCP 协议的网络信息</span><br><span class="line">    -u   查询 UDP 协议的网络信息</span><br><span class="line">    -l   查看监听的端口，listening</span><br><span class="line">    -r   查看路由即查看网关，route</span><br><span class="line">    -n   用 IP 地址和端口号显示查询结果，而不是用域名或服务的名称，这样更快，因为省略了解析过程，numeric</span><br><span class="line">    -a   all</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看本机监听的端口，即查询当前计算机下，我开了哪些计算机端口</span><br><span class="line">    netstat -tuln</span><br><span class="line"></span><br><span class="line">    # 查看本机所有的网络连接</span><br><span class="line">    netstat -an</span><br><span class="line"></span><br><span class="line">    # 查看本机路由表，即查询路由列表</span><br><span class="line">    netstat -rn</span><br></pre></td></tr></table></figure></p>
<p>net 网络的意思，stat 即 state 状态的意思，查询网络状态的命令。这条命令的用途在服务器上非常广泛的。TCP 是传输控制协议的简称；UDP 用户数据报协议的简称。一般情况下服务的端口号是固定的，我们可以通过判断本机开了哪些监听端口来判断我的计算机开启了哪些服务。注意：TCP 协议才可以直接接受访问，所以它有 listen，代表状态是监听的。而 UDP 是没有的，它可以直接发送，不监听即不顾你在不在线。访问服务的时候不管访问的是 22 还是访问其他的服务，你的发起端口即源端口是 1024 以上的随机端口，只有目标端口是固定的。</p>
<p><img src="/upload_image/netstat_an.png" alt="netstat -an" title="netstat -an"><br>发现该命令的输出分了两大类，一类是上面的这些网络服务，除了有监听的协议之外，状态还出现了 ESTABLISHED 表示正在连接的。另一类就是下面的除了服务状态计算机中会有很多网络程序，它也会使用网络协议，使用网络端口，你可以看到这些程序所占用的端口，这个对我们意义不大。主要看到还是上面的信息。它跟 netstat -tlun最大的区别在于 netstat -tlun 只能查看监听，而它可以查看到正在连接的网络程序。</p>
<p><img src="/upload_image/netstat-rn.png" alt="netstat -rn" title="netstat -rn"><br>Destination 为 0.0.0.0 那行是当前计算机的默认路由列表，其实就是自己的网关。可以通过该命令查询当前计算机的网关。还可以通过 <code>route -n</code> 或 <code>cat /etc/resolv.conf</code> 查看当前计算机的网关。</p>
<p>10、网络命令 setup<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/usr/bin/setup；作用：配置网络</span><br></pre></td></tr></table></figure></p>
<p>setup 是 redhat 开发的一个管理工具集合，它在其它的版本的 Linux 中不存在，这是 redhat 系类专有的。注意在配置完成后一点要重启网络服务：service network restart。使用 setup 配置的 IP 地址是永久生效的。该命令简单了解即可。</p>
<h2 id="挂载命令-mount"><a href="#挂载命令-mount" class="headerlink" title="挂载命令 mount"></a>挂载命令 mount</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    命令所在路径：/bin/mount</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    mount [-t 文件系统] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure>
<p>该命令的作用是把我的设备连接到我给它分配的挂载点（可以理解为 windows 中的盘符，只是我们的挂载点是目录，而 windows 中的是 CDEF）。分区都是自动挂载的，只要安装了，分区了，每次启动不需要手动参与直接就可以挂载。但是 Linux 的 U 盘、光盘、移动硬盘等外接存储设备不能实现自动挂载，每次开机都只能手工来挂载。</p>
<p>挂载步骤：</p>
<ol>
<li>先创建挂载点：mkdir  /mnt/cdrom。</li>
<li>开始实现挂载：mount -t （-t 后面指定光盘的文件系统）iso9660（光盘的文件系统是固定的） /dev/sr0（设备文件名称，其来源是系统默认指定的，Linux 系统在 redhat centOS6.0 以上的系统中，设备文件名默认就叫 sr0，只要记住就可以了，不需要知道它是怎么来的，当然也可以写 cdrom，实际上就是一个软连接，通过命令：ll  /dev/cdrom 可以查看到）。这条命令中其实 -t iso9660 是可以省略的，因为该命令的这个选项或者说分区的光盘的文件系统是默认的，系统就知道它就叫  iso 9660，不写也可以。</li>
</ol>
<p>挂载其实就是找到这个硬件，给它分配一个设备文件名，再给它找一个盘符（即目录），把它的设备文件名和盘符连接起来，就是挂载。（挂载的本质：就是把设备文件名连接到挂载点上）。如果之前你的这个挂载点上做过挂载，那么你需要把它卸载以后再进行挂载：umonut  /dev/sr0。正常挂载完，mount 命令是没有任何提示的，这里提示的作用是报错，它尝试把它挂成写权限，但是光驱是只读的，所以被迫挂成了只读的，光盘绝大多数都是只读的。（windows 是光盘符下访问，而 Linux 中的盘符是目录）挂载完成后通过 cd（即cd  /mnt/cdrom）切换到盘符目录下去访问它的数据。（/dev/sr0 是一个文件，cd 命令是进不去的）。注意：必须要执行卸载命令，才可以弹出光盘。切记不可以在光盘挂载点下面卸载，因为系统会认为光盘正在使用，不允许卸载。你需要退出挂载点，直接 cd 即可返回到自己的宿主目录。在卸载的时候，因为 /dev/sr0 和 /mnt/cdrom 它们两个通过 mount 命令已经连接了，所以后面加其中任何一个都是可以的，但是只能跟一个，要是跟两个它就会卸载两遍，第二遍它就会报错。直接回车没有任何提示表示卸载成功，再回到 /mnt/cdrom 执行 ls 命令发现变成了空目录了。</p>
<h2 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h2><p>1、shutdown 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：shutdown [选项] 时间</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c   取消前一个关机命令，cancel</span><br><span class="line">    -h   关机，halt</span><br><span class="line">    -r   重启，reboot</span><br></pre></td></tr></table></figure></p>
<p>除了 shutdown 命令之外还有其他命令可以实现关机或重启，只是早期的时候只有 shutdown 命令会在关机和重启之前正确的保存它正在启动的服务，尽管现在 Linux 中绝大多数的关机重启命令都已经实现了正确的关闭服务和保存数据，只是我们已经习惯了 shutdown 命令了。虽然其他命令也可以做到，但是 shutdown 命令更安全一点，我们更信任它。</p>
<p>2、其他关机命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关机</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line"># 关机</span><br><span class="line">power off</span><br><span class="line"></span><br><span class="line"># 关机</span><br><span class="line">init 0</span><br></pre></td></tr></table></figure></p>
<p>注意：poweroff 相当于直接断电，谨慎使用！！！</p>
<p>3、其他重启命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重启</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">init 6</span><br></pre></td></tr></table></figure></p>
<p>4、系统运行级别<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   关机</span><br><span class="line">1   单用户</span><br><span class="line">2   不完全多用户，不含 NFS 服务</span><br><span class="line">3   完全多用户</span><br><span class="line">4   未分配</span><br><span class="line">5   图形界面</span><br><span class="line">6   重启</span><br></pre></td></tr></table></figure></p>
<p>单用户类似于 windows 中的安全模式，其实就是启动最小的服务，其他多余的东西、附加的程序都不要，甚至连网都不要，只启动最核心的程序，进去是用来做修复的。只能是 root 登录进去，其他用户都不行，顾名思义即为单用户。运行级别 1 是没有图形界面的，不光 1 级别没有图形界面，1、2、3 这 3 个运行级别都是没有图形界面的，4 是没有使用的，即可以自己定义，5 是标准的图形界面。2、3 其实都是命令行，区别是：3 是完全的命令行，而 2 是不包含 NFS 服务的命令行，即它也是命令行只是不完整（2 级别也没有网络服务）。NFS 服务：（network file system）网络文件系统，使用 NFS 是实现两个 Linux 之间的文件共享或者是 Linux 和 Unix 之间的文件共享的服务。由于 NFS 用户验证的机制比较弱，即可能不是太安全，有它自己的安全隐患在里面，所以不太建议使用 NFS 来进行文件共享，当然使用它进行文件共享确实很简单方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看系统默认运行级别</span><br><span class="line">cat /etc/inittab</span><br><span class="line"></span><br><span class="line"># 修改系统默认运行级别，注意：id 最后是有冒号的「:」，千万不可以丢！！！</span><br><span class="line">id:3:initdefault:</span><br><span class="line"></span><br><span class="line"># 查看系统运行级别</span><br><span class="line">runlevel</span><br></pre></td></tr></table></figure>
<p>注意：0 和 6 不能设为系统默认运行级别。在 Linux 中用 X11 代表图形界面，大写的 X 指的是 Xwindow，一般来讲，在 Linux 中看到类似于这样的表示（包括只有一个大写的 X）都表示 Linux 的一个图形环境的意思。</p>
<p>执行 runlevel 命令之后会有「N  3」这样的显示，3 表示当前运行的级别号，N 代表上一个运行级别，即进入 3 级别之前我在哪个级别（由于我们是开机之后直接进来的，所以是 N 表示 null 的意思）。</p>
<p><code>init 5</code> 表示切换到运行级别 5 即图形界面，由于我没有装图形界面它不会执行，且远程工具上是不会报错的，但是在 Linux 本地上会有报错提示，它尝试去启动 5 级别，但是没有启动成功。但是系统以为你进去了，所以执行 runlevel 命令的时候会有显示 <code>5 3</code>。</p>
<p>5、退出登录命令 logout<br>退出一个登录 Shell。注意：在使用完 Linux 后，一定要 logout！！！否则后果很严重！！！</p>
<p>6、Linux 中的管道符<br>利用 Linux 所提供的管道符「|」将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://blog.51cto.com/9762617/1678917" target="_blank" rel="noopener">centOS 7 安装 man 中文版手册</a><br><a href="https://blog.csdn.net/qq_36838191/article/details/80314101" target="_blank" rel="noopener">Linux 中的内部命令和外部命令</a><br><a href="http://blog.51cto.com/xuding/1728866" target="_blank" rel="noopener">Linux 网络属性配置命令</a></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(七)</title>
    <url>/2018/10/18/Linux-2018-10-18-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B8%83/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(七) —— 软件包管理 </blockquote>

<a id="more"></a>
<h2 id="RPM-包管理之-rpm-命令管理"><a href="#RPM-包管理之-rpm-命令管理" class="headerlink" title="RPM 包管理之 rpm 命令管理"></a>RPM 包管理之 rpm 命令管理</h2><p>1、Linux 软件包分类</p>
<ol>
<li>源码包 （脚本安装包）</li>
<li>二进制包（RPM 包、系统默认包）</li>
</ol>
<p>Linux 是 C 语言写的，这里指的源码包绝大多数都是 C 语言写的。源码包和二进制包最大的区别就是：源码包是直接开发完的源代码给你，而二进制包它是将经过编译以后的包给你，看不到源代码了。编译的时间会比较慢。在 Centos 中我们把二进制包称为 RPM（red hat package manage）包。</p>
<p>2、RPM 包命名规则<br><img src="/upload_image/rpm_name_rule.png" alt="RPM 包命名规则" title="RPM 包命名规则"></p>
<p>15 指的是在这个版本上发布了 15 次。el6.centos 指 rpm 包的这个版本可以在 RHEL6 和 Centos 这两个 Linux 版本上安装。noarch 表示任何硬件平台都可以安装。有的包没有写适合哪个 Linux 平台，则适合所有的 Linux 平台。</p>
<p>注意区分包名和包全名：</p>
<blockquote>
<p>包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径。上图的包全名为「httpd-2.2.15-15.el6.centos.1.i686.rpm」。一般是安装和升级的时候使用包全名，因为安装和升级的时候这些包都没有安装，操作的是未安装的包所以使用包全名。<br>包名：操作已经安装的软件包时，使用包名。是搜索 /var/lib/rpm 中的数据库。上图中的包名为「httpd」。一般查询、卸载这些命令操作的对象都是包名。</p>
</blockquote>
<p>3、RPM 包依赖性<br><img src="/upload_image/rpm_dependence.png" alt="RPM 包依赖性" title="RPM 包依赖性"></p>
<p>解决环形依赖：用一条命令把软件包 a、b、c 同时安装，就会解决环形依赖。</p>
<p>软件包库依赖(即模块依赖)：库依赖有个特征，只要是用「.so.数字」结尾，这种包都是库依赖，这个库依赖的不是单独独立的包，它是某一个软件安装包里面的某一个软件。即只要你找到了这个软件所在的包，然后将其所在的包安装，那么这个软件就会随着包的安装而自动安装，就会解决依赖性问题。通过 <a href="http://www.rpmfind.net" target="_blank" rel="noopener">www.rpmfind.net</a> 查找某个软件属于哪个依赖包。</p>
<p>4、RPM 包的安装、升级、卸载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm 命令简介：</span><br><span class="line">    命令所在路径：/bin/rpm；作用：RPM 包管理器</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    rpm [选项] [包名/包全名]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i        安装，install</span><br><span class="line">    -v        显示详细信息，verbose</span><br><span class="line">    -h        显示安装进度，hash</span><br><span class="line">    -U        升级，upgrade</span><br><span class="line">    -e        卸载，erase</span><br><span class="line">    --nodeps  不检测依赖性，「no/deps」</span><br><span class="line"></span><br><span class="line"># 安装 RPM 包，注意包全名</span><br><span class="line">rpm -ivh 包全名</span><br><span class="line"></span><br><span class="line"># 升级 RPM 包，注意包全名</span><br><span class="line">rpm -Uvh 包全名</span><br><span class="line"></span><br><span class="line"># 卸载 RPM 包，注意包名</span><br><span class="line">rpm -e 包名</span><br></pre></td></tr></table></figure></p>
<p>注意：安装和卸载用 yum 更为简单，因为它会自动就解决依赖性。但是查询只能通过 rpm，因为 yum 没有 rpm 查询强大，使用 yum 查不了 rpm 那么多的信息，即 rpm 的查询是一个非常常用的功能，不管是通过 rpm 安装还是 yum 安装都可以通过 rpm 命令的查询方式来进行查询。</p>
<p>5、RPM 包的查询</p>
<p>(1)查询包是否安装，-q 查询（query）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -q 包名</span><br><span class="line"></span><br><span class="line"># 查询所有已经安装的 RPM 包</span><br><span class="line">rpm -qa</span><br></pre></td></tr></table></figure></p>
<p>注意：这里查询是从 Linux 后台系统数据库中取数据，所以不需要路径，任何位置都可以直接执行相应的命令。</p>
<p>(2)查询软件包详细信息，-i 查询软件包信息（information），-p 查询未安装包信息（package）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询已安装包信息</span><br><span class="line">rpm -qi 包名</span><br><span class="line"></span><br><span class="line"># 查询未安装包信息</span><br><span class="line">rpm -qip 包全名</span><br></pre></td></tr></table></figure></p>
<p>(3)查询包中文件安装位置，-l 列表（list），-p 查询未安装包信息（package）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询已安装包文件安装位置</span><br><span class="line">rpm -ql 包名</span><br><span class="line"></span><br><span class="line"># 查询未安装包文件安装位置</span><br><span class="line">rpm -qlp 包全名</span><br></pre></td></tr></table></figure></p>
<p>注意：软件包中文件的安装位置，一个软件包中不止有一个文件，所以使用 list，文件的安装位置（默认安装位置）是固定的，是在生产这个包的时候就已经决定了这个文件装在哪里是合理的，rpm 包可以手动指定安装位置，但是手动指定安装位置会带来一系列的问题，比如：服务管理命令找不到 rpm 的一些功能服务，很多服务其搜索的位置都是默认的，从而会带来一些问题。所以最好采用默认安装位置。  </p>
<p>(4)查询系统文件属于哪个 RPM 包，-f 指定要查询的系统文件名（file）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qf 系统文件名</span><br></pre></td></tr></table></figure></p>
<p>注意：这个系统文件必须是通过包装出来的，才能通过文件反查包。</p>
<p>(5)查询软件包的依赖性，-R 查询软件包依赖性（requires），-p 查询未安装包信息（package）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qR 包名</span><br></pre></td></tr></table></figure></p>
<p>6、RPM 包校验<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 选项 -V 作用：校验指定 RPM 包中的文件（verify）</span><br><span class="line">rpm -V 已安装的包名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 如果结果没有任何输出，则表示没有任何改变；只有改变的情况才会有输出</span><br><span class="line">    rpm -V httpd</span><br></pre></td></tr></table></figure></p>
<p>什么是校验？RPM 包安装之后，先把它的特征记录下来，然后当我需要的时候把现在的文件和原先的文件进行比较，查看文件之间的变化，从而判断现在的文件是否做了修改。我们使用校验是为了判断我们的系统文件是否被人进行了更改。</p>
<p><img src="/upload_image/rpm_V_show.png" alt="rpm -V" title="rpm -V"><br><img src="/upload_image/rpm_V_introduction.png" alt="解析 rpm -V" title="解析 rpm -V"><br><img src="/upload_image/rpm_V_filetype.png" alt="解析 rpm -V" title="解析 rpm -V"><br><img src="/upload_image/rpm_V_introductions.png" alt="解析 rpm -V" title="解析 rpm -V"></p>
<p>如上图所示，如果有字母则表示其对应的项做了修改，如果用点表示，则表示其对应项没有修改，c 是标称文件的类型，c 表示 config 即配置文件的意思。</p>
<p>7、从 RPM 包中提取文件，即从 RPM 包中提取指定的某个或某些文件，主要是用来做修复的，如日常工作中不小心把某个文件给误删除了，这时候可能并不需要重新安装整个包，只需要把对应的文件提取出去并放到相应位置即可修复。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | cpio -idv .文件在包中的绝对路径</span><br><span class="line"></span><br><span class="line"># rpm2cpio 命令的作用：将 rpm 包转换为 cpio 格式的文件</span><br><span class="line"></span><br><span class="line"># cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件</span><br></pre></td></tr></table></figure></p>
<p>rpm2cpio，由于 2 的英文发音 two 和 to 很像，所在 Linux 命令中经常用 2 表示从什么到什么的意思，此处表示从 rmp 格式转换为 cpio 格式。所有的 rmp 包都是 rpm 包格式的，只有把它转换成 cpio 格式的，才可以通过 cpio 命令把这个包中指定的文件提取出来。「\」在 Linux 表示一条命令没有输入完换行下面接着来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    cpio 命令</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    cpio [选项] &lt; [文件|设备]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i   copy-in 模式，还原</span><br><span class="line">    -d   还原时自动新建目录</span><br><span class="line">    -v   显示还原过程</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查询 ls 命令属于哪个软件包</span><br><span class="line">    rpm -qf /bin/ls</span><br><span class="line">    # 造成 ls 命令误删假象</span><br><span class="line">    mv /bin/ls /tmp</span><br><span class="line">    # 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下</span><br><span class="line">    rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls</span><br><span class="line">    # 把 ls 命令复制到 /bin 目录，修复丢失文件</span><br><span class="line">    cp /root/bin/ls /bin/</span><br></pre></td></tr></table></figure>
<h2 id="RPM-包管理之-yum-在线管理"><a href="#RPM-包管理之-yum-在线管理" class="headerlink" title="RPM 包管理之 yum 在线管理"></a>RPM 包管理之 yum 在线管理</h2><p>注意：yum 是一个命令，管理的是 RPM 包，在红帽系列的 Linux 中认为 yum 是一个售后服务，所以有的是收费的。</p>
<p>1、IP 地址配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动网卡</span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0 将 ONBOOT 的值改为 yes</span><br><span class="line"></span><br><span class="line"># 重启网络服务</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure></p>
<p>注意：有 IP 和子网掩码就可以在局域网内使用；如果要想访问互联网，Ip、子网掩码、DNS、网关缺一不可。</p>
<p>2、网络 yum 源<br><img src="/upload_image/yum_base_config.png" alt="网路 yum 源配置格式" title="网路 yum 源配置格式"><br><img src="/upload_image/network_yum_repository.png" alt="网络 yum 源" title="网络 yum 源"><br>在 /etc/yum.repos.d/ 这个目录中，只要是以 .repo 结尾的，都是合法的 yum 源。默认是 Base 生效即网络 yum 源生效。</p>
<p>3、常用 yum 命令<br>(1) 查询<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询对应 yum 源中所有可用软件包列表</span><br><span class="line">yum list</span><br><span class="line"></span><br><span class="line"># 统计对应 yum 源中有多少个软件包</span><br><span class="line">yum list | wc -l</span><br><span class="line"></span><br><span class="line"># 搜索服务器上所有和关键字相关的包</span><br><span class="line">yum search 关键字</span><br></pre></td></tr></table></figure></p>
<p>注意：前面讲解的包名和包全名，只对 rpm 手工管理命令生效，即其使用范围仅限 rpm 手工管理范围。在 yum 中没有包名和包全名之分，只有包名。</p>
<p>(2) 安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># install 安装，-y 自动回答 yes</span><br><span class="line">yum -y install 包名</span><br></pre></td></tr></table></figure></p>
<p>gcc 是 c 语言的编译器，在源码包安装的时候，必须有 gcc 存在，源码包才可以正常安装。</p>
<p>(3) 升级<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># update 升级，-y 自动回答 yes</span><br><span class="line">yum -y update 包名</span><br></pre></td></tr></table></figure></p>
<p>注意：这个升级命令如果没有指定包名，只写了「yum -y update」，它的意思是升级所有的软件包，包括 Linux 内核都会升级，Linux 内核升级完成之后，是需要在本地做一定的配置，你的内核才可以正常使用，才可以启动，如果你是在远程执行的这条命令，你就会发现你的服务器怎么也开不了机了，永远也无法连接，这个时候，这条命令会导致服务器直接崩溃，所以升级命令慎重使用！！！</p>
<p>(4) 卸载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># remove 卸载，-y 自动回答 yes</span><br><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure></p>
<p>注意：在使用 yum 卸载的时候，它会自动把依赖这个包的包全部卸载掉，有可能会造成系统崩溃。Linux 安装原则：安装的时候最小化安装，不安装多余软件。使用什么软件就安装什么软件，手工装，尽量不卸载，<strong>尤其是 yum 卸载，尽量不要多用。这个命令不建议使用！！！</strong></p>
<p>4、yum 软件组管理命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有可用的软件组列表</span><br><span class="line">yum grouplist</span><br><span class="line"></span><br><span class="line"># 安装指定软件组，组名可以由 grouplist 查询出来</span><br><span class="line">yum groupinstall 软件组名</span><br><span class="line"></span><br><span class="line"># 卸载指定软件组</span><br><span class="line">yum groupremove 软件组名</span><br></pre></td></tr></table></figure></p>
<p>注意：如果软件包组名之间有空格，要用双引号括起来，使用的时候要使用英文组名，中文组名是不会被识别的。</p>
<p>5、光盘 yum 源搭建<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、挂载光盘</span><br><span class="line">mount /dev/cdrom /mnt/cdrom</span><br><span class="line"></span><br><span class="line">2、让网络 yum 源失效，即停用所有的网络 yum 源。取巧办法是将 /etc/yum.repos.d/ 文件夹下所有以 .repo 结尾的网络 yum 源改名</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line">mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak</span><br><span class="line">mv CentOs-Vault.repo CentOs-Vault.repo.bak</span><br><span class="line"></span><br><span class="line">3、修改光盘 yum 源，配置光盘地址，enabled 设置为 1 表示开启光盘 yum 源</span><br><span class="line">vim CentOS-Media.repo</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/media_yum_repo.png" alt="光盘 yum 源配置信息" title="光盘 yum 源配置信息"></p>
<p>注意：系统在检测是否为有效 yum 源的时候是通过 .repo 这个后缀的，我们为了不打开一个个去修改，即将配置文件中的 yum 源容器的 enabled 全部设置为 0，所以此处选择了修改文件名的方式，这个简单粗暴省力。</p>
<p>光盘 yum 优点：本地不需要网络，下载更快；缺点：版本不能升级，即版本是固定的，需要连接光盘；注意：file 后面有三个 ///，前两个是固定格式「file://」最后一个代表根目录。对于多余的光盘地址，建议注释掉，虽然不影响使用，但是每次系统都会提示你多余的光盘地址找不的的信息。<strong>注意：指定 baseurl 为自己的光盘挂载地址。</strong></p>
<p>注意：绝大多 Linux 的配置文件对注释都是有严格要求的，不光 # 前面不能加缩进，有一些配置文件甚至在 # 后面都不能加空格。如下所示：这种缩进的就会报错！！！<br><img src="/upload_image/linux_comment.png" alt="错误注释示例" title="错误注释示例"></p>
<h2 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h2><p>1、rpm 包和源码包的区别</p>
<blockquote>
<p>安装之前的区别：概念上的区别<br>安装之后的区别：安装位置不同</p>
</blockquote>
<p>2、RPM 包默认安装位置<br><img src="/upload_image/rpm_default_install_location.png" alt="RPM 包默认安装路径" title="RPM 包默认安装路径"></p>
<p>3、源码包安装位置<br>源码包的安装位置是要手工指定的，一般是「/usr/local/软件名」。/usr 目录是 Unix 系统资源目录，有一个 local 目录，本地的意思，是系统专门为我们准备安装外来应用的地方。我们在目录下创建一个对应软件名进行安装即可。</p>
<p>4、安装位置不同带来的影响<br>(1)RPM 包安装的服务可以使用系统服务管理命令（service）来管理，例如 RPM 包安装的 apache 的启动方法是：<code>/etc/rc.d/init.d/httpd start</code> 或 <code>service httpd start</code>。Linux 要想启动一个可执行文件（服务），都应该是利用绝对路径启动的。service 是 red hat 特有的，service 命令会自动的去 /etc/rc.d/init.d/ 下去寻找，找到了就执行，找不到就报错。类似 service 这种系统服务都会去默认的安装目录下去寻找，主要是 rmp 默认安装的位置，所以可以使用，但是源码包不行，只能是绝对路径启动。</p>
<p>(2)而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：<code>/usr/local/apache2/bin/apachectl start</code>。</p>
<p>小结：rpm 包和源码包由于安装的位置不同，所以带来了服务的管理方法不同。</p>
<p>5、源码包安装方法<br>（1）安装准备</p>
<blockquote>
<p>安装 C 语言编译器</p>
</blockquote>
<p>（2）安装注意事项</p>
<blockquote>
<p>源代码保存位置：/usr/local/src<br>软件安装位置：/usr/local<br>如何确定安装过程是否报错？(1) echo $? 查看上条命令执行结果 (2) 安装过程停止，并且出现 error、warning 或 no 的提示</p>
</blockquote>
<p>（3）源码包安装过程</p>
<blockquote>
<p>下载源码包<br>解压缩下载的源码包<br>进入解压缩目录</p>
</blockquote>
<p>（4）进入解压缩以后的安装目录，注意以下两个文件</p>
<blockquote>
<p><strong>INSTALL 安装说明，注意名字大写。README  使用说明，注意名字大写。</strong> 在 Linux 当中，任何一个源码包都有 INSTALL、README 类似的文件，碰到陌生的源代码的时候，需要先查看说明，再安装或使用源码包。</p>
</blockquote>
<p>（5）软件配置与检查</p>
<p><img src="/upload_image/source_package_configure.png" alt="软件配置与检查" title="软件配置与检查"></p>
<blockquote>
<p>可以使用「./configure –help」查看该源码包可用的配置项的帮助信息，会发现源码包安装会有很多的安装配置选项。此处我们只定义安装的目录为 <code>./configure --prefix=/usr/local/apache2</code>，源码包的安装路径选项在安装的时候是一定要定义的，其他选项可以不定义。configure 配置的意思，即在安装源码包之前，把源代码中需要的配置都先配置好，为随后的检查、编译、安装做好准备。注意：Makefile 文件是要等到 ./configure 这条命令执行之后才会生成，里面包含软件的各种配置，是用来安装软件的。</p>
</blockquote>
<p>（6）编译、安装</p>
<blockquote>
<p>如果前面都通过的话，则执行命令 make 表示编译，如果没有报错的话，则执行 make install 表示安装。到此源码安装就完成了。至于软件安装完成以后如何启动的问题，可以参看源码包中的 INSTALL 等文档的说明。</p>
</blockquote>
<blockquote>
<p>注意：在执行 ./configure 和 make 命令的时候不会向 /usr/local 里面写入任何数据。如果在执行 make 的时候报错，则可以使用 make clean 清空编译的数据，这样可以达到完全清空。make install 才会向真正的目录写入数据。</p>
</blockquote>
<p>6、源码包的卸载<br>不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件。</p>
<p>7、在 Linux 中，如果已经安装了 rpm 包的 httpd，可以再安装源码包的 httpd，因为安装位置不同，所以可以安装，但是没必要同时安装两个相同的软件。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://fukun.org/archives/12131599.html" target="_blank" rel="noopener">Bash 快捷建</a><br><a href="https://blog.csdn.net/yjz_sdau/article/details/52765611" target="_blank" rel="noopener">Linux 上安装源码包</a><br><a href="http://18810098265.iteye.com/blog/2400559" target="_blank" rel="noopener">centos 软件包管理之 rpm 的使用</a><br><a href="https://coderschool.cn/641.html" target="_blank" rel="noopener">Linux 下 /usr 和 /var 的含义和内容</a></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(八)</title>
    <url>/2018/10/22/Linux-2018-10-22-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%85%AB/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(八) —— 用户和用户组管理 </blockquote>

<a id="more"></a>
<h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><h3 id="1、用户信息文件-etc-passwd-详解"><a href="#1、用户信息文件-etc-passwd-详解" class="headerlink" title="1、用户信息文件 /etc/passwd 详解"></a>1、用户信息文件 /etc/passwd 详解</h3><p>在 Linux 中主要是通过用户配置文件来查看和修改用户信息。注意：在操作 passwd 文件的时候备份。可以使用 <code>man 5 passwd</code> 查看配置文件的帮助文档。</p>
<p><img src="/upload_image/etc_passwd_config.png" alt="/etc/passwd" title="/etc/passwd"></p>
<blockquote>
<p>第 1 个字段：用户名称。</p>
</blockquote>
<blockquote>
<p>第 2 个字段：密码标志。x 表示这个用户是有密码的。注意 x 是不能省略的，如果省略了，则用户登录的时候，系统是不会去 shadow 文件中去搜索用户的真正密码的，它会认为这个用户压根就没有密码，可以直接登录。没有密码的登录只允许本地登录，不允许远程登录，因为 ssh 协议本身就禁止的。</p>
</blockquote>
<blockquote>
<p>第 3 个字段：UID（用户 ID）。注意：系统中默认有很多伪用户，但是这些伪用户不能删，一旦删除系统就会崩溃，因为系统有很多服务会调用这些伪用户。这些伪用户是专门用来给系统当中，启动服务、启动命令的时候来调用的。总之这些用户都是系统用户，这些用户不能登录，其次不能删除。</p>
<blockquote>
<p>0:           超级用户，注意系统是通过 UID 为 0 来识别是否为超级管理员的，不是通过用户名是否为 root 识别<br>1-499:       系统用户（伪用户）<br>500-65535:   普通用户    </p>
</blockquote>
</blockquote>
<blockquote>
<p>第 4 个字段：GID（用户初始组 ID）。</p>
<blockquote>
<p>初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组。初始组的特点：每一个用户都必须有且仅有一个初始组。初始组不能选，但是可以改，一旦改变，以前的初始组就会被放弃，因为只能有一个初始组存在。<br>附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。</p>
</blockquote>
</blockquote>
<blockquote>
<p>第 5 个字段：用户说明。</p>
</blockquote>
<blockquote>
<p>第 6 个字段：家目录。</p>
<blockquote>
<p>普通用户：/home/用户名/<br>超级用户：/root/</p>
</blockquote>
</blockquote>
<blockquote>
<p>第 7 个字段：登录之后的 Shell。</p>
<blockquote>
<p>Shell 就是 Linux 的命令解释器。在 /etc/passwd 当中，除了标准 Shell 是 /bin/bash 之外，还可以写如 /sbin/nologin。简单来说：就是你在 Linux 中输入一个命令，eg：ll，实际上中间要通过命令解释器将 ll 命令解释成内核可以识别的符号然后传输给内核，内核再作出应答显示在命令操作窗口，这样的一个过程。对命令的解释就是 Shell 来执行的。默认即标准 Shell 是 /bin/bash，Linux 中 Shell 可以有多个，默认为 /bin/bash，理论上可以更改。  </p>
</blockquote>
</blockquote>
<h3 id="2、影子文件-etc-shadow-详解"><a href="#2、影子文件-etc-shadow-详解" class="headerlink" title="2、影子文件 /etc/shadow 详解"></a>2、影子文件 /etc/shadow 详解</h3><p>注意：/etc/shadow 文件的默认权限为 000，该文件很重要，保存了加密以后的用户密码。</p>
<p><img src="/upload_image/etc_shadow_config.png" alt="/etc/shadow" title="/etc/shadow"></p>
<blockquote>
<p>第 1 个字段：用户名。<br>第 2 个字段：加密密码。注意：如果密码位是「!!」或「*」代表没有密码，不能登录。<br>第 3 个字段：密码最后一次修改日期。使用 1970.01.01 作为标准时间，每过一天时间戳加 1。<br>第 4 个字段：两次密码的修改间隔时间（和第 3 字段相比）。<br>第 5 个字段：密码有效期（和第 3 字段相比）。<br>第 6 个字段：密码修改到期前的警告天数（和第 5 字段相比）。<br>第 7 个字段：密码过期后的宽限天数（和第 5 字段相比）。0 代表密码过期后立即失效。-1 则表示密码永远不会失效。<br>第 8 个字段：账号失效时间。要用时间戳表示。不管前面怎么设置，到时间了直接密码失效。<br>第 9 个字段：保留。</p>
</blockquote>
<p>时间戳换算方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把时间戳换算为日期</span><br><span class="line">date -d &quot;1970-01-01 16666 days&quot;</span><br><span class="line"></span><br><span class="line"># 把日期换算为时间戳</span><br><span class="line"># $() 用来引用系统命令，date --date=&quot;2018/10/01&quot; +%s 将指定日期换算成秒（以 1970.01.01 作为标准时间）</span><br><span class="line">echo $(($(date --date=&quot;2018/10/01&quot; +%s)/86400+1))</span><br></pre></td></tr></table></figure></p>
<h3 id="3、组信息文件-etc-group"><a href="#3、组信息文件-etc-group" class="headerlink" title="3、组信息文件 /etc/group"></a>3、组信息文件 /etc/group</h3><p><img src="/upload_image/etc_group_config.png" alt="/etc/group" title="/etc/group"></p>
<blockquote>
<p>第 1 个字段：组名。<br>第 2 个字段：组密码标志。<br>第 3 个字段：GID。<br>第 4 个字段：组中附加用户。</p>
</blockquote>
<h3 id="4、组密码文件-etc-gshadow"><a href="#4、组密码文件-etc-gshadow" class="headerlink" title="4、组密码文件 /etc/gshadow"></a>4、组密码文件 /etc/gshadow</h3><p><img src="/upload_image/etc_gshadow_config.png" alt="/etc/gshadow" title="/etc/gshadow"></p>
<blockquote>
<p>第 1 个字段：组名。<br>第 2 个字段：组密码。<br>第 3 个字段：组管理员用户名。<br>第 4 个字段：组中附加用户。</p>
</blockquote>
<p>组密码的作用：只有管理员可以将用户加入到其他的用户组，但是 root 太忙了，这时候可以给组选一个管理员，给这个组设置一个密码，只要这个管理员知道密码，就可以把其他人拉到这个组里面来。或者把用户从这个组里面删掉。不推荐使用组密码，安全性差。</p>
<h2 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h2><p>1、用户的家目录</p>
<blockquote>
<p>普通用户：/home/用户名/，所有者和所属组都是此用户，权限 700。<br>超级用户：/root，所有者和所属组都是 root 用户，权限是 550。</p>
</blockquote>
<p>注意：用户的家目录是添加用户的时候自动生成的，可以在添加的时候不让它自动生成，手动创建，但是所有者、所属组以及权限都需要手动去调整。将普通用户变为超级管理员，修改 /etc/passwd 文件，将用户的 UID 改为 0，但是用户的家目录不会改变成 root，还是原来的家目录，只是它的权限是超级用户的权限了。</p>
<p>2、用户的邮箱<br>用户邮箱目录：/var/spool/mail/用户名/。注意：/var 目录是 Linux 中可变数据的保存位置。</p>
<p>3、用户模板目录 /etc/skel/<br>注意：添加一个用户会默认修改 7 个位置的文件，分别是：/etc/passwd/、/etc/shadow/、/etc/group/、/etc/gshadow/、家目录、邮箱目录、用户模板目录。模板文件 /etc/skel 里面有隐藏文件，新添加的用户，系统会默认将里面的文件拷贝到其所在的家目录下的。所以，添加一个用户实际会默认修改 6 个位置的文件，因为模板只是从其里面拷贝用的，不会修改。</p>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="1、用户添加命令-useradd"><a href="#1、用户添加命令-useradd" class="headerlink" title="1、用户添加命令 useradd"></a>1、用户添加命令 useradd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 命令格式：</span><br><span class="line">    useradd [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -u UID        手工指定用户的 UID 号</span><br><span class="line">    -d 家目录      手工指定用户的家目录</span><br><span class="line">    -c 用户说明    手工指定用户的说明。如果输入的内容之间有空格，要加双引号</span><br><span class="line">    -g 组名        手工指定用户的初始组</span><br><span class="line">    -G 组名        指定用户的附加组。可以同时指定多个附加组，中间以逗号分隔</span><br><span class="line">    -s shell       手工指定用户的登录 Shell。默认是 /bin/shell</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 添加默认用户，注意有 6 个位置的文件会被修改外加 1 个位置的文件被复制</span><br><span class="line">    useradd test</span><br><span class="line"></span><br><span class="line">    # 指定选项添加用户</span><br><span class="line">    useradd -u 666 -d /home/test -c &quot;test add user&quot; -g test -G root,bin -s /bin/bash test</span><br></pre></td></tr></table></figure>
<p>用户默认值文件：/etc/default/useradd<br><img src="/upload_image/etc_default_useradd.png" alt="/etc/default/useradd" title="/etc/default/useradd"></p>
<p>用户默认值文件：/etc/login.defs<br><img src="/upload_image/etc_logindefs.png" alt="/etc/login.defs" title="/etc/login.defs"></p>
<p>注意：密码最小长度为 5 位的那条记录已经不生效了，因为其定义的密码强度过于简单，现在采用的是 PAM 验证生效即默认最少 8 位。</p>
<h3 id="2、修改用户密码-passwd"><a href="#2、修改用户密码-passwd" class="headerlink" title="2、修改用户密码 passwd"></a>2、修改用户密码 passwd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 命令格式：</span><br><span class="line">    passwd [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -S       查询用户密码的密码状态。仅 root 用户可用。</span><br><span class="line">    -l       暂时锁定用户。仅 root 用户可用。</span><br><span class="line">    -u       解锁用户。仅 root 用户可用。</span><br><span class="line">    --stdin  可以通过管道符输出的数据作为用户的密码 (stdin 标准输入)。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看密码状态</span><br><span class="line">    passwd -S test</span><br><span class="line">    输出结果为：  test PS 2018-04-11 0 99999 7 -1 (密码已设置，使用 SHA512 算法。)</span><br><span class="line">    解析输出结果：用户名(test) 密码状态(PS 密码已设置、LK 密码已锁定) 密码设定时间(2018-04-11)</span><br><span class="line">    密码修改间隔时间(0) 密码有效期(99999) 警告时间(7) 密码不失效(-1)</span><br><span class="line"></span><br><span class="line">    # 锁定用户</span><br><span class="line">    passwd -l test</span><br><span class="line">    # 解锁用户</span><br><span class="line">    passwd -u test</span><br><span class="line"></span><br><span class="line">    # 使用字符串作为用户的密码</span><br><span class="line">    # 注意：使用 --stdin 每个用户的密码都是使用明文的方式保存下来的，所以要提醒每个用户登录以后要修改密码</span><br><span class="line">    echo &quot;123&quot; | passwd --stdin test</span><br></pre></td></tr></table></figure>
<p>passwd 直接回车，表示给当前用户设置密码。 新建的用户如果没有设置密码是不能远程登录的，但是可以在本地无密码登录。普通用户修改密码只能使用 passwd，后面是不能加用户名的，只有超级用户可以。</p>
<h3 id="3、修改用户信息-usermod"><a href="#3、修改用户信息-usermod" class="headerlink" title="3、修改用户信息 usermod"></a>3、修改用户信息 usermod</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod 即 user modify 修改用户的意思</span><br><span class="line"></span><br><span class="line">命令格式：</span><br><span class="line">    usermod [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -u UID        修改用户的 UID 号</span><br><span class="line">    -c 用户说明    修改用户的说明信息</span><br><span class="line">    -G 组名        修改用户的附加组</span><br><span class="line">    -L            临时锁定用户（Lock）</span><br><span class="line">    -U            解锁用户锁定（Unlock）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 修改用户说明</span><br><span class="line">    usermod -c &quot;test user&quot; test</span><br><span class="line"></span><br><span class="line">    # 把 test 用户加入 root 组</span><br><span class="line">    usermod -G root test</span><br><span class="line"></span><br><span class="line">    # 锁定解锁用户</span><br><span class="line">    usermod -L test</span><br><span class="line">    usermod -U test</span><br></pre></td></tr></table></figure>
<h3 id="4、修改用户密码状态-chage"><a href="#4、修改用户密码状态-chage" class="headerlink" title="4、修改用户密码状态 chage"></a>4、修改用户密码状态 chage</h3><p>注意：是 <strong>chage</strong> 不是 cha<strong>n</strong>ge，没有 n 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    chage [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -l         列出用户的详细密码状态</span><br><span class="line">    -d 日期    修改密码最后一次更改日期（shadow 3 字段）</span><br><span class="line">    -m 天数    修改两次密码修改间隔（shadow 4 字段）</span><br><span class="line">    -M 天数    修改密码有效期（shadow 5 字段）</span><br><span class="line">    -W 天数    修改密码过期前警告天数（shadow 6 字段）</span><br><span class="line">    -I 天数    修改密码过期后宽限天数（shadow 7 字段）</span><br><span class="line">    -E 日期    修改账号失效时间（shadow 8 字段）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 该命令把密码修改日期归 0 了（shadow 3 字段），这样用户一登录就要修改密码。</span><br><span class="line">    # 即用户从来没有修改过密码，即第一次密码时间为 1971-01-01，所以你一登录系统就会要求你更改密码。即把用户的密码修改时间归零。</span><br><span class="line">    chage -d 0 test</span><br></pre></td></tr></table></figure>
<h3 id="5、删除用户-userdel"><a href="#5、删除用户-userdel" class="headerlink" title="5、删除用户 userdel"></a>5、删除用户 userdel</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    userdel [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -r 删除用户的同时删除用户家目录</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 手动删除用户</span><br><span class="line">    vim /etc/passwd</span><br><span class="line">    vim /etc/shadow</span><br><span class="line">    vim /etc/group</span><br><span class="line">    vim /etc/gshadow</span><br><span class="line">    rm -rf /var/spool/mail/lamp</span><br><span class="line">    rm -rf /home/用户名</span><br></pre></td></tr></table></figure>
<p>查看用户 ID：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure></p>
<p>切换用户身份 su:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">    su [选项] 用户名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -             选项只使用「-」代表连带用户的环境变量一起切换</span><br><span class="line">    -c 命令       仅执行一次命令，而不切换用户身份</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 切换成 root</span><br><span class="line">    # 命令 env 用来查看用户环境变量（环境变量就是这个用户当前所操作的环境）</span><br><span class="line">    # 注意：su 命令切换的时候中间的减号一定不能省略，而且减号前后都有空格</span><br><span class="line">    # 从普通用户切换超级用户或其他普通用户需要输入密码，从超级用户切换普通用户不需要输入密码</span><br><span class="line">    su - root</span><br><span class="line"></span><br><span class="line">    # 不切换成 root，但是执行 useradd 命令添加 user1 用户</span><br><span class="line">    # 没有切换用户，用 -c 选项表示暂时性的调用 root 身份去执行一条 root 用户才能执行的命令</span><br><span class="line">    su - root -c &quot;useradd user1&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><p>1、添加用户组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    groupadd [选项] 组名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -g GID   指定组 ID</span><br></pre></td></tr></table></figure></p>
<p>2、修改用户组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    groupmod [选项] 组名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -g GID       修改组 ID</span><br><span class="line">    -n 新组名    修改组名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 把组名 group1 修改为 group2</span><br><span class="line">    groupmod -n group2 group1</span><br></pre></td></tr></table></figure></p>
<p>3、删除用户组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    groupdel 组名</span><br></pre></td></tr></table></figure></p>
<p>对于组的删除：如果这个组里面是某个用户的初始组，则这个组不能删。要想删除这个组首先要删除用户。如果某个组里面没有初始用户，附加用户有没有都可以删除，里面的用户会自动被清空。</p>
<p>4、把用户添加入组或从组中删除用户<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    gpasswd [选项] 组名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 用户名   把用户加入组</span><br><span class="line">    -d 用户名   把用户从组中删除</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">    gpasswd -a 用户名 用户组</span><br><span class="line">    gpasswd -d 用户名 用户组</span><br></pre></td></tr></table></figure></p>
<p>Linux 本地无密码登录方法：将 /etc/passwd/ 文件中对应用户的密码标志位置为空，即去掉 x。然后在本地直接输入用户名就可以登录了。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(九)</title>
    <url>/2018/10/23/Linux-2018-10-23-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E4%B9%9D/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(九) —— 权限管理 </blockquote>

<a id="more"></a>
<h2 id="ACL-权限"><a href="#ACL-权限" class="headerlink" title="ACL 权限"></a>ACL 权限</h2><h3 id="ACL-权限简介与开启"><a href="#ACL-权限简介与开启" class="headerlink" title="ACL 权限简介与开启"></a>ACL 权限简介与开启</h3><p>1、ACL 权限简介<br><img src="/upload_image/acl_introductio.png" alt="ACL 权限简介" title="ACL 权限简介"></p>
<p>ACL 权限就是专门用作解决身份（u、g、o）不足的问题。它跟 Windows 中的权限很类似，<strong>即 ACL 权限不再管以前存在的身份（u、g、o），而是针对某个用户或者组，添加相应的权限。</strong></p>
<p>2、查看<strong>分区</strong> ACL 权限是否开启<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dumpe2fs 命令是查询指定分区详细文件系统信息的命令</span><br><span class="line"># -h 选项：仅显示超级块中信息，而不显示磁盘块组的详细信息</span><br><span class="line">dumpe2fs -h /dev/sda3</span><br></pre></td></tr></table></figure></p>
<p>命令：<code>df -h</code> 查看当前系统有哪些分区。df 命令是用来查看分区使用状况的，或者说占用空间容量的，但是它可以看到其对应的分区。/dev/shm 分区是一个假的分区。</p>
<p>注意：是否支持 ACL 权限，不是文件支持，也不是用户支持，而是文件所在的分区是否支持 ACL 权限。即 ACL 权限本身是用户对这个文件有没有相应的 rwx 权限，但是必须文件所在的分区支持才可以来分配。</p>
<p><img src="/upload_image/acl_look.png" alt="ACL 权限查看" title="ACL 权限查看"><br>注意查看默认挂载选项 <code>default mount options</code>，可以看到支持 acl。当前的 Linux 当中，所有的分区，默认挂载的时候都已经支持 ACL。</p>
<p>3、临时开启分区 ACL 权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重新挂载根分区，并挂载加入 ACL 权限</span><br><span class="line">mount -o remount,acl /</span><br></pre></td></tr></table></figure></p>
<p>4、永久开启分区 ACL 权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在权限位，一般是 defaults 后面加上 acl，分隔符为逗号，即「defaults,acl」</span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line"># 重新挂载文件系统或重启系统，使修改生效</span><br><span class="line">mount -o remount</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/etc_fstab_content.png" alt="/etc/fstab" title="/etc/fstab"><br>注意：defaults 表示的是分区自动挂载时候的默认选项，Linux 中默认已经支持 ACL 选项了。如果某个分区不支持，可以直接在 defaults 后面加「,acl」然后保存重启。</p>
<p><strong>ACL 权限是为了解决 u、g、o 三个身份不足的情况。ACL 权限的开启方法，了解即可，一般默认都开启了。</strong></p>
<h3 id="查看与设定-ACL-权限"><a href="#查看与设定-ACL-权限" class="headerlink" title="查看与设定 ACL 权限"></a>查看与设定 ACL 权限</h3><p>1、查看 ACL 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getfacl 文件名</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/look_acl_permission.png" alt="查看 ACL 权限" title="查看 ACL 权限"></p>
<p>注意：用户 shiting 和用户组 tgroup2 并不是 /project 目录的所有者和所属组，但它依然对该目录有相应的权限，这就是 ACL 权限。</p>
<p>2、设定 ACL 权限的命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    setfacl 选项 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -m    设定 ACL 权限</span><br><span class="line">    -x    删除指定的 ACL 权限</span><br><span class="line">    -b    删除所有的 ACL 权限</span><br><span class="line">    -d    设定默认 ACL 权限</span><br><span class="line">    -k    删除默认 ACL 权限</span><br><span class="line">    -R    递归设定 ACL 权限</span><br></pre></td></tr></table></figure></p>
<p>3、给用户设定 ACL 权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 示例命令</span><br><span class="line">mkdir /project</span><br><span class="line">useradd student1</span><br><span class="line">useradd student2</span><br><span class="line">useradd shiting</span><br><span class="line">groupadd tgroup</span><br><span class="line">gpasswd -a student1 tgroup</span><br><span class="line">gpasswd -a student2 tgroup</span><br><span class="line">chown root:tgroup /project</span><br><span class="line">chmod 770 /project</span><br><span class="line">setfacl -m u:shiting:rx /project</span><br></pre></td></tr></table></figure></p>
<p>注意：给用户 shiting 赋予 r-x 权限，使用「u:用户名:权限」的格式。注意：权限的后面多了一个「+」号，就表示设置 ACL 权限成功了。要想看具体的 ACL 权限，就要使用前面讲的 getfacl 命令。<br><img src="/upload_image/set_acl_show.png" alt="注意 + 号" title="注意 + 号"></p>
<p>4、给用户组设定 ACL 权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd tgroup2</span><br><span class="line"># 为组 tgroup2 分配 ACL 权限。使用「g:组名:权限」的格式</span><br><span class="line">setfacl -m g:tgroup2:rwx /project</span><br></pre></td></tr></table></figure></p>
<h3 id="最大有效权限与删除-ACL-权限"><a href="#最大有效权限与删除-ACL-权限" class="headerlink" title="最大有效权限与删除 ACL 权限"></a>最大有效权限与删除 ACL 权限</h3><p>1、最大有效权限 mask<br>mask 是用来指定最大有效权限的。如果我给用户赋予了 ACL 权限，是需要和 mask 的权限「相与」才能得到用户的真正权限。</p>
<p><img src="/upload_image/mask_permission.png" alt="mask 权限相与" title="mask 权限相与"></p>
<p><strong>注意：mask 不会影响所有者的权限，但是会影响 ACL 和所属组的权限。</strong></p>
<p>2、修改最大有效权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设定 mask 权限为 r-x，使用「m:权限」的格式</span><br><span class="line">setfacl -m m:rx 文件名</span><br></pre></td></tr></table></figure></p>
<p>3、删除 ACL 权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除指定用户的 ACL 权限</span><br><span class="line">setfacl -x u:用户名 文件名</span><br><span class="line"></span><br><span class="line"># 删除指定用户组的 ACL 权限</span><br><span class="line">setfacl -x g:组名 文件名</span><br><span class="line"></span><br><span class="line"># 会删除文件的所有的 ACL 权限，包括 mask</span><br><span class="line">setfacl -b 文件名</span><br></pre></td></tr></table></figure></p>
<h3 id="默认-ACL-权限和递归-ACL-权限"><a href="#默认-ACL-权限和递归-ACL-权限" class="headerlink" title="默认 ACL 权限和递归 ACL 权限"></a>默认 ACL 权限和递归 ACL 权限</h3><p>1、递归 ACL 权限<br>递归是父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意：-R 的位置不能放到 -m 那里，只能放到如下所示的位置</span><br><span class="line">setfacl -m u:用户名:权限 -R 文件名</span><br></pre></td></tr></table></figure>
<p>2、默认 ACL 权限<br>默认 ACL 权限的作用是如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 格式：setfacl -m d:u:用户名:权限 文件名</span><br><span class="line"># 加 -R 选项，表示其子目录递归拥有默认权限</span><br><span class="line">setfacl -m d:u:shiting:rx -R /project</span><br></pre></td></tr></table></figure>
<p>注意：递归权限针对的是目录下的子文件，如果赋予文件 ACL 权限，文件是不可能有子文件的，它会报错。默认权限指的是这个目录当中新出现的文件或者目录遵守 ACL 权限，如果给文件赋予 ACL 权限，它虽然不报错，但是没有作用，因为不能在文件中创建子文件。所以这两个权限都只能赋予目录。</p>
<h2 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h2><h3 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h3><p>1、SetUID 的功能<br>(1) 只有可以执行的二进制程序才能设定 SetUID 权限<br>(2) 命令执行者要对该程序拥有执行权限即 x<br>(3) 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主）<br>(4) SetUID 权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效    </p>
<p>举例：</p>
<blockquote>
<p>passwd 命令拥有 SetUID 权限，所以普通用户可以修改自己的密码。<br>cat 命令没有 SetUID 权限，所以普通用户不能查看 /etc/shadow 文件内容。</p>
</blockquote>
<p><img src="/upload_image/passwd_file.png" alt="passwd 文件属性" title="passwd 文件属性"><br>注意：上图中出现了「s」，SetUID 指的就是在该文件的所有者权限范围内拥有「s」权限；而 SetGID 指的就是在该文件的所属组权限范围内拥有「s」权限；而 Sticky BIT 指的就是在该文件的其他人权限范围内拥有「s」权限。<strong>它们都是将对应执行权限位的 x 替换为 s。</strong></p>
<p><img src="/upload_image/setuid_show.png" alt="注意 s 权限" title="注意 s 权限"></p>
<p>2、设定 SetUID 的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 4 代表 SetUID</span><br><span class="line">方法一：chmod 4755 文件名</span><br><span class="line">方法二：chmod u+s 文件名</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/setuid_example_one.png" alt="设定 SetUID" title="设定 SetUID"></p>
<p><img src="/upload_image/setuid_example_two.png" alt="大写 S 表示报错" title="大写 S 表示报错"></p>
<p>注意：出现了大写的 S，跟 chmod 4755 设定出来的小写的 s 效果不一样。大写的 S 其实是报错了，证明这个权限不能运行，因为用户必须对这个文件拥有执行权限，SetUID 才有作用，这个文件的权限原来是 644，在 644 的基础之上加了一个 s，任何人对这个文件都没有执行权限，所以系统用大写的 S 报警，提示用户这种 SetUID 值不能正确执行。</p>
<p>3、取消 SetUID 的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：chmod 755 文件名</span><br><span class="line">方法二：chmod u-s 文件名</span><br></pre></td></tr></table></figure></p>
<p>4、危险的 SetUID<br>（1）关键目录应严格控制写权限。比如「/」「/usr」等。<br>（2）用户的密码设置要严格遵守密码三原则。<br>（3）对系统中默认应该具有 SetUID 权限的文件做个列表，定时检查有没有列表之外的文件被设置了 SetUID 权限。</p>
<h3 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h3><p>1、SetGID 针对文件的作用<br>(1) 只有可执行的二进制程序才能设置 SetGID 权限<br>(2) 命令执行者要对该程序拥有执行权限即 x<br>(3) 命令执行在执行程序的时候，组身份升级为该程序文件的属组<br>(4) SetGID 权限只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</p>
<p><img src="/upload_image/locate_show.png" alt="SetGID 作用效果" title="SetGID 作用效果"><br>举例：<br>locate 文件搜索命令，它跟 find 命令相比，之所以执行速度更快，是因为 locate 命令搜索的是 /var/lib/mlocate/mlocate.db 这个数据库，该数据库中会记录当前系统中所有文件的文件名。会发现该数据的权限是 -rw-r—–，如果普通用户去搜索这个数据库文件按理应该是没有权限的，但是 locate 命令有 SetGID 权限。即普通用户虽然对数据库文件没有权限，但是普通用户是通过 locate 命令去搜索数据库文件的，而 locate 命令是拥有 SetGID 权限的，当任意一个普通用户执行 locate 命令的时候，其身份组就会切换为 locate 命令的组即 slocate，而数据库文件的所属组就是 slocate，并且所属组拥有读权限，所以普通用户利用 locate 命令的 SetGID 权限就可以读取数据库文件了。</p>
<p>2、SetGID 针对目录的作用<br>(1) 普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录<br>(2) 普通用户在此目录中的有效组会变成此目录的属组<br>(3) 若普通用户对此目录拥有 w 权限时，新建的文件的默认属组是这个目录的属组</p>
<p><strong>注意：只有 SetGID 可以既针对二进制文件，也可以针对目录。</strong></p>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># root 用户执行命令</span><br><span class="line">mkdir /tmp/dtest</span><br><span class="line">chmod 2777 /tmp/dtest</span><br><span class="line"># 切换为普通用户</span><br><span class="line">su - youcai</span><br><span class="line">cd /tmp/dtest/</span><br><span class="line"># 注意：在 /tmp/dtest 目录下新建文件的所属组是 root，即 dtest 目录的所属组，不再是当前用户的缺省组了</span><br><span class="line">touch /tmp/dtest/ftest</span><br></pre></td></tr></table></figure></p>
<p>注意：对目录设置 SetGID 实际操作意义不大，了解即可。</p>
<p>3、设定 SetGID<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 代表 SetGID</span><br><span class="line">方法一：chmod 2755 文件名</span><br><span class="line">方法二：chmod g+s 文件名</span><br></pre></td></tr></table></figure></p>
<p>4、取消 SetGID<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：chmod 755 文件名</span><br><span class="line">方法二：chmod g-s 文件名</span><br></pre></td></tr></table></figure></p>
<p>系统利用了 SetUID 和 SetGID 这些权限来完成一些必须给普通用户分配权限的工作。</p>
<h3 id="Sticky-BIT"><a href="#Sticky-BIT" class="headerlink" title="Sticky BIT"></a>Sticky BIT</h3><p>1、Sticky BIT 粘着位作用<br>(1) 粘着位目前只对目录有效。<br>(2) 普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限。<br>(3) 如果没有粘着位，因为普通用户拥有 w 权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了 root 可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</p>
<p>举例：<br><img src="/upload_image/stichy_bit_example.png" alt="/tmp/ 目录属性" title="/tmp/ 目录属性"><br>注意：/tmp/ 目录的其他人权限位中的「t」表示粘着位权限。</p>
<p>2、设置粘着位<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：chmod 1755 目录名</span><br><span class="line">方法二：chmod o+t 目录名</span><br></pre></td></tr></table></figure></p>
<p>3、取消粘着位<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：chmod 755 目录名</span><br><span class="line">方法二：chmod o-t 目录名</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：Stichy BIT 针对的是删除的限制，对读和修改没有限制。注意：特殊权限位虽然可以给 7，但是一般不这样做，因为操作的对象不同，有的是目录，有的是文件，所以不可能同时生效，所以这样做是没有意义的。注意：要定时检查系统中赋予 SetUID 和 SetGID 的权限的文件，如果有，要确认是否是多出来的，否则会造成非常大的隐患。</strong></p>
<p>小结：SetUID 只能针对二进制文件，用 4 表示，权限为字母为 s。SetGID 既可以针对二进制文件，也可以针对目录，用 2 表示，权限为字母为 s。Stichy BIT 只能针对目录，用 1 表示，权限为字母为 t。</p>
<h2 id="文件系统属性-chattr-权限"><a href="#文件系统属性-chattr-权限" class="headerlink" title="文件系统属性 chattr 权限"></a>文件系统属性 chattr 权限</h2><p>1、chattr 命令格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">    change file attributes on a Linux file system（ch「change」 attr「attributes」)</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    # + 增加权限；- 删除权限；= 等于某权限</span><br><span class="line">    chattr [+-=] [选项] 文件或目录名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    i    如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置 i 属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。</span><br><span class="line">    a    如果对文件设置 a 属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除。</span><br></pre></td></tr></table></figure></p>
<p>注意：i 属性赋予文件，表示该文件是只读的。<strong>chattr 针对 root 用户也生效。要想恢复，则先去掉 i 属性。这也是 chattr 的好处，保护数据内容，而且对 root 用户也有效</strong>。 其实 a 是 append 追加的意思。如果对文件设置了 a 属性，则不能使用 vim 的方式对文件修改，只能使用 echo [内容]  &gt;&gt; [文件]的追加方式进行数据的写入。</p>
<p>2、查看文件系统属性<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    lsattr 选项 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 显示所有文件和目录</span><br><span class="line">    -d 若目标是目录，仅列出目录本身的属性，而不是子文件的</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/lsattr_show.png" alt><br>e 属性：代表这个文件是在 ext 文件系统中创建的，e 属性是 ext 文件系统默认的，而且也不能取消。</p>
<h2 id="系统命令-sudo-权限"><a href="#系统命令-sudo-权限" class="headerlink" title="系统命令 sudo 权限"></a>系统命令 sudo 权限</h2><p>1、sudo 权限</p>
<blockquote>
<p>root 把本来只能超级用户执行的命令赋予普通用户执行。<br>sudo 的操作对象是系统命令。</p>
</blockquote>
<p>2、sudo 使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通过编辑 /etc/sudoers 文件来给普通用户授权</span><br><span class="line"># visudo 命令实际修改的是 /etc/sudoers 文件</span><br><span class="line">visudo 等价于 vim /etc/sudoers</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/authorization_format.png" alt="授权格式" title="授权格式"></p>
<p>注意：上图中的授权格式中有三个 ALL，这三个 ALL 分别代表的是：</p>
<blockquote>
<p>第一个 ALL：它定义的并不是允许哪一个 IP 地址或网络访问我这台本机，而是定义的是允许哪一个用户执行某一条命令在<strong>哪一台计算机上</strong>。即它定义的是执行命令的计算机的 IP 地址或网段。<br>第二个 ALL：表示我可以使用什么身份。可以不写，默认为 ALL，表示把用户当成什么身份来对待。<br>第三个 ALL：代表任意命令。</p>
</blockquote>
<p>3、示例：授权 test 用户可以重启服务器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br><span class="line"># 添加如下内容，注意命令要写绝对路径，可以通过 whereis 查找命令绝对路径</span><br><span class="line">test ALL = /sbin/shutdown -r now</span><br></pre></td></tr></table></figure></p>
<p>4、示例：普通用户执行 sudo 赋予的命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看可用的 sudo 命令</span><br><span class="line">sudo -l</span><br><span class="line"></span><br><span class="line"># 普通用户执行 sudo 赋予的命令</span><br><span class="line">sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：普通用户是可以使用 vim 的，但是普通用户自己用 vim 的时候是局限在自己的权限范围之内的。如果用 sudo 的方式把 root 用户的 vim 赋给普通用户，那么普通用户在执行 vim 命令的时候他的身份会自动切换成为 root，这是极其危险的。</strong></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十一)</title>
    <url>/2018/10/25/Linux-2018-10-25-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十一) —— Shell 基础 </blockquote>

<a id="more"></a>
<h2 id="Shell-概述"><a href="#Shell-概述" class="headerlink" title="Shell 概述"></a>Shell 概述</h2><p>1、Shell 是什么？<br>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统程序，用户可以用 Shell 来启动、挂起、停止甚至编写一些程序。</p>
<p>Shell 还是一个功能相当强大的编程语言。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。</p>
<p>2、Shell 的分类<br>Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh。</p>
<p>C Shell：C Shell 主要在 BSD (Berkeley Software Distribution，是一个操作系统的名称，衍生自 Unix，被称为伯克利 Unix) 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。</p>
<p>Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh、ksh、Bash、psh、zhs；C 家族主要包括：csh、tcsh。</p>
<p>Bash (Bourne Again Shell): Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。</p>
<p>3、Linux 支持的 Shell<br>在 「/etc/shells」文件中保存着当前系统支持的 Shell。注意：只要是系统支持的 Shell，我们就可以通过输入对应的 Shell 名字来进行切换。</p>
<p>4、echo 输出命令<br>echo 是反射、回声的意思。是用来输出的命令。格式：<code>echo [选项][输出内容]</code>；选项：<code>-e</code>，支持反斜杠控制的字符转换。<br>eg：<code>echo &#39;Hello World!&#39;</code>  注意：感叹号在 Shell 中有特殊的作用，所以这里使用单引号。</p>
<p>5、Linux 中常见的转义符<br><img src="/upload_image/Escape_Character.png" alt="Linux 中常见的转义符" title="Linux 中常见的转义符"></p>
<p>eg：<code>echo -e &quot;ab\bc&quot;</code> 删除左侧字符；输出结果：<code>ac</code>；分析：<code>\b</code> 代表的是退格键。<br>eg：<code>echo -e &quot;a\tb\tc\nd\te\tf&quot;</code> 制表符与换行符。<br>eg: <code>echo -e &quot;\e[1;31m abcd \e[0m&quot;</code> 带颜色输出内容；输出结果：<code>红色的 abcd</code>；分析：31m=红色；「\e[1;」表示开启颜色输出，「\e[0m」    表示结束颜色输出。</p>
<p>6、第一个 Shell 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/Bash</span><br><span class="line"><span class="meta">#</span>The first program</span><br><span class="line"><span class="meta">#</span>Author: YanChongsheng E-mail: yanchongsheng@gmail.com</span><br><span class="line">echo -e "YanChongsheng is the most handsome man in China."</span><br></pre></td></tr></table></figure>
<p>注意：「#!/bin/Bash」这句话不是注释，而是标称，标称以下内容是 Shell 脚本。在 Linux 中以 # 号开头的是注释。</p>
<p>7、脚本执行</p>
<ul>
<li>方式一：赋予执行权限，直接运行 <code>赋予权限：chmod 755 hello.sh 运行脚本：./hello.sh</code></li>
<li>方式二：通过 Bash 调用执行脚本：<code>bash hello.sh</code></li>
</ul>
<p>注意：使用 base 执行脚本的时候，脚本甚至可以没有执行权限。它的意思是通过这个 Shell 来解释这个 shell 脚本文件，所以只要里面的内容是正确的，连执行权限都可以不用给就可以执行，但是最习惯的执行方法还是第一种。</p>
<p>cat 命令给其加上选项 -A ：表示查看所有的文件内容，包括隐藏字符，例如回车符就属于文件中的隐藏字符。在 Linux 中，回车符识别为「$」号。但是 Windows 中的回车符是「^M$」，表示这个 shell 是在 windows 中编辑完成的，要想在 Linux 中执行，就需要进行转换，利用命令: dos2unix [文件名]。注意：如果 dos2unix 命令没有则需要安装：<code>yum -y install dos2unix</code>。</p>
<h2 id="Bash-的基本功能"><a href="#Bash-的基本功能" class="headerlink" title="Bash 的基本功能"></a>Bash 的基本功能</h2><p>1、历史命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：histor [选项][历史命令保存文件]</span><br><span class="line">选项：</span><br><span class="line">    -c  清空历史命令</span><br><span class="line">    -w  把缓存中的历史命令写入历史命令保存文件「~./bash_histor」</span><br></pre></td></tr></table></figure></p>
<p>注意：每次登陆之后所敲的命令都会放在 history 即内存中，并不会放入 ~/.bash_history 文件，而是等正常退出以后，才会将内存中的历史命令写入到 ~/.bash_history 文件中的。注意：-c 会清除内存中和文件中的所有的历史命令。</p>
<p>历史命令默认会保存 1000 条，可以在环境变量配置文件「/etc/profile」中进行修改 <code>HISTSIZE=1000</code> 注意：重新登录以后才会生效。如果超过 1000，则删除第 1 条命令，保存第 1001 条命令。</p>
<p>历史命令的调用：</p>
<ol>
<li>使用上、下箭头调用以前的历史命令</li>
<li>使用「!n」调用第 n 条历史命令</li>
<li>使用「!!」执行上一条命令</li>
<li>使用「!字符」执行最后一条以该字符串开头的命令</li>
</ol>
<p>2、命令别名：<br>设定命令别名：alias 别名=’原命令’。注意：用命令行方式定义的别名它只会临时生效，一旦系统重启，这个别名就会消失。<br>查询命令别名：alias 别名</p>
<p>3、命令执行顺序</p>
<ol>
<li>第一顺位：执行用绝对路径或相对路径执行的命令。</li>
<li>第二顺位：执行别名。</li>
<li>第三顺位：执行 Bash 的内部命令。</li>
<li>第四顺位：执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令。</li>
</ol>
<p>输出环境变量：<code>echo $PATH</code></p>
<p>让别名永久生效：<code>vim /root/.bashrc</code> 注意：修改的是用户对应家目录下的「./bashrc」文件。rc 可以简单的理解为 user config 的简写，取 user 的最后一个字母 r 和 config 的第一个字母 c 组成 rc。</p>
<p>删除别名：<code>unalias 别名</code></p>
<p>4、Bash 常用快捷键<br><img src="/upload_image/Bash_Shortcut_Key.png" alt="Bash 常用快捷键" title="Bash 常用快捷键"></p>
<p>5、标准输入输出</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
<p>6、输出重定向<br><img src="/upload_image/Output_redirect.png" alt="输出重定向" title="输出重定向"></p>
<p>注意：不是所有的命令都可以使用输出重定向的，这个命令必须得有输出才可以。<br>注意：错误输出中，2 和 大于号之间不能有空格。</p>
<p><img src="/upload_image/Output_All.png" alt="正确输出和错误输出同时保存" title="正确输出和错误输出同时保存"></p>
<p>注意：「/dev/null」是 Linux 中的一个特殊文件，可以把它当成垃圾箱，相当于不保存任何输出。</p>
<p>7、输入重定向「注意：输入重定向了解即可」<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：wc [选项][文件名]</span><br><span class="line">选项：</span><br><span class="line">    -c  统计字节数 (byte) print the byte counts</span><br><span class="line">    -m  统计字符数 (character) print the character counts</span><br><span class="line">    -w  统计单词数 (word)</span><br><span class="line">    -l  统计行数 (line)</span><br></pre></td></tr></table></figure></p>
<p>注意：wc 可以统计键盘输入，输入的行数、单词数、字节数，输入完成之后按 ctrl + d，结束并进行统计。注意回车换行符也会被当成字节进行统计。</p>
<p>把文件作为命令的输入：<code>命令&lt;文件</code>。eg：<code>wc &lt; anaconda-ks.cfg</code></p>
<p>8、多命令顺序执行<br><img src="/upload_image/Execute_Many_Command.png" alt="多命令顺序执行" title="多命令顺序执行"></p>
<p>eg：<code>ls; date; cd /user; pwd</code><br>eg: <code>命令 &amp;&amp; echo yes || echo no</code></p>
<p><img src="/upload_image/Example_Many_Command.png" alt="例子" title="例子"><br>命令 dd 是磁盘或者说是数据复制的命令，但是它不是 cp，cp 命令只能复制文件，但是 dd 命令能复制特殊文件，也能复制分区甚至整个硬盘，不仅复制分区或硬盘的数据，还复制分区或硬盘的文件系统。dd 主要是用来进行磁盘复制。</p>
<p>9、管道符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：命令1 | 命令2</span><br></pre></td></tr></table></figure></p>
<p><code>命令1</code> 的<code>正确输出</code>作为<code>命令2</code> 的<code>操作对象</code>。</p>
<p>注意：命令1 必须正确输出，否则命令2 不会正常执行。</p>
<p>10、grep 命令，在文件中搜索符合条件的字符串<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：grep [选项] &quot;搜索内容&quot;</span><br><span class="line">选项：</span><br><span class="line">    -i  忽略大小写</span><br><span class="line">    -n  输出行号</span><br><span class="line">    -v  反向查找 (注意：-v 查找的是不匹配的行，即反向查找)</span><br><span class="line">    --color=auto  搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure></p>
<p>通配符<br><img src="/upload_image/Wildcard.png" alt="通配符" title="通配符"></p>
<p>Bash 中的特殊符号<br><img src="/upload_image/Special_Character.png" alt="Bash 中的特殊符号" title="Bash 中的特殊符号"></p>
<p>注意：通配符是用来匹配文件名的，起码在 Linux 系统当中是用来匹配文件名的。</p>
<p>$ 和 $() 的区别是：$ 是用于调用变量的值；而 $() 是用来引用系统命令。</p>
<h2 id="Bash-的变量"><a href="#Bash-的变量" class="headerlink" title="Bash 的变量"></a>Bash 的变量</h2><p>1、变量设置规则  </p>
<ol>
<li><p>变量名称可以由字母、数字、下划线组成，但是不能以数字开头。</p>
</li>
<li><p>在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</p>
</li>
<li><p>变量用等号连接值，<strong>等号左右两侧不能有空格</strong>。</p>
</li>
<li><p>变量的值如果有空格，需要使用单引号或双引号包括。</p>
</li>
<li><p>在变量的值中，可以使用「\」转义符。</p>
</li>
<li><p>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名” 或用 ${变量名} 包含。</p>
</li>
<li><p>如果是把命令的结果作为变量值赋值给变量，则需要使用反引号或 $() 包含<strong>命令</strong>。</p>
</li>
<li><p>环境变量名建议大写，便于区分。</p>
</li>
</ol>
<p>环境变量名大写，目的是为了区分。因为环境变量会让 Linux 当中所有的 Shell 都能使用，Linux 的系统命令也是在所有的 Shell 中都能使用，但是系统命令都是小写，为了让系统命令和环境变量区分开，建议把环境变量都写成大写。</p>
<p>2、变量分类</p>
<ol>
<li>用户自定义变量</li>
<li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</li>
<li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li>
<li>预定义变量：是 Bash 中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li>
</ol>
<p>其实位置参数变量是预定义变量的一种，由于位置参数变量相对来说较多，所以我们习惯上将位置参数变量单独作为一个分类。所以这两种变量的限制是一样的，只能更改值。</p>
<p>3、本地变量<br>用户自定义变量又称为本地变量。「$变量名」的作用是调用变量。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义变量</span><br><span class="line">aa=123</span><br><span class="line"></span><br><span class="line"># 变量叠加</span><br><span class="line">aa=&quot;$aa&quot;456 # 结果：123456</span><br><span class="line">aa=$&#123;aa&#125;789 # 结果：123456789</span><br><span class="line"></span><br><span class="line"># 变量调用</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line"># 变量查看</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 变量删除</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure></p>
<p>set 命令：表示查看系统的所有变量，包括系统的环境变量，以及系统变量，自定义的变量。<br>总结：变量的定义、叠加、调用、查看、删除；变量的概念、变量的规则、变量的分类。</p>
<p>4、环境变量是什么？<br>用户自定义变量只在当前 Shell 中生效。（使用命令行定义的）环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 Shell 中生效。</p>
<p>5、设置环境变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 声明变量</span><br><span class="line">export 变量名=变量值</span><br><span class="line"></span><br><span class="line"># 查询变量</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"># 删除变量</span><br><span class="line">unset 变量名</span><br><span class="line"></span><br><span class="line"># 将已经定义好的本地变量变为环境变量</span><br><span class="line">export 变量名</span><br></pre></td></tr></table></figure></p>
<p>注意：系统当前本身就是在一个 Shell 里面，我们可以直接输入 csh、或 bash 表示进入对应的 Shell，而系统本身的 shell 就是 csh 或者 bash 的父 Shell，这样就创建了一个子 Shell，当然子 Shell 里面还可以有子子 Shell。</p>
<p>如何查询和确定 Shell 呢？<br>使用命令 <code>pstree</code>，它的作用是确定进程数。</p>
<p>6、系统常见环境变量<br>PATH：系统查找命令的路径。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输出 PATH</span><br><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line"># PATH 变量叠加</span><br><span class="line">PATH=&quot;$PATH&quot;:/root/sh</span><br></pre></td></tr></table></figure></p>
<p>PS1：定义系统提示符的变量</p>
<p><img src="/upload_image/PS1_Character.png" alt="定义系统提示符" title="定义系统提示符"></p>
<p>eg：<code>PS1=[\u@\h \W]\$</code>。注意习惯在 $ 最后加一个空格，要不然你的命令会紧挨着提示符 # 或者 $。这种写法只是临时生效。</p>
<p>注意：env 是专门用来查看当前系统的环境变量的。严格来说 PS1 并不是环境变量，因为 env 命令查看不到，必须使用 set 命令查看。虽然它不是环境变量，但是它是系统预留专门用作定义系统操作环境的一个变量。它是环境变量的一个子分支。</p>
<p><strong>注意：Linux 以冒号为分割符号。</strong></p>
<p>7、位置参数</p>
<p><img src="/upload_image/Location_Param.png" alt="位置参数" title="位置参数"></p>
<p>位置参数变量最大的作用就是向程序中传递需要的值。它的好处是可以在命令执行的同时接受参数。</p>
<p>注意：位置参数变量的名称和作用都是固定的。我们能做的只是在里面传入不同的值。</p>
<p>注意：要想进行数值运算，必须加 $(()) 双小括号括起来，它才能进行数值计算，这是 Linux Shell 的标准格式。</p>
<p>注意：$# 不会计算命令本身，它计算的仅仅只是参数。</p>
<p><code>$*</code> 和 $@ 的区别：<code>$*</code> 中的所有参数看成是一个整体。$@ 中的每个参数看成是独立的。</p>
<p>8、预定义变量<br><img src="/upload_image/Predefined_Variable.png" alt="预定义变量" title="预定义变量"></p>
<p>其实位置参数变量就是预定义变量当中的一个分类，其特点是不能改变变量名，变量的作用也是固定的。</p>
<p>$? 用来接收和判断上一条命令是否正确执行。注意：&amp;&amp; || 利用的就是 $? 来判断上一条命令是否正确执行的。</p>
<p>9、接受键盘输入，read 会把键盘输入的数据赋值给后面的变量中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">    -p &quot;提示信息&quot;：在等待 read 输入时，输出提示信息</span><br><span class="line">    -t 秒数：read 命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">    -n 字符数：read 命令只接受指定的字符数，就会执行</span><br><span class="line">    -s：隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure></p>
<p>注意：如果不加 -n 选项，read 命令在回车以后才会结束，如果加了 -n 选项，则字符数达到 -n 执行的数字，则自动结束 read 并执行。</p>
<h2 id="Bash-的运算符"><a href="#Bash-的运算符" class="headerlink" title="Bash 的运算符"></a>Bash 的运算符</h2><p>注意：Linux 的 Shell 中变量的类型默认都是字符串型。</p>
<p>1、declare 声明变量类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">    -：给变量设定类型属性</span><br><span class="line">    +：取消变量的类型属性</span><br><span class="line"></span><br><span class="line">    -i：将变量声明为整型（integer）</span><br><span class="line">    -x：将变量声明为环境变量</span><br><span class="line">    -p：显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure></p>
<p>2、数值运算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line"></span><br><span class="line"># 方法1</span><br><span class="line">declare -i cc=$aa+$bb</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line"># 利用 expr 或 let 数值运算工具。注意：「+」号左右两侧必须有空格。</span><br><span class="line">cc=$(expr $aa + $bb)</span><br><span class="line"></span><br><span class="line"># 方法3</span><br><span class="line"># $((运算式)) 或 $[运算式]</span><br><span class="line">cc=$(($aa+$bb))</span><br><span class="line">cc=$[$aa+$bb]</span><br></pre></td></tr></table></figure></p>
<p>3、运算符<br><img src="/upload_image/Linux_Operator.png" alt="运算符" title="运算符"></p>
<p>注意：此处数字越大，优先级越高。</p>
<p>4、变量测试与内容替换<br><img src="/upload_image/Variable_Alternative_Test.png" alt="变量测试与内容替换" title="变量测试与内容替换"></p>
<p>主要作用：通过 x 的值来确定 y 的情况。这块内容了解即可，完全可以 if 语句来替代，只是系统提供的更简洁、高效一点，用到的时候查一下能看懂就行，不要可以去记忆。</p>
<h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><p>1、source 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：source 配置文件</span><br><span class="line">或</span><br><span class="line">格式：. 配置文件</span><br></pre></td></tr></table></figure></p>
<p>注意：source 命令的作用是让你的配置文件生效，即让系统重新读取一遍配置文件。（正常情况下配置文件生效需要重新登录一次，但是利用 source 命令可以直让配置文件生效）。<br>注意：点「.」和配置文件之间有空格，点「.」其实就是 source 的缩写。</p>
<p>2、环境变量配置文件简介<br>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如 PATH、HISTSIZE、PS1、HOSTNAME 等默认环境变量。</p>
<p>系统中主要的 5 类环境变量配置文件：</p>
<ol>
<li>/etc/profile 的作用：USER 变量、LOGNAME 变量、MAIL 变量、PATH 变量、HOSTNAME 变量、HISTSIZE 变量、umask、调用 /etc/profile.d/*.sh 文件。</li>
<li>~/.bash_profile 的作用：调用了 ~/.bashrc 文件、在 PATH 变量后面加入了 「:$HOME/bin」这个目录。</li>
<li>~/.bashrc 的作用：定义默认别名、调用 /etc/bashrc。</li>
<li>/etc/bashrc 的作用：PS1 变量、umask、PATH 变量、调用 /etc/profile.d/*.sh 文件。</li>
<li>/etc/profile.d/*.sh</li>
</ol>
<p>注意：只要是保存在 /etc 目录中的，表示对所有登录到该 Linux 系统的用户都生效。~/ 表示当前用户的家目录，「.」表示该文件是隐藏文件，这些配置文件针对的是当前用户。「~」表示家目录的意思。</p>
<p>3、环境变量配置文件作用</p>
<p><img src="/upload_image/Profile_Invoke_Order.png" alt="环境变量配置文件调用顺序" title="环境变量配置文件调用顺序"></p>
<p>注意：环境变量默认赋值的时候分两种情况<br>1.一种是用户通过输入用户名和密码的正常登陆。<br>2.一种是用户通过命令切换到子 Shell 的登陆，这种情况是没有输入用户名密码过程的。<br>这两种不同的登陆方法，它读取的配置文件是不一样的。</p>
<p>注意：环境变量配置文件它们之间是有优先级的。越后面读取的配置文件，其优先级越高，因为后面定义的变量会覆盖前面的变量。</p>
<p>需要输入用户名密码的正常登录情况配置文件的读取顺序：<br>/etc/profile「 ——&gt; …… ——&gt; /etc/sysconfig/i18n (新版的 Linux 为 /etc/locale.conf) 这些都是 /etc/profile 文件中调用的子文件或子子文件」当完成 /etc/profile 的所有调用以后 /etc/profile 就会将它的调用传递给下一个环境变量配置文件即 ~./bash_profile，然后照着上图依次往下传递。</p>
<p>发现 /etc/profile 和 /etc/bashrc 中有很多内容是重复的，如 PATH、umask、PS1，注意这个不是单单只是重复。你会发现 /etc/bashrc 中重复定义变量的地方有这样的注释「We’re not a login shell」即该文件定义的是没有登录情况的 Shell 的环境变量。</p>
<p>4、注销时生效的环境变量配置文件<br>~/.bash_logout 默认为空，可以在里面写一些退出登录时候的操作，比如清空历史命令等操作。</p>
<p>5、其他配置文件<br>~/.bash_history 历史命令保存的地方。一般不要清空，但是有一种情况例外，比如你给某个服务设置密码，如 mysql，mysql 设置密码的时候使用的是明文（注意：是明文）系统命令，它会把密码记录在历史文件中，所以要清空明文密码记录。</p>
<p>6、Shell 登录信息<br>1.<strong>本地</strong>终端欢迎信息：/etc/issue<br><img src="/upload_image/Local_Terminal_Character.png" alt="本地终端转义符" title="本地终端转义符"></p>
<p>注意：欢迎信息不要写 welcome 之类的，应该写的是警告信息。注意：针对的是本地登录。</p>
<p>2.<strong>远程</strong> 终端欢迎信息：/etc/issue.net<br>注意：转义符在 /etc/issue.net 文件中不能使用，即本地终端的转义符在这里都不能使用，这里只能写纯文本信息。是否显示此欢迎信息由 ssh 的配置文件 /etc/ssh/sshd_config 决定，加入「Banner /etc/issue.net」行才能显示。（记得重启 ssh 服务）。重启 ssh 服务：<code>service sshd restart</code></p>
<p>3.<strong>本地和远程</strong>登录后欢迎信息：/etc/motd<br>不管是本地登录，还是远程登录，都可以显示此欢迎信息。但是，它是登录后的欢迎信息。刚才那两个文件是登录前的提示信息。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十)</title>
    <url>/2018/10/24/Linux-2018-10-24-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十) —— 文件系统管理 </blockquote>

<a id="more"></a>
<h2 id="分区和文件系统"><a href="#分区和文件系统" class="headerlink" title="分区和文件系统"></a>分区和文件系统</h2><p>1、分区类型<br><img src="/upload_image/disk_prartition.png" alt="分区类型" title="分区类型"></p>
<p>2、分区表示方法<br><img src="/upload_image/prartition_show.png" alt="分区表示方法" title="分区表示方法"></p>
<p>3、分区的设备文件名<br><img src="/upload_image/prartition_device_name.png" alt="分区的设备文件名" title="分区的设备文件名"><br>其中，sd 表示硬盘的接口类型，a 代表第一块硬盘，1、2、3、4 代表 4 个主分区。注意：分区的设备文件名是固定的，我们只需要记下来，能看懂就行。注意：逻辑分区最少从 5 开始，1、2、3、4 这 4 个数字是留给主分区或扩展分区用的。</p>
<p>4、文件系统<br>了解文件系统 ext、ext1、ext2、ext3、ext4。</p>
<p><strong>小结：分区的表示方式，采用 /dev 下的 sd 代表 SATA 硬盘接口，hd 代表 IDE 硬盘的接口，a、b、c、d 代表第几块硬盘，1、2、3、4 代表主分区或扩展分区，5、6、7、8、… 代表逻辑分区。</strong></p>
<h2 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h2><p>1、文件系统查看命令 df<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：</span><br><span class="line">    df - report file system disk space usage</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    df [选项] [挂载点]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a  显示所有的文件系统信息，包括特殊文件系统，如 /proc、/sysfs</span><br><span class="line">    -h  使用习惯单位显示容量，如 KB、MB、GB 等</span><br><span class="line">    -T  显示文件系统类型</span><br><span class="line">    -m  以 MB 为单位显示容量</span><br><span class="line">    -k  以 KB 为单位显示容量。默认就是以 KB 为单位</span><br></pre></td></tr></table></figure></p>
<p>2、统计目录或文件大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：</span><br><span class="line">    du - estimate(估计) file space usage</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">    du [选项] [目录或文件]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</span><br><span class="line">    -h 使用习惯单位显示磁盘占用量，如 KB、MB、GB 等</span><br><span class="line">    -s 统计总占用量，而不列出子目录和子文件的占用量</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 统计 /etc/ 目录大小</span><br><span class="line">    du /etc/</span><br><span class="line">    输出结果：它会列出该目录下所有子目录各占用了多大空间，最后统计这个目录的总大小</span><br></pre></td></tr></table></figure></p>
<p>注意：du 命令是用来统计目录或文件大小的，但是一般不用它来统计文件大小，因为通过「ls -l」命令就可以很清楚的看到文件的大小。<strong>但是 ls 命令在统计目录大小的时候，它只会统计该目录下一级子目录和子文件的文件名占用了多大空间，并不会统计该目录下子目录当中的数据或者文件当中的数据占用了多大空间。</strong> 所以你会看到 ls 命令在显示目录的大小的时候一般就只有几 KB，这也是 ls 命令的局限性所在。要想统计目录的大小就必须使用 du 命令。</p>
<p>3、du 命令和 df 命令的区别</p>
<blockquote>
<p>df 命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。</p>
</blockquote>
<blockquote>
<p>du 命令是面向文件的，只会计算文件后目录占用的空降。</p>
</blockquote>
<p>Linux 系统要定期重启，来释放被进程或者已经删除的文件所占用的硬盘空间。要以 df 命令看到的剩余空间才是真正可以使用的空间。</p>
<p>4、文件系统修复命令 fsck<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    fsck [选项] 分区设备文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a 不用显示用户提示，自动修复文件系统</span><br><span class="line">    -y 自动修复。和 -a 作用一致，不过有些文件系统只支持 -y</span><br></pre></td></tr></table></figure></p>
<p>系统会自动执行该命令进行修复检测，一般不用该命令，除非真的需要。没事别用，否则有可能会造成系统崩溃。该命令了解即可。</p>
<p>5、显示磁盘状态命令 dumpe2fs<br><strong>注意：该命令只针对 ext 文件系统有效。</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    dumpe2fs 分区设备文件名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    dumpe2fs /dev/sda3 | more</span><br></pre></td></tr></table></figure></p>
<p>「| more」 分屏显示，即将很多内容，分成多段来显示。主要是用来查看超级块的信息的，可以看到分区中一个数据块的大小。注意：每个数据块中(常见的为 4kb)，只能保存一个文件中的数据。</p>
<p>在 Centos7 系统下使用 dumpe2fs 查看文件系统查不到对应的超级块，原因是 Centos7 默认安装的文件系统是 XFS 类型而不是 ext2/ext3/ext4。对于 XFS，使用 dumpe2fs 命令是找不到对应的超级块，可以使用 xfs_info 来查看分区信息。<a href="https://wenku.baidu.com/view/3d882d2c0812a21614791711cc7931b765ce7baf.html?re=view" target="_blank" rel="noopener">CentOS 7 查看磁盘状态</a></p>
<p>小结：du 只统计文件大小，df 不光统计文件大小，还要统计被系统占用的空间。所以用 du 看文件大小更准确，用 df 看剩余空间更准确。</p>
<p>6、查询与自动挂载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询系统中已经挂载的设备，-l 会显示卷标名称</span><br><span class="line">mount [-l]</span><br><span class="line"></span><br><span class="line"># 依据配置文件 /etc/fstab 的内容，自动挂载</span><br><span class="line"># 按照配置文件的需求，把所有的分区重新挂载一遍，a 即 all</span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure></p>
<p>mount 是用来进行设备挂载的命令，Linux 中所有的可存储设备：包括硬盘、光盘、u盘、软盘、移动硬盘等，都必须挂载之后才能使用，只是硬盘的挂载是系统自动进行的，其他的就需要手工挂载了。</p>
<p>挂载：Linux 中每一个硬件都有一个设备文件名，也会有一个挂载点（空目录），挂载就是把设备文件名和挂载点联系起来。<strong>只有通过访问挂载点，来访问这个设备，即设备是不能直接访问的，得需要通过挂载点才能访问。</strong></p>
<p>7、挂载命令格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    mount [选项] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -t 文件系统        加入文件系统类型来指定挂载的类型，如 ext3、ext4、iso9660 等文件系统</span><br><span class="line">    -L 卷标名          挂载指定卷标的分区，而不是安装设备文件名挂载。卷标：就相当于给你的分区起一个别名，意义不大，不写也无所谓</span><br><span class="line">    -o 特殊选项        可以指定挂载的额外选项</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 重新挂载 /home 分区，并使用 noexec 权限</span><br><span class="line">    mount -o remount,noexec /home</span><br><span class="line">    # 测试，发现不能执行了</span><br><span class="line">    cd /home &amp;&amp; vim hello.sh &amp;&amp; chmod 755 hello.sh &amp;&amp; ./hello.sh</span><br><span class="line">    # 最后记得改回去，要不会影响系统启动的</span><br><span class="line">    mount -o remount,exec /home</span><br></pre></td></tr></table></figure></p>
<p>以下为 -o 的特殊选项：<br><img src="/upload_image/mount_o_option.png" alt="-o 的特殊选项" title="-o 的特殊选项"></p>
<p>注意：mount -o 的这些选项参数，针对的都是分区。-o 后面可以同时跟多个选项，选项之间以逗号分隔。</p>
<p>7、挂载示例<br>（1）挂载光盘<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 建立挂载点</span><br><span class="line">mkdir /mnt/cdrom/</span><br><span class="line"></span><br><span class="line"># 挂载光盘</span><br><span class="line">mount -t iso9660 /dev/cdrom/ /mnt/cdrom/</span><br><span class="line">或</span><br><span class="line">mount /dev/sr0 /mnt/cdrom/</span><br></pre></td></tr></table></figure></p>
<p>只要是<strong>空目录</strong>都可以作为挂载点。注意光盘是只读的。</p>
<p>（2）卸载命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    umount 设备文件名或挂载点</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    umount /mnt/cdrom</span><br></pre></td></tr></table></figure></p>
<p>用完光盘之后，必须手动卸载，否则光驱不会弹出来。注意：不要在光盘目录下卸载，否则会报设备正忙的错。</p>
<p>（3）挂载 U 盘<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看 U 盘设备文件名</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"># 挂载 U 盘</span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br></pre></td></tr></table></figure></p>
<p>注意：Linux 默认是不支持 NTFS 文件系统的。注意：U 盘的设备文件名不是固定的，因为 U 盘跟硬盘采用同样的命名规则，如果系统中只有一块硬盘，U 盘就会识别为 sdb，依次类推，如果系统中已经有两块硬盘，则 U 盘就会识别为 sdc。即它是需要自动识别的，不需要去分配，只要插入，它就会自动去识别。在插入 U 盘的时候，鼠标一定要点到虚拟机里面（VMware 中），否则它就不是 Linux 虚拟机识别 U 盘了，而是 Windows 去识别 U 盘了。Linux 中把 fat16 文件系统识别为 fat，fat32 文件系统识别为 vfat。注意：先卸载再拔出 U 盘。</p>
<p>8、Linux 挂载 NTFS 文件系统的硬件设备<br>由于 Linux 本身不支持 NTFS 文件系统，所以需要利用第三方软件让 Linux 支持 NTFS 文件系统。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载 NTFS-3G 插件</span><br><span class="line">http://www.tuxera.com/community/ntfs-3g-download/</span><br><span class="line">2、安装 NTFS-3G 插件</span><br><span class="line">解压 &amp;&amp; 进入压缩目录 &amp;&amp; 「./configure」编译器准备。没有指定安装目录，安装到默认位置。 &amp;&amp; 编译 &amp;&amp; 安装</span><br><span class="line">3、插入 NTFS 文件系统的外设</span><br><span class="line">移动硬盘，插入硬盘的时候，鼠标要点进 VMware 虚拟机里面</span><br><span class="line">4、挂载</span><br><span class="line">mount -t ntfs-3g 分区设备文件名 挂载点</span><br></pre></td></tr></table></figure></p>
<h2 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk 分区"></a>fdisk 分区</h2><p>Linux 中真正的手工分区命令 fdisk。要掌握如何利用 fdisk 命令给 Linux 新建一个新的分区。</p>
<p>1、添加新硬盘<br>注意：添加硬盘的时候，必须先断电，否则虚拟机中硬件是无法添加和删除的，真实机也是这样的。</p>
<p>2、查看新硬盘<br>使用「fdisk -l」命令查询一下新硬盘是否被识别了。该命令最主要的作用就是查询系统当中有多少可以被识别的硬件设备。</p>
<p>3、使用 fdisk 命令分区<br>fdisk /dev/sdb</p>
<p><img src="/upload_image/fdisk_manual.png" alt="fdisk 交互指令" title="fdisk 交互指令"><br>主要知道 d、l、m、n、p、q、w 的作用即可。</p>
<p>4、重新读取分区表信息，使得新添加的分区生效<br>partprobe</p>
<p>5、格式化分区，注意扩展分区是不能格式化和写入数据的，但是逻辑分区可以<br>mkfs -t ext4 /dev/sdb1</p>
<p>6、建立挂载点并挂载分区<br>mkdir /disk1 &amp;&amp; mount /dev/sdb1 /disk1/</p>
<p>注意：使用 fdisk -l 命令只能看到分区是否被正常分配，但是不能知道分区是否被 Linux 挂载，要想知道分区是否被挂载可以使用 mount 或 df 命令。</p>
<p>7、分区的自动挂载<br>在 Linux 当中，如果使用命令来挂载，一旦重启命令操作的结果就会消失。要想永久生效，就要写入文件。自动挂载归根结底是要写入 /etc/fstab 文件。</p>
<p><img src="/upload_image/etc_fstab.png" alt="fstab 文件" title="fstab 文件"><br>第一个字段：最好使用 UUID。因为设备文件名有个问题，如果不小心把分区的顺序颠倒了，或者升级了系统内核，或者添加了新的硬盘，这种情况非常容易造成系统崩溃，但是系统是按照原先的顺序进行系统的启动和调用的。UUID 的作用相当于给每个分区起了一个唯一识别号，不管分区顺序如何变，分区的 UUID 号都是不会变的。可以使用「dumpe2fs -h 分区设备文件名」可以查看到分区的 UUID。</p>
<p>第四个字段：defaults 指分区自动挂载的时候使用默认权限，跟 mount 挂载的时候通过 -o 指定挂载权限是一回事。</p>
<p>第五个字段：注意这里的自动备份针对的是分区，即目录必须是分区才可以。自动备份到 lost+found 目录下。</p>
<p>第六个字段：一般我们新添加的分区，不应该等于 1，因为 1 是系统分配的，其优先级本应该最高，所以说我们分配的分区优先级应该比 2 大（数字越大，优先级越低）。注意：/etc/fstab 文件是重要的系统启动文件，修改的时候要特别小心，否则会把系统搞崩溃。</p>
<p><strong>注意：当修改完 /etc/fstab 文件后不要着急重启，先执行「mount -a」命令，如果 /etc/fstab 文件中有错误，会有提示，不至于重启的时候系统崩溃。</strong> 该命令的作用是根据配置文件 /etc/fstab 的内容，自动挂载。</p>
<p>如果还是不小心把 /etc/fstab 文件中的内容写错了，是还有修复的机会的。重启系统，输入 root 用户的密码，这时候会进入到系统，但是却发现不能编辑 /etc/fstab 文件，因为分区在报错了之后，挂载的时候挂成了只读权限，所以任何文件都无法修改，这个时候只需要重新把根分区挂载成读写权限就可以了「mount -o remount,rw /」。注意：/etc/fstab 文件修复，只能修复这个文件的报错，但是如果你在这个文件中把根分区 / 写错了，则无法修复，系统会直接崩溃。</p>
<h2 id="分配-swap-分区"><a href="#分配-swap-分区" class="headerlink" title="分配 swap 分区"></a>分配 swap 分区</h2><p>1、free 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看内存与 swap 分区使用情况，选项 -h 人性化显示大小</span><br><span class="line">free</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>cached(缓存)：是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程。<br>buffer(缓冲)：是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。</p>
</blockquote>
<p>2、添加 swap 分区操作步骤<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1、新建 swap 分区</span><br><span class="line"># 注意：把分区 ID 改为 82</span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line"># 2、格式化，注意分区设备名</span><br><span class="line">mkswap /dev/sdb6</span><br><span class="line"></span><br><span class="line"># 3、加入 swap 分区，注意分区设备名</span><br><span class="line">swapon /dev/sdb6</span><br><span class="line"># 取消 swap 分区</span><br><span class="line">swapoff /dev/sdb6</span><br><span class="line"></span><br><span class="line"># 4、swap 分区开机自动挂载</span><br><span class="line">vim /etc/fstab</span><br><span class="line">写入内容：/dev/sdb6 swap swap defaults 0 0</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十二)</title>
    <url>/2018/10/26/Linux-2018-10-26-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十二) —— Shell 编程 </blockquote>

<a id="more"></a>
<h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>1、正则表达式与通配符<br><strong>正则表达式</strong>用来在<strong>文件中</strong>匹配符合条件的<strong>字符串</strong>，正则是<strong>包含匹配</strong>。grep、awk、sed 等命令可以支持正则表达式。</p>
<p><strong>通配符</strong>用来匹配符合条件的<strong>文件名</strong>，通配符是<strong>完全匹配</strong>。ls、find、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配了。</p>
<p>注意：通配符和正则表达式这种区分，仅限于 Linux 的 Shell 当中。</p>
<p><img src="/upload_image/Basic_Regex.png" alt="基础正则表达式" title="基础正则表达式"></p>
<p>注意：这里是基础正则表达式，还存在扩展正则表达式。</p>
<p>注意：「^」位于中括号里面表示取反，位于外面表示行首。</p>
<p>test.txt 内容如下，将适用于以下所有用到 test.txt 的地方：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>zhangsan</td>
<td>male</td>
<td>86</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>female</td>
<td>90</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>male</td>
<td>83</td>
</tr>
</tbody>
</table>
<ol>
<li><p>「*」示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 匹配所有内容，包括空白行（即 a 出现了 0 次），相当于列出整个文档</span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含一个 a 的行</span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配至少包含两个 a 的行</span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>「.」示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># s..d 匹配在 s 和 d 之间一定有两个字符的所在行</span><br><span class="line">grep &quot;s..d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 d 之间有任意字符，把「.*」当做一个整体看，表示除换行符外任意一个字符出现任意次</span><br><span class="line">grep &quot;s.*d&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配所有内容</span><br><span class="line">grep &quot;.*&quot; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>「^」行首、「$」行尾示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以 M 开头的行</span><br><span class="line">grep &quot;^M&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 以 n 结尾的行</span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配空白行</span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>「[]」示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：中括号里面是不能匹配换行符的。</span><br><span class="line"></span><br><span class="line"># 匹配 s 和 i 之间，要么是 a、要么是 o。注意：一个中括号只匹配一个字符</span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配任意一个数字</span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配以小写字母开头的行</span><br><span class="line">grep &quot;^[a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用小写字母开头的行</span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配不用字母开头的行</span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>「\」转义符示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：「.」在正则里面表示任意一个字符，所以这里要加转义符。</span><br><span class="line"></span><br><span class="line"># 匹配使用「.」结尾的行</span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># a 连续出现 3 次</span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 包含连续的 3 个数字的字符串所在行</span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配最少用连续三个数字开头的行</span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"></span><br><span class="line"># 匹配在 s 和 i 之间，最少有一个 a，最多有三个 a</span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h2><p>1、cut 字段提取命令「注意：cut 命令默认列之间的分隔符为 tab 键」<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：cut [选项] 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -f列号    提取第几列</span><br><span class="line">    -d分隔符  按照指定分隔符分割列</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 提取第二列</span><br><span class="line">    cut -f 2 test.txt</span><br><span class="line"></span><br><span class="line">    # 提取第二、第三列，注意不是范围，是指定的列，中间以逗号分隔</span><br><span class="line">    cut -f 2,3 test.txt</span><br><span class="line"></span><br><span class="line">    # 指定列之间的分隔符为「:」，默认为 tab 键</span><br><span class="line">    cut -d &quot;:&quot; -f 1,3 test.txt</span><br></pre></td></tr></table></figure></p>
<p>注意：grep 命令表示在指定的文件中提取匹配的行，cut、awk 命令用来提取匹配的列。cut 命令中列之间的默认分割符为制表符即 tab 键。命令 grep -v [内容]，表示列出不包含指定的内容的行。grep 确认行，cut 确认列，利用这两个命令可以做一些操作，比如，获取所有普通用户的用户名：<code>cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1</code>。</p>
<p>cut 命令有一个局限就是「无法」识别空格（指识别起来超级麻烦扩展性还差）。对于空格的判断我们使用 awk 命令，但是因为 awk 比较复杂，所以能用 cut 的尽量不要用 awk，因为 cut 简单，但是存在局限性。</p>
<p>2、printf 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：printf &apos;输出类型输出格式&apos; 输出内容</span><br><span class="line"></span><br><span class="line">输出类型：</span><br><span class="line">      %ns     输出字符串。n 是数字，指代输出几个字符</span><br><span class="line">      %ni     输出整数。n 是数字，指代输出几个数字</span><br><span class="line">      %m.nf   输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。</span><br><span class="line">              eg：%8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">      \a   输出警告音</span><br><span class="line">      \b   输出退格键，即 Backspace 键</span><br><span class="line">      \f   清除屏幕</span><br><span class="line">      \n   换行</span><br><span class="line">      \r   回车，即 Enter 键</span><br><span class="line">      \t   水平输出 Tab 键</span><br><span class="line">      \v   垂直输出 Tab 键</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 注意以下命令中是否加了单引号或双引号</span><br><span class="line">    printf %s 1 2 3 4 5 6</span><br><span class="line">    printf %s %s %s 1 2 3 4 5 6</span><br><span class="line">    printf &apos;%s %s %s&apos; 1 2 3 4 5 6</span><br><span class="line">    printf &apos;%s %s %s\n&apos; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure></p>
<p>printf 是格式化输出命令，类似于 echo 命令。注意：printf 后面不能直接加文件名，也不能接受管道符的内容。但是可以使用 <code>printf &#39;%s&#39; $(cat 文件名)</code> 的形式输出命令执行结果，需要注意的是 printf 不调整输出格式。</p>
<p>printf 命令没有 cat 和 echo 的自动格式化功能，为什么还要学习 printf 命令，是因为在 awk 命令中不能调用系统命令 cat 或者 echo，只能使用 printf。</p>
<p>在 awk 命令的输出中支持 print 和 printf 命令：</p>
<blockquote>
<p>print：print 会在每个输出之后自动加入一个换行符（Linux 默认没有 print 命令）。<br>printf：printf 是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符。</p>
</blockquote>
<p>注意：print 只能在 awk 中使用。printf 命令在 Linux 系统中直接使用的几率不大，主要是在 awk 命令中使用。</p>
<p>3、awk 命令，注意单引号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">    awk &apos;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&apos; 文件名</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line">    一般使用关系表达式作为条件，如：</span><br><span class="line">    x &gt; 10</span><br><span class="line">    x &lt;= 10</span><br><span class="line"></span><br><span class="line">动作：</span><br><span class="line">    格式化语句</span><br><span class="line">    流程控制语句</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # $2 表示第 2 列，$4 表示第 4 列</span><br><span class="line">    awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br><span class="line"></span><br><span class="line">    df -h | awk &apos;&#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&apos;</span><br><span class="line"></span><br><span class="line">典例：获取系统中根分区硬盘的使用率，可以用来报警，如果超过80则给管理员提示。</span><br><span class="line">    df -h | grep 只有根分区才存在的字符串 | awk &apos;&#123;printf $5&#125;&apos; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure></p>
<p>注意：awk 命令虽然是列提取命令，但是它处理数据的时候，是先读入一行数据，然后把这行数据所有的内容都复制给对应的变量，$1 代表第一列，依次类推，然后再判断条件是否符合，对满足条件的执行相应的动作。</p>
<p>注意：awk 默认是以空格或者制表符作为分割符的。</p>
<p>注意：BEGIN 必须大写。它位于大括号前，表示它是一个条件，只有满足了这个条件，其后的动作才会被执行。BEGIN 的作用是：在所有的数据读取之前，执行其后面相对应的动作。注意所有的动作都要用单引号括起来。</p>
<ol>
<li><p>BEGIN 表示最先执行 BEGIN 条件后面的动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在进行真正的数据读取之前，即 awk &apos;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt，打印「This is a transcript.」这句话</span><br><span class="line">awk &apos;BEGIN&#123;printf &quot;This is a transcript. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>FS 内置变量<br>FS 的作用是指定分隔符的。注意：awk 命令在处理的时候是先读入第一行数据，然后再执行相应的动作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输出结果中，第一行数据没有按照预期输出</span><br><span class="line">awk &apos;&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd</span><br><span class="line"></span><br><span class="line"># 改进：读取第一条数据之前，先把分隔符变成「:」</span><br><span class="line">awk &apos;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>END 表示最后执行 END 条件后面的动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 表示在输出 &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125; 动作中的内容之后，输出 &#123;printf &quot;The end. \n&quot;&#125; 动作中的内容</span><br><span class="line">awk &apos;END&#123;printf &quot;The end. \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取成绩大于 87 的用户名，grep -v Name 的作用是去掉标题行</span><br><span class="line">cat test.txt | grep -v Name | awk &apos;$4 &gt;= 87 &#123;printf $2 &quot;\n&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4、sed 命令<br>sed 是一种几乎包括在所有 Unix 平台（包括 Linux）的轻量级<strong>流编辑器</strong>。sed 主要是用来将数据进行选取、替换、删除、新增的命令。</p>
<p>sed 其实不是截取命令，其实是一个流的编辑器。相当于一个编辑器。既然已经学了 vim，为什么还有学习 sed 呢？因为 vim 命令只能修改文件，不能直接修改命令结果里的内容。要想使用 vim 修改命令的输出，则需要先把输出保存到文件当中，然后再用 vim 修改文件。sed 不光可以修改文件，因为其是一个流编辑器，所以可以从管道符接受数据来进行修改，即 sed 支持管道符操作。实际操作中主要用在对命令的结果进行操作，但是在 shell 编程中，sed 是一个重要的流数据处理编辑器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    sed [选项] &apos;[动作]&apos; 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n  一般 sed 命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过 sed 命令处理的行输出到屏幕</span><br><span class="line">    -e  允许对输入数据应用多条 sed 命令编辑</span><br><span class="line">    -i  用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出，不光输出的数据会更改，源数据文件也会被更改。</span><br><span class="line"></span><br><span class="line">动作：</span><br><span class="line">    a \:    追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    c \:    行替换，用 c 后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    i \:    插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用「\」代表数据未完结</span><br><span class="line">    d:      删除，删除指定的行</span><br><span class="line">    p:      打印，输出指定的行</span><br><span class="line">    s:      字符串替换，用一个字符串替换另外一个字符串。格式为「行范围/s/就字符串/新字符串/g」</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 查看文件的第二行，会输出全部内容</span><br><span class="line">    sed &apos;2p&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 只显示经过 sed 命令处理的行</span><br><span class="line">    sed -n &apos;2p&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 针对管道符结果操作</span><br><span class="line">    df -h | sed -n &apos;2p&apos;</span><br><span class="line"></span><br><span class="line">    # 删除第二到第四行的数据，但不修改文件本身</span><br><span class="line">    sed &apos;2,4d&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第二行后追加 hello</span><br><span class="line">    sed &apos;2a hello&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第二行前插入两行数据</span><br><span class="line">    sed &apos;2i hello \</span><br><span class="line">    world&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 数据替换</span><br><span class="line">    sed &apos;2c No such person&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 在第三行中，把 90 替换成 99</span><br><span class="line">    sed &apos;3s/90/99/g&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # sed 操作的数据直接写入文件</span><br><span class="line">    sed -i &apos;3s/90/99/g&apos; test.txt</span><br><span class="line"></span><br><span class="line">    # 同时把 zhangsan 和 lisi 替换为空</span><br><span class="line">    sed -e &apos;s/zhangsan//g;s/lisi//g&apos; test.txt</span><br></pre></td></tr></table></figure>
<h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><p>1、排序命令 sort<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    sort [选项] 文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -f    忽略大小写</span><br><span class="line">    -n    以数值型进行排序，默认使用字符串型排序</span><br><span class="line">    -r    反向排序</span><br><span class="line">    -t    指定分割符，默认分隔符是制表符</span><br><span class="line">    -k n[,m]    按照指定的字段范围排序。从第 n 字段开始，m 字段结束（默认到行尾）</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 排序用户信息文件</span><br><span class="line">    sort /etc/passwd</span><br><span class="line"></span><br><span class="line">    # 反向排序</span><br><span class="line">    sort -t /etc/passwd</span><br><span class="line"></span><br><span class="line">    # 指定分隔符「:」。用第三字段开头，第三字段结尾排序，就是只用第三字段排序（类比数据库 order by 后面可以跟多个字段）</span><br><span class="line">    sort -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line"></span><br><span class="line">    # -n 表示将提取的字段当成数字来对待</span><br><span class="line">    sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br></pre></td></tr></table></figure></p>
<h2 id="条件判断（即测试一个条件是否成立）"><a href="#条件判断（即测试一个条件是否成立）" class="headerlink" title="条件判断（即测试一个条件是否成立）"></a>条件判断（即测试一个条件是否成立）</h2><p>1、按照文件类型进行判断（记住蓝色的就行，其它的了解）<br><img src="/upload_image/Judge_File_Type.png" alt="按照文件类型进行条件判断" title="按照文件类型进行条件判断"></p>
<p>2、两种判断格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式一:</span><br><span class="line">  # 注意该命令执行后没有任何输出，要想知道该命令的输出结果，可以使用 $? 来获取结果，「echo $?」打印结果</span><br><span class="line">  # $? 的作用是判断上一条命令是否正确执行，正确执行返回 0，否则返回其他数字</span><br><span class="line">  test -e /root/install.log</span><br><span class="line"></span><br><span class="line">格式二:</span><br><span class="line">  # 注意两端必须有空格</span><br><span class="line">  [ -e /root/install.log ]</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line">  # 第一个判断命令如果正确执行，则打印 yes，否则打印 no</span><br><span class="line">  [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br></pre></td></tr></table></figure></p>
<p>这种判断主要用在 Shell 脚本当中，而在脚本当中最常用的判断格式是用中括号。</p>
<p>3、按照文件权限进行判断<br><img src="/upload_image/Judge_File_Permission.png" alt="按照文件权限进行条件判断" title="按照文件权限进行条件判断"></p>
<p>举例：<code>[ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</code> 判断文件是否拥有写权限</p>
<p>注意：以上权限部分不区分所有者、所属组、其他人，只要该文件有这个权限，就为真。</p>
<p>4、两个文件之间进行比较（不常用）<br><img src="/upload_image/Two_File_Compare.png" alt="两个文件之间进行比较" title="两个文件之间进行比较"></p>
<p>5、两个整数之间比较（常用）<br><img src="/upload_image/Two_Integer_Compare.png" alt="两个整数之间比较" title="两个整数之间比较"><br>-ne ：  (not equal) 不相等<br>-gt ：  (greater than) 大于<br>-lt ：  (less than) 小于<br>-ge ：  (greater than or equal) 大于或等于<br>-le ：  (less than or equal)小于或等于</p>
<p>举例：<code>[ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || &quot;no&quot;</code> 判断 23 是否大于等于 22</p>
<p>6、字符串的判断（常用）<br><img src="/upload_image/Judge_String.png" alt="字符串的判断" title="字符串的判断"><br>注意：== 会把参数当成字符串</p>
<p>7、多重条件判断<br><img src="/upload_image/Judge_Many_Condition.png" alt="多重条件判断" title="多重条件判断"></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>1、<strong>单分支</strong> if 条件语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意：中括号内两边都有空格，注意分号不能少</span><br><span class="line">if [ 条件判断式 ];then</span><br><span class="line">  程序</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">    then</span><br><span class="line">      程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>单分支条件语句注意点：</p>
<blockquote>
<p>if 语句使用 fi 结尾，和一般语言使用大括号结尾不同。<br>[ 条件判断式 ] 就是使用 test 命令判断，所以中括号和条件判断式之间必须有空格。<br>then 后面跟符合条件之后执行的程序，可以放在 [] 之后，用「;」分割。也可以换行写入，就不需要「;」了。</p>
</blockquote>
<p>举例：判断分区使用率<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 统计根分区使用率</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"># 把根分区使用率作为变量赋值给 rate</span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda3&quot; | awk &apos;&#123;printf $5&#125;&apos; | cut -d &apos;%&apos; -f 1)</span><br><span class="line"></span><br><span class="line">if [ $rate -ge 80 ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;Warning! /dev/sda3 is full!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>2、双分支 if 条件语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">  then</span><br><span class="line">    条件成立时，执行的程序</span><br><span class="line">  else</span><br><span class="line">    # 注意 else 后面没有 then 了</span><br><span class="line">    条件不成立时，执行的另一个程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>示例1：备份 mysql 数据库<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 同步系统时间。注意：必须联网才能同步系统时间</span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span> 把当前系统时间按照「年月日」格式赋予变量 date</span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line"><span class="meta">#</span> 统计 mysql 数据库的大小，并把大小赋予 size 变量</span><br><span class="line">size=$(du -sh /var/lib/mysql)</span><br><span class="line"></span><br><span class="line">if [-d /tmp/dbbak ]</span><br><span class="line">  then</span><br><span class="line">    echo "Date: $date!" &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line">    echo "Data size: $size" &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line">    cd /tmp/dbbak</span><br><span class="line">    # 压缩的时候源文件可以写多个，中间用空格隔开就行</span><br><span class="line">    tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt; /dev/null</span><br><span class="line">    rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">  else</span><br><span class="line">    mkdir /tmp/dbbak</span><br><span class="line">    echo "Date: $date!" &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line">    echo "Data size: $size" &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line">    cd /tmp/dbbak</span><br><span class="line">    tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt; /dev/null</span><br><span class="line">    rm -rf /tmp/dbbak/dbinfo.txt</span><br></pre></td></tr></table></figure></p>
<p>示例2：判断 apache 是否启动<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 使用 nmap 命令扫描服务，并截取 apache 服务的状态，赋予变量 port</span><br><span class="line"><span class="meta">#</span> nmap 命令默认是没有装的</span><br><span class="line"><span class="meta">#</span> -sT 表示扫描指定服务器上开启的 tcp 端口</span><br><span class="line">port=$(nmap -sT 127.0.0.1 | grep tcp | grep http | awk '&#123;printf $2&#125;')</span><br><span class="line"></span><br><span class="line">if [ "$port" == "open" ]</span><br><span class="line">  then</span><br><span class="line">    echo "$(date) httpd is ok!" &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">  else</span><br><span class="line">    /etc/rc.d/init.d/httpd start &amp;&gt; /dev/null</span><br><span class="line">    echo "$(date) restart httpd!" &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>如何判断系统中某个服务是否启动？此处已 apache 服务器为例。<br>方式1：通过 <code>ps aux | grep httpd</code> 查找是否有 apache 的进程在运行。但是这种判断是有点问题的，比如有些情况下就算 apache 启动了，如果它死机了，服务是死掉的，但是进程还在却不能正常相应客户的请求。所以不是特别准确。</p>
<p>方式2：通过 <code>netstat -tlun</code> 判断端口，比如 80 端口，问题同上，不能确定你的 apache 是否能正常提供访问。它只能确定 apache 是启动的，而且不仅 apache 其他应用也可能会占用 80 端口。</p>
<p>方式3：最有效的办法是通过 nmap 命令，是一个远程扫描命令，是一个扫描工具，用它来扫描当前计算机，如果该工具能够正确连接 apache 的端口，它就会返回 apache 的状态是 open，证明 apache 是打开的而且是可访问的。推荐使用这个，比较准确一点。</p>
<p>3、多分支 if 条件语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ]</span><br><span class="line">  then</span><br><span class="line">    当条件判断式 1 成立时，执行程序 1</span><br><span class="line">elif [ 条件判断式2 ]</span><br><span class="line">  then</span><br><span class="line">    当条件判断式 2 成立时，执行程序 2</span><br><span class="line">......</span><br><span class="line">else  </span><br><span class="line">  # 注意没有 then 了</span><br><span class="line">  当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 判断用户输入的是什么文件</span><br><span class="line">#!/bin/bash</span><br><span class="line"># 接受键盘的输入，并赋给变量 file</span><br><span class="line">read -p &quot;Please input a filename: &quot; file</span><br><span class="line"># 判断 file 是否为空</span><br><span class="line">if [ -z &quot;$file&quot; ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;Error,please input a filename.&quot;</span><br><span class="line">    exit 1</span><br><span class="line">elif [ ! -e &quot;$file&quot; ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;Your input is not  a file.&quot;</span><br><span class="line">    exit 2</span><br><span class="line">elif [ -f &quot;$file&quot; ]    </span><br><span class="line">  then</span><br><span class="line">    echo &quot;$file is a regulare file.&quot;</span><br><span class="line">elif [ -d &quot;$file&quot; ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;$file is a director.&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;$file is an other file.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：对于 if else 中的报错程序，如果报错了一定要退出程序，否则程序还会继续向下执行。</strong></p>
<h3 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h3><p>多分支 case 条件语句：case 语句和 if…elif…else 语句一样都是多分支条件语句，不过和 if 多分支条件语句不通的是，case 语句只能判断一种条件关系，而 if 语句可以判断多种条件关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">  &quot;值1&quot;)</span><br><span class="line">      如果变量的值等于值 1，则执行程序 1</span><br><span class="line">      # 表示程序段的结束，不能省略</span><br><span class="line">      ;;    </span><br><span class="line">  &quot;值2&quot;)</span><br><span class="line">      如果变量的值等于值 2，则执行程序 2  </span><br><span class="line">      # 表示程序段的结束，不能省略</span><br><span class="line">      ;;   </span><br><span class="line">  ... 省略其他分支 ...</span><br><span class="line">  # 注意 * 号是没有引号的，其他的是有引号的</span><br><span class="line">  *)</span><br><span class="line">      如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">      ;;</span><br><span class="line"># 注意最后的 esac     </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;Please choose yes/no: &quot; -t 30 cho</span><br><span class="line">case $cho in</span><br><span class="line">    &quot;yes&quot;)</span><br><span class="line">        echo &quot;Your choose is yes.&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;no&quot;)</span><br><span class="line">        echo &quot;Your choose is no.&quot;</span><br><span class="line">        ;;        </span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Your choose is error.&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>1、语法一<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 值之间的分隔符为空格</span><br><span class="line">for 变量 in 值1 值2 值3 ...</span><br><span class="line">  do</span><br><span class="line">    程序</span><br><span class="line">  done</span><br></pre></td></tr></table></figure></p>
<p>注意：后面有几个值，for 循环执行几次，每次执行都会把值赋给变量。注意：in 后面的值不管是空格还是换行，只要是分开的，系统就把它当场一个内容即一个值。</p>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">  do</span><br><span class="line">    echo &quot;This time is $time.&quot;</span><br><span class="line">  done</span><br></pre></td></tr></table></figure></p>
<p>这种循环很笨，但是还存在的理由：就是更加利于系统管理，因为 in 后面的值可以从内容中获取，即循环的次数可以不确定，比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 批量解压缩脚本</span><br><span class="line">cd /test</span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">  do</span><br><span class="line">    tar -zxf $i &amp;&gt; /dev/null</span><br><span class="line">  done</span><br><span class="line">rm -rf /test/ls.log</span><br></pre></td></tr></table></figure></p>
<p>2、语法二<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ((初始值;循环控制条件;变量变化))</span><br><span class="line">  do</span><br><span class="line">    程序</span><br><span class="line">  done</span><br></pre></td></tr></table></figure></p>
<p>在 Linux 中，只有用双小括号括起来，才可以进行加减乘除这种数值运算。<br>两种循环的区别：第一种循环不知道循环次数，第二种循环知道循环次数。</p>
<p>示例1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 从 1 加到 100</span><br><span class="line">s = 0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">  do</span><br><span class="line">    s=$(( $s+$i ))</span><br><span class="line">  done</span><br><span class="line">echo &quot;The sum result is: + $s&quot;</span><br></pre></td></tr></table></figure></p>
<p>示例2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 批量添加指定数量的用户</span><br><span class="line">read -p &quot;Please input username: &quot; -t 30 name</span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t 30 number</span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t 30 password</span><br><span class="line"></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$number&quot; -a ! -z &quot;$password&quot; ]</span><br><span class="line">  then</span><br><span class="line">    # 判断 number 是否合法，即是否为纯数字</span><br><span class="line">    # 把以任意数字开头且以任意数字结尾的替换为空，即将纯数字替换为空</span><br><span class="line">    y = $(echo $number | sed &apos;s/^[0-9]*$//g&apos;)</span><br><span class="line">      if [-z &quot;$y&quot;]</span><br><span class="line">        then</span><br><span class="line">          for (( i=1;i&lt;=$number;i=i+1 ))</span><br><span class="line">            do</span><br><span class="line">              /usr/sbin/useradd $name$i $&gt;/dev/null</span><br><span class="line">              echo $password | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null</span><br><span class="line">            done</span><br><span class="line">      fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>1、while 循环是<strong>不定循环</strong>，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和 for 的固定循环不太一样了。注意：在 while 的执行语句中需要对其条件判断式不断改变，否则要是永远成立，则死循环了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">  do</span><br><span class="line">    程序</span><br><span class="line">  done</span><br></pre></td></tr></table></figure>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 从 1 加到 100</span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">  do</span><br><span class="line">    s=$(( $s+$i ))</span><br><span class="line">    i=$(( $i+1 ))</span><br><span class="line">  done</span><br><span class="line">echo &quot;The sum is:  $s&quot;</span><br></pre></td></tr></table></figure></p>
<p>2、until 循环，和 while 循环相反，until 循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">  do</span><br><span class="line">    程序</span><br><span class="line">  done</span><br></pre></td></tr></table></figure>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 从 1 加到 100</span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">  do</span><br><span class="line">    s=$(( $s+$i ))</span><br><span class="line">    i=$(( $i+1 ))</span><br><span class="line">  done</span><br><span class="line">echo &quot;The sum is:  $s&quot;</span><br></pre></td></tr></table></figure></p>
<p>注意：Shell 是脚本语言，脚本语言的好处就是所见即所得，即写完的所有脚本语言都不需要编译就可以直接运行，但是它不是不需要编译，而是在执行的同时进行编译，省略简化了编译过程，好处是编程更加简单，坏处是效率要更慢。Shell 语言不适合进行大量的数据运算，其最大的作用是帮助管理员减少重复操作。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十三)</title>
    <url>/2018/11/02/Linux-2018-11-02-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十三) —— Linux 服务管理 </blockquote>

<a id="more"></a>
<h2 id="服务简介与分类"><a href="#服务简介与分类" class="headerlink" title="服务简介与分类"></a>服务简介与分类</h2><p>1、服务的分类<br><img src="/upload_image/linux_service_category.png" alt="服务的分类" title="服务的分类"><br>注意：因为 Linux 操作系统都是使用 RPM 安装的，所以把 RPM 包安装的服务称为默认服务。</p>
<blockquote>
<p>独立的服务：Linux 当中绝大多数的服务都是独立的，服务直接就在内存里，当有用户访问，该服务就会直接响应用户，好处是服务的访问响应速度更快，坏处是独立的服务越多，消耗的服务器内存资源越多。</p>
</blockquote>
<blockquote>
<p>Xinetd 服务本身就是独立的，它就在内存中，它本身没有任何功能，它唯一的功能就是在它之后还有一系列被它管理的服务。比如 rsync 是 Linux 中网络备份服务，要访问它（rsync）不能直接找到它，因为它（rsync）没在内存里，先找 xinetd，再通过 xinetd 找到它，好处是 xinetd 之后的服务不占用内存，坏处是响应速度相对慢。</p>
</blockquote>
<p>2、启动与自启动</p>
<blockquote>
<p>服务启动：就是在当前系统中让服务运行，并提供功能。</p>
</blockquote>
<blockquote>
<p>服务自启动：自启动是指让服务在系统开机或重启之后，随着系统的启动而自动启动服务。</p>
</blockquote>
<p>3、查询已安装的<strong>服务</strong>是否开启自启动</p>
<blockquote>
<p>RPM 包安装的服务：<code>systemctl list-unit-files</code> 查看服务自启动状态，可以看到所有 RPM 包安装的服务。</p>
</blockquote>
<blockquote>
<p>源码包安装的服务：查看服务安装位置，一般是 /usr/local/ 下。</p>
</blockquote>
<p>注意 systemctl 是不能查看源码包安装的服务的。注意：它是服务自启动查看命令，不是服务是不是正在运行的查看命令。要想查看服务是否正在运行可以通过 <code>ps aux</code> 查看系统所有进程 或 <code>netstat -tlun</code> 查看所有端口服务的方式去查看。</p>
<p>4、RPM 包安装服务和源码包安装服务的区别就是安装位置的不同。源码包安装在指定位置，一般是 /usr/local/；RPM 包安装在默认位置中。</p>
<h2 id="RPM-包安装服务的管理"><a href="#RPM-包安装服务的管理" class="headerlink" title="RPM 包安装服务的管理"></a>RPM 包安装服务的管理</h2><h3 id="独立服务的管理"><a href="#独立服务的管理" class="headerlink" title="独立服务的管理"></a>独立服务的管理</h3><p>1、RPM 包常见通用的默认安装位置（对于 CentOS 7.x 来说部分已过期）<br><img src="/upload_image/rpm_install_default_location.png" alt="RPM 包常见通用的默认安装位置" title="RPM 包常见通用的默认安装位置"><br>CentOS7 的服务 systemctl 脚本存放在：/usr/lib/systemd/，有系统（system）和用户（user）之分。是存放<strong>独立服务启动脚本的位置</strong>。</p>
<p>2、独立服务的启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    systemctl start|stop|restart|status 独立服务名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    systemctl status crond.service</span><br></pre></td></tr></table></figure></p>
<p>3、独立服务的自启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    systemctl enable/disable 独立服务名</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    systemctl enable crond.service</span><br></pre></td></tr></table></figure></p>
<p>可以使用 <code>ntsysv</code> 命令管理自启动服务。ntsysv 相当于 setup 命令，想要启动，在其前面输入 * 号，不想启动输入空格。是 red hat 系列专有命令，可以管理独立的服务和基于 xinetd 服务。</p>
<h3 id="基于-xinetd-服务的管理"><a href="#基于-xinetd-服务的管理" class="headerlink" title="基于 xinetd 服务的管理"></a>基于 xinetd 服务的管理</h3><p>1、安装 xinetd 与 telnet<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install xinetd</span><br><span class="line"></span><br><span class="line">yum -y install telnet-server</span><br></pre></td></tr></table></figure></p>
<p>注意：基于 xinetd 管理的服务越来越少了。telnet 服务非常不安全，用它做远程管理已经被淘汰了，我们只是用它的客户端来测试一下端口是否能连接，不再用它来做远程管理。远程管理使用更加安全的 ssh 服务。telnet 服务器是非常不安全，用完之后最好删除。但是其客户端是系统默认安装的。</p>
<h2 id="源码包安装服务的管理"><a href="#源码包安装服务的管理" class="headerlink" title="源码包安装服务的管理"></a>源码包安装服务的管理</h2><p>1、源码包安装服务的启动<br>使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。</p>
<p>2、源码包服务的自启动</p>
<p>3、让源码包服务被服务管理命令识别</p>
<h2 id="服务管理总结"><a href="#服务管理总结" class="headerlink" title="服务管理总结"></a>服务管理总结</h2><p><img src="/upload_image/services_management_summary.png" alt="服务管理总结" title="服务管理总结"></p>
<p>常见服务的作用：</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>功能简介</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>crond</td>
<td>系统的定时任务，一般的 Linux 服务器都需要定时任务帮助系统维护</td>
<td>开启</td>
</tr>
<tr>
<td>gpm</td>
<td>在字符终端（tt1-tt6）中可以使用鼠标复制粘贴。就是这个服务的功能</td>
<td>开启</td>
</tr>
<tr>
<td>iptables</td>
<td>防火墙功能，Linux 中防火墙是内核支持功能。这是服务器的主要防护手段，必须开启</td>
<td>开启</td>
</tr>
<tr>
<td>sshd</td>
<td>ssh 加密远程登录管理的服务。服务器的远程管理必须使用此服务</td>
<td>开启</td>
</tr>
<tr>
<td>syslog</td>
<td>日志的守护进程</td>
<td>开启</td>
</tr>
</tbody>
</table>
<p>注意：服务开的越少越好，因为安全，而且占用的资源也比较少。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十四)</title>
    <url>/2018/11/03/Linux-2018-11-03-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E5%9B%9B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十四) —— Linux 系统管理 </blockquote>

<a id="more"></a>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h3><p>1、进程简介<br>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p>
<p>注意：命令也是一个进程，因为命令其实是一个功能，但是命令的进程存留的时间超级短，可能很难看到。要运行一个程序至少产生一个进程。</p>
<p>2、进程管理的作用</p>
<blockquote>
<p>判断服务器健康状态<br>查看系统中所有进程<br>杀死进程</p>
</blockquote>
<p>注意：进程管理最主要的工作是判断服务器的健康状态，而不是杀死进程，就算是不需要的进程也应该尝试正确终止，而不是杀死进程，杀进程是无法正常终止才采用的方式。</p>
<p>3、查看系统中所有进程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式一：使用 BSD 操作系统格式</span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line"># 方式二：使用 Linux 标准命令格式</span><br><span class="line">ps -le</span><br></pre></td></tr></table></figure></p>
<p>第一种采用的是 Unix 格式，注意选项前面并没有「-」。aux：a 表示查看所有前台进程，x 表示查看所有后台进程，u 显示进程是由哪个用户产生的。-le：l 显示进程详细信息，e 显示系统所有进程。</p>
<p><img src="/upload_image/ps_aux_show.png" alt="ps aux 显示" title="ps aux 显示"><br><img src="/upload_image/ps_aux_explain.png" alt="ps aux 显示说明" title="ps aux 显示说明"></p>
<p>绝大多数的系统进程的 TTY 显示的都是 「?」，证明这个进程不是由终端调用的，而是由内核直接产生的。按住 Alt + F1~F6 能够切换 6 个本地字符终端，如果按装了图形界面可以使用 Ctrl + Alt + F7 切换到图形终端。</p>
<p>4、查看系统健康状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    top [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -d 秒数        指定 top 命令每隔几秒钟更新，默认是 3 秒</span><br><span class="line"></span><br><span class="line">    在 top 命令的交互模式当中可以执行的命令：</span><br><span class="line">    ? 或 h         显示交互模式的帮助</span><br><span class="line">    P              以 cpu 使用率排序，默认就是此项</span><br><span class="line">    M              以内存的使用率排序</span><br><span class="line">    N              以 PID 排序</span><br><span class="line">    q              退出 top</span><br></pre></td></tr></table></figure></p>
<p>相当于 Windows 的任务管理器，默认以 cpu 的占用率进行排序。该命令最主要的是看头 5 行。</p>
<p><img src="/upload_image/top_show.png" alt="top 命令显示" title="top 命令显示"><br>主要看上图中的三个指标：Tasks 的 load average、Cpu 的 id、Mem 的 free。</p>
<p>(1) 第一行信息为任务队列信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>17:01:55</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 10 days,  6:02</td>
<td>系统的运行时间，本机已经运行 10 天 6 小时 2 分钟</td>
</tr>
<tr>
<td>1 users</td>
<td>当前登陆了一个用户</td>
</tr>
<tr>
<td>load average: 0.00, 0.01, 0.05</td>
<td>系统在之前 1 分钟，5 分钟，15 分钟的平均负载。一般认为小于 1 时，负载较小；如果大于 1，系统已经超出负荷。</td>
</tr>
</tbody>
</table>
<p>(2) 第二行为进程信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 119 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>118 sleeping</td>
<td>睡眠的进程</td>
</tr>
<tr>
<td>0 stopped</td>
<td>正在停止的进程</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程。如果不是 0，需要手工检查僵尸进程</td>
</tr>
</tbody>
</table>
<p>僵尸进程指：这个进程正在终止，但是还没有终止完全。</p>
<p>(3) 第三行为 CPU 信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Cpu(s):  0.0 us</td>
<td>用户模式占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0 sy</td>
<td>系统模式占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>改变过优先级的用户进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>100.0 id</td>
<td>空闲 CPU 的 CPU 百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入/输出的进程的占用 CPU 百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>st（steal time）虚拟时间百分比。就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比</td>
</tr>
</tbody>
</table>
<p>(4) 第四行为物理内存信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>KiB Mem :  1012400 total</td>
<td>物理内存的总量，单位 KB</td>
</tr>
<tr>
<td>279524 free</td>
<td>空闲的物理内存数量</td>
</tr>
<tr>
<td>196900 used</td>
<td>已经使用的物理内存数量</td>
</tr>
<tr>
<td>535976 buff/cache</td>
<td>作为缓冲/缓存的内存数量</td>
</tr>
</tbody>
</table>
<p>(5) 第五行为交换分区（swap）信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>KiB Swap:  1888252 total</td>
<td>交换分区（虚拟内存）的总大小</td>
</tr>
<tr>
<td>1888252 free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td>0 used</td>
<td>已经使用的交换分区的大小</td>
</tr>
<tr>
<td>574856 avail Mem</td>
<td>作为缓存的交换分区的大小</td>
</tr>
</tbody>
</table>
<p>注意：top 命令以及 Windows 的任务管理器，本身是非常耗费资源的，看一看就行，没事不要总打开。top 命令本身比较消耗资源。</p>
<p>5、查看进程树<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    pstree [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -p    显示进程的 PID</span><br><span class="line">    -u    显示进程的所属用户</span><br></pre></td></tr></table></figure></p>
<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>1、kill 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看可用的进程信号</span><br><span class="line">kill -l</span><br><span class="line"></span><br><span class="line"># 重启进程，22345 表示进程 ID 即 PID</span><br><span class="line"># 注意 kill 后面跟的一定是 PID 号而不能是进程名</span><br><span class="line">kill -1 22345</span><br><span class="line"></span><br><span class="line"># 强制杀死进程</span><br><span class="line">kill -9 22368</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/kill_l_show.png" alt="常见进程信号" title="常见进程信号"></p>
<p>最常用的进程信号：1（重启）、9（强制终止）、15（正常终止，默认为此项）</p>
<p>2、killall 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    # 按照进程名杀死进程</span><br><span class="line">    killall [选项][信号] 进程名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -i    交互式，询问是否要杀死某个进程</span><br><span class="line">    -I    忽略进程名的大小写</span><br></pre></td></tr></table></figure></p>
<p>3、pkill 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    # 按照进程名终止进程</span><br><span class="line">    pkill [选项][信号] 进程名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -t 终端号     按照终端号踢出用户</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 按照终端号踢出用户</span><br><span class="line">    # 用 w 命令查询本机已经登录的用户</span><br><span class="line">    # 强制杀死从 pst/1 虚拟终端登录的进程</span><br><span class="line">    pkill -t -9 pst/1</span><br></pre></td></tr></table></figure></p>
<p>pkill 和 killall 其实非常类似，都是根据<strong>进程名</strong>杀死进程，区别就是 pkill 支持 -t 选项，即根据终端号踢出用户。</p>
<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><p>1、把进程放入后台<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式一：使用 &amp; ，&amp; 表示放入后台继续运行</span><br><span class="line">tar -zxf etc.tar.gz /etc &amp;</span><br><span class="line"></span><br><span class="line"># 方式二：使用 ctrl + z 快捷键，表示放入后天暂停运行</span><br><span class="line"># 在 top 命令执行的过程中，使用 ctrl + z 快捷键</span><br></pre></td></tr></table></figure></p>
<p>2、查看后台的工作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    # 选项 -l 显示工作的 PID</span><br><span class="line">    jobs [-l]</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/jobs_l_show.png" alt="jobs -l 显示" title="jobs -l 显示"></p>
<p>注：[数字]表示工作号，表示第几个放入的。「+」号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。「-」号代表倒数第二个放入后台的工作。在不指定工作号的情况下，默认第一个恢复「+」，其次「-」。</p>
<p>3、将后台暂停的工作恢复到前台执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    fg %工作号</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    %工作号    %号可以省略，但是注意工作号和 PID 的区别</span><br></pre></td></tr></table></figure></p>
<p>4、把后台暂停的工作恢复到后台执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bg %工作号</span><br></pre></td></tr></table></figure></p>
<p>注：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行。</p>
<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><p>1、vmstat 命令监控系统资源<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    vmstat [刷新延时 刷新次数]</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    # 监听 3 次系统资源，每次间隔 1 秒钟</span><br><span class="line">    vmstat 1 3</span><br></pre></td></tr></table></figure></p>
<p>2、dmesg 开机时内核检测信息，dmesg 是一个重要的信息查看命令，可以通过它判断系统的硬件信息，如：查看 CPU 的信息 <code>dmesg | grep CPU</code>。</p>
<p>3、free 命令查看内存使用状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    free [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -b 以字节为单位；-k 以 KB 为单位，默认项</span><br><span class="line">    -m 以 MB 为单位；-G 以 GB 为单位</span><br></pre></td></tr></table></figure></p>
<p>4、缓存和缓冲的区别<br>简单来说缓存（cache）是用来加速数据从硬盘中「读取」的，而缓冲（buffer）是用来加速数据「写入」硬盘的。</p>
<p>由于内存的运行速度比硬盘快，而且快的多。缓冲是为了避免频繁的对硬盘进行写操作，是将要写入的内容积累到一定数量然后一次性写入硬盘。</p>
<p>5、查看 CPU 信息：<code>cat /proc/cpuinfo</code>。注意 /proc 目录是内存的挂载点，一旦断电这个目录里面的内容就会消失，即每次开机都系统都会检测 cpu 并写入该文件。</p>
<p>6、uptime 命令：显示系统的启动时间和平均负载，也就是 top 命令的第一行。w 命令也可以看到这个数据。</p>
<p>7、查看系统与内核相关的信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    uname [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a   查看系统所有相关信息</span><br><span class="line">    -r   查看内核版本</span><br><span class="line">    -S   查看内核名称</span><br></pre></td></tr></table></figure></p>
<p>8、判断当前系统的位数：<code>file /bin/ls</code> file 命令是查看文件类型的命令，只要使用 file 命令查询一个系统的外部命令的文件类型，注意不能是 Shell 的内部命令，会附带的显示操作系统位数。</p>
<p>9、查询当前 Linux 系统的发行版本：<code>lsb_release -a</code></p>
<p>10、列出进程打开或使用的文件信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    lsof [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -c 字符串：只列出以字符串开头的进程打开的文件</span><br><span class="line">    -u 用户名：只列出某个用户的进程打开的文件</span><br><span class="line">    -p pid  ：列出某个 PID 进程打开的文件</span><br></pre></td></tr></table></figure></p>
<h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><p>1、crond 服务管理与访问控制（cron 计划任务，d 表示 deamon 守护进程）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># crond 启动命令</span><br><span class="line">systemctl restart crond.service</span><br><span class="line"></span><br><span class="line"># 设置 crond 开机自启动</span><br><span class="line">systemctl enable crond.service</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/crond_isstart_show.png" alt="查看 crond 服务是否启动" title="查看 crond 服务是否启动"></p>
<p>2、用户的 crontab 设置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    crontab [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -e   编辑 crontab 定时任务</span><br><span class="line">    -l   查询 crontab 任务</span><br><span class="line">    -r   删除当前用户所有的 crontab 任务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    */5 * * * * /bin/echo &quot;11&quot; &gt;&gt; /tmp/test</span><br><span class="line">    5 5 * * 2 /sbin/shutdown -r now</span><br><span class="line">    0 5 1,10,15 * * /root/sh/autobak.sh</span><br></pre></td></tr></table></figure></p>
<p>执行命令 <code>crontab -e</code> 进入 crontab 编辑界面。会打开 vim 编辑你的工作。格式：<code>* * * * * 执行的任务</code>，注意：在 crontab 中 % 是有特殊含义的，为了能够格式化日期，必须加转义符，否则定义的时间是无法正确执行 <code>date=$(date +\%y\%m\%d)</code>。</p>
<p>crontab 编辑格式中五个「*」的含义：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个 *</td>
<td>一小时当中的第几个分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个 *</td>
<td>一天当中的第几个小时</td>
<td>0-24</td>
</tr>
<tr>
<td>第三个 *</td>
<td>一个月当中的第几个天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个 *</td>
<td>一年当中的第几个月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个 *</td>
<td>一周当中的第几天</td>
<td>0-7（0 和 7 都代表星期日）</td>
</tr>
</tbody>
</table>
<p>crond 定时任务特殊符号解释：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任何时间。比如第一个 * 就表示一小时中每分钟都执行一次的意思</td>
</tr>
<tr>
<td>,</td>
<td>代表不连续的时间。比如 <code>0 8,12,16 * * * 命令</code>，就代表在每天的 8 点 0 分，12 点 0 分， 16 点 0 分都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如 <code>0 5 * * 1-6 命令</code>，代表在周一到周六的凌晨 5 点 0 分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次。比如 <code>*/10 * * * * 命令</code>，代表每隔 10 分钟就执行一遍命令</td>
</tr>
</tbody>
</table>
<p>crond 定时任务示例解释：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>45 22 * * * 命令</code></td>
<td>在每天的 22 点 45 分执行命令</td>
</tr>
<tr>
<td><code>0 17 * * 1 命令</code></td>
<td>在每周 1 的 17 点 0 分执行命令</td>
</tr>
<tr>
<td><code>0 5 1,15 * * 命令</code></td>
<td>在每个月的 1 号和 15 号 5 点 0 分执行命令</td>
</tr>
<tr>
<td><code>40 4 * * 1-5 命令</code></td>
<td>每周 1 到周 5 的 4 点 40 分执行命令</td>
</tr>
<tr>
<td><code>*/10 4 * * * 命令</code></td>
<td>每天 4 点，每隔 10 分钟执行一次命令</td>
</tr>
<tr>
<td><code>0 0 1,15 * 1 命令</code></td>
<td>每月 1 号和 15 号，每周 1 的 0 点 0 分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱</td>
</tr>
</tbody>
</table>
<p>如果写的是「*」代表任意时间，如果写的是具体的值，代表指定的时间。</p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十五)</title>
    <url>/2018/11/04/Linux-2018-11-04-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%BA%94/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十五) —— 日志管理 </blockquote>

<a id="more"></a>
<h2 id="日志管理简介"><a href="#日志管理简介" class="headerlink" title="日志管理简介"></a>日志管理简介</h2><p>1、日志服务<br>在 CentOS 6.x 中日志服务已经由 rsyslogd 取代了原先的 syslogd 服务。rsyslogd 日志服务更加先进，功能更多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看服务是否启动</span><br><span class="line">ps aux | grep rsyslogd</span><br><span class="line"></span><br><span class="line"># 启动日志服务</span><br><span class="line">systemctl restart rsyslog.service</span><br><span class="line"></span><br><span class="line"># 查看服务是否是自启动</span><br><span class="line">systemctl list-unit-files | grep rsyslog.service</span><br><span class="line"></span><br><span class="line"># 设置日志服务自启动</span><br><span class="line">systemctl enable rsyslog.service</span><br></pre></td></tr></table></figure>
<p>2、常见日志的作用<br><img src="/upload_image/common_log_function.png" alt="常见日志的作用" title="常见日志的作用"></p>
<p>除了系统默认的日志之外，采用 RPM 方式安装的系统服务也会默认把日志记录在 /var/log 目录中（源码包安装的服务日志是在源码包指定目录中）。不过这些日志不是由 rsyslogd 服务来记录的和管理的，而是各个服务使用自己的日志管理文档来记录自身日志。只要通过 RPM 包的方式安装对应的服务，就会产生对应的日志。</p>
<h2 id="rsyslogd-日志服务"><a href="#rsyslogd-日志服务" class="headerlink" title="rsyslogd 日志服务"></a>rsyslogd 日志服务</h2><p>1、日志文件格式<br>基本日志格式包含以下四列：</p>
<blockquote>
<p>事件产生的时间<br>发生事件的服务器的主机名<br>产生事件的服务名或程序名<br>事件的具体信息</p>
</blockquote>
<p>2、/etc/rsyslog.conf 配置文件</p>
<p>rsyslogd 服务记录哪些日志，到底记录什么样的日志，是由 /etc/rsyslog.conf 这个配置文件决定的。该日志的固定格式为：<code>服务名称[连接符号]日志等级   日志记录位置</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务名称 authpriv，连接符号「.」，日志等级 *，日志记录位置 /var/log/secure</span><br><span class="line"># authpriv 表示认证相关的服务，「.」代表大于等于后面日志等级，* 所有日志等级</span><br><span class="line"># 即所有认证相关服务的日志不管它是什么等级，全都记录在 /var/log/secure 这个日志中</span><br><span class="line">authpriv.*             /var/log/secure</span><br></pre></td></tr></table></figure></p>
<p><img src="/upload_image/log_service_name.png" alt="服务名称" title="服务名称"></p>
<p><img src="/upload_image/log_connector.png" alt="连接符号" title="连接符号"></p>
<p><img src="/upload_image/log_level.png" alt="日志等级" title="日志等级"><br>注意：上图中从上到下为从低等级到高等级。等级越高，记录的内容越小（因为发生的可能比较小），优先级越高，危害越大。</p>
<p><img src="/upload_image/log_location.png" alt="日志记录位置" title="日志记录位置"><br>lp0 表示打印机的意思。</p>
<h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><p>1、日志轮替包含以下两点：</p>
<blockquote>
<p>日志需要切割：例如将大日志按天分成小日志。<br>日志需要轮换：例如只记录 30 天的日志，前第 31 天以前的就会被删掉。</p>
</blockquote>
<p>2、日志文件的命名规则<br><img src="/upload_image/log_name_regulation.png" alt="日志文件的命名规则" title="日志文件的命名规则"></p>
<p>3、logrotate.conf 配置文件<br><img src="/upload_image/logrotate_instruction.png" alt="logrotate.conf 配置文件" title="logrotate.conf 配置文件"></p>
<p>4、把 apache 日志加入轮替<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/logrotate.conf</span><br><span class="line">/usr/local/apache/logs/access_log &#123;</span><br><span class="line">  daily</span><br><span class="line">  create</span><br><span class="line">  rotate 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：RPM 包安装的，日志都不需要进行手工去轮替，系统都会默认去轮替；需要做的只有源码包安装的日志。一般情况下所有的源码包安装的日志都需要做手工配置轮替。</p>
<p>5、logrotate 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    logrotate [选项] 配置文件名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    如果此命令没有选项，则会安装配置文件中的条件进行日志轮替</span><br><span class="line">    -v   显示日志轮替过程</span><br><span class="line">    -f   强制进行日志轮替。不管日志轮替的条件是否已经符号，强制配置文件中多有的日志进行轮替</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十六)</title>
    <url>/2018/11/05/Linux-2018-11-05-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E5%85%AD/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十三) —— Linux 启动管理 </blockquote>

<a id="more"></a>
<h2 id="CentOS-启动管理"><a href="#CentOS-启动管理" class="headerlink" title="CentOS 启动管理"></a>CentOS 启动管理</h2><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p>1、运行级别<br><img src="/upload_image/linux_run_level.png" alt="运行级别" title="运行级别"></p>
<p>2、运行级别命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前运行级别</span><br><span class="line">runlevel</span><br><span class="line"></span><br><span class="line"># 改变运行级别</span><br><span class="line">init 运行级别</span><br></pre></td></tr></table></figure></p>
<p>3、系统默认运行级别<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置系统开机后直接进入哪个运行级别</span><br><span class="line">vim  /etc/inittab</span><br><span class="line">写入如下内容：（注意最后的冒号不能少）</span><br><span class="line">id:3:initdefault:</span><br><span class="line"></span><br><span class="line"># CentOS7 设置系统默认运行级别</span><br><span class="line"># To view current default target, run:</span><br><span class="line">systemctl get-default</span><br><span class="line"># To set a default target, run:</span><br><span class="line">systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure></p>
<h3 id="系统启动过程"><a href="#系统启动过程" class="headerlink" title="系统启动过程"></a>系统启动过程</h3><p>1、Linux 启动流程图<br><img src="/upload_image/linux_boot_process.png" alt="启动流程图" title="启动流程图"></p>
<p>当按下开机键以后，主板上的 BIOS 芯片就会进行自检，自检完成后它会加载 MBR（即主引导记录，它里面保存着启动引导程序。在 Linux 中启动引导程序是 grub ，grub 保存在 MBR 中，grub 是系统启动主要的引导程序） 。紧接着判断式单系统还是多系统，单系统直接启动，多系统让用户选择要启动哪个系统，最终都会加载需要启动的操作系统的内核（这里的内核是一个压缩的内核），然后启动就会往下一步走。内核解压并进行自检，如果是 Linux，Linux 一般信任的是 Linux 内核自检，会把内核的自检过程记录在 dmesg。内核加载之后，就需要由内核去加载驱动（注意：只要内核安装完成，所有的驱动都装在内核当中，内核会根据硬件自动判断需要哪个驱动并进行加载，这点不同于 Windows。注意，内核中只保留了常见的驱动，把不常见的驱动作为函数模块，即把驱动写成一个程序，保存在硬盘里，一般放在 /lib 目录下，当需要的时候内核直接去该目录下去读取，这样保证了内核不会太大）。</p>
<p>2、注意：boot 这个分区不是由内核直接加载的，而是由启动引导程序事前就已经读取出来的，即启动引导程序默认是可以识别 boot 分区的。initramfs 内存文件系统，其作用是可以通过启动引导程序加载到内存中，然后加载启动过程中所需的内核模块，比如 USB、SATA、SCSI 硬盘的驱动和 LVM、RAID 文件系统的驱动。可以在 /boot 目录下看到该文件。</p>
<p>3、打开 initramfs 文件操作步骤<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看文件类型</span><br><span class="line">file initramfs*.img</span><br><span class="line"># 提取文件</span><br><span class="line">cpio -ivcdu &lt; initramfs*.img</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 入门总结(十七)</title>
    <url>/2018/11/06/Linux-2018-11-06-Linux%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93-%E5%8D%81%E4%B8%83/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Linux 入门总结(十七) —— 备份与恢复 </blockquote>

<a id="more"></a>
<h2 id="备份概述"><a href="#备份概述" class="headerlink" title="备份概述"></a>备份概述</h2><p>1、Linux 系统常见需要备份的数据<br>/root/目录、/home/目录、/var/spool/mail/目录、/etc/目录、其他目录。</p>
<p>2、备份策略</p>
<blockquote>
<p>完全备份：就是指把所有需要备份的数据全部备份，当然完全备份可以备份整块硬盘，整个分区或某个具体的目录。</p>
</blockquote>
<blockquote>
<p>增量备份：即每次备份的都是基于上一次备份新增的数据。节省空间，但恢复的时候比较费劲。</p>
</blockquote>
<blockquote>
<p>差异备份：每次备份都是基于第一次的完全备份。属于折中的办法。</p>
</blockquote>
<h2 id="dump-和-restore-命令"><a href="#dump-和-restore-命令" class="headerlink" title="dump 和 restore 命令"></a>dump 和 restore 命令</h2><p>Linux 中常见的增量备份工具 dump 和 恢复工具 restore。</p>
<p>1、dump 命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    dump [选项] 备份之后的文件名 原文件或目录</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -level     就是我们说的 0-9 十个备份级别，0 表示完全备份，1 表示第一次增量备份，依次类推</span><br><span class="line">    -f 文件名   指定备份之后的文件名</span><br><span class="line">    -u         备份成功之后，把备份时间记录在 /etc/dumpdates 文件</span><br><span class="line">    -v         显示备份过程中更多的输出信息</span><br><span class="line">    -j         调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式</span><br><span class="line">    -W         显示允许被 dump 的分区的备份等级及备份时间</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    1、备份分区</span><br><span class="line">    # 先执行一次完全备份，并压缩和更新备份时间</span><br><span class="line">    dump -0uj -f /root/boot.bak.bz2 /boot/</span><br><span class="line">    # 查看备份时间文件</span><br><span class="line">    cat /etc/dumpdates</span><br><span class="line">    # 修改 /boot 分区</span><br><span class="line">    cp install.log /boot/</span><br><span class="line">    # 增量备份 /boot 分区，并压缩</span><br><span class="line">    dump -1uj -f /root/boot.bak1.bz2 /boot/</span><br><span class="line">    # 查询分区的设备时间及备份级别</span><br><span class="line">    dump -W</span><br><span class="line"></span><br><span class="line">    2、备份文件或目录</span><br><span class="line">    # 完全备份 /etc 目录，注意目录和文件只能使用 0 级别进行完全备份，而不再支持增量备份</span><br><span class="line">    # 注意：dump 命令只有备份分区的时候才可以使用增量备份</span><br><span class="line">    dump -0j -f /root/etc.dump.bz2 /etc</span><br></pre></td></tr></table></figure></p>
<p>注意：CentOS 7.0 之后开始选择 XFS 作为默认的文件系统。dump 命令只能针对 ext 文件系统使用，而要对 xfs 文件系统进行增量备份，则需要使用 xfsdump 命令。</p>
<p>2、restore 命令</p>
<p>restore 命令主要用于还原 dump 命令增量备份后的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    restore [模式选项] [选项]</span><br><span class="line"></span><br><span class="line">模式选项：restore 命令常用的模式有以下四种，这四个模式不能混用。</span><br><span class="line">    -C   比较备份数据和实际数据的变化</span><br><span class="line">    -i   进入交互模式，手工选择需要恢复的文件</span><br><span class="line">    -t   查看模式，用于查看备份文件中拥有哪些数据</span><br><span class="line">    -r   还原模式，用于数据还原</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -f   指定备份文件的文件名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j 日志总结</title>
    <url>/2018/07/14/Other-2018-07-27-Log4j%E6%97%A5%E5%BF%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> Log4j 日志总结 </blockquote>

<a id="more"></a>
<h2 id="1-日志组件"><a href="#1-日志组件" class="headerlink" title="1.日志组件"></a>1.日志组件</h2><p><strong>Loggers「记录器」</strong>：Logger 负责捕捉事件并将其发送给合适的 Appender。  </p>
<p><strong>Appenders「输出源」</strong>：也被称为 Handlers，负责将日志事件记录到目标位置。在将日志事件输出之前， Appenders 使用 Layouts 来对事件进行格式化处理。  </p>
<p><strong>Layouts「布局」</strong>：也被称为 Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts 决定了数据在一条日志记录中的最终形式。</p>
<p>当 Logger 记录一个事件时，它将事件转发给适当的 Appender。然后 Appender 使用 Layout 来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。另外，Filters 可以让你进一步指定一个 Appender 是否可以应用在一条特定的日志记录上。在日志配置中，Filters 并不是必需的，但可以让你更灵活地控制日志消息的流动。</p>
<h2 id="2-日志系统"><a href="#2-日志系统" class="headerlink" title="2.日志系统"></a>2.日志系统</h2><p>日志系统：日志的具体实现。Java 的常见的日志系统有 Log4j、jdk-jul「即：java.util.logging」、logback 等，这些日志系统各自独立，编程方式也不一致。如果你一个系统要用到多个「框架库」，而这些框架库又可能要用不同的「日志系统」，那么你一个系统中就得使用多套日志系统，那多套日志系统如何融合在一起是个很大的问题。</p>
<h2 id="3-日志框架"><a href="#3-日志框架" class="headerlink" title="3.日志框架"></a>3.日志框架</h2><p>那么如何解决呢？进行抽象，抽象出一个接口层，对每个日志实现都适配或者转接，这样这些提供给别人的库都直接使用抽象层即可，不需要关注具体的日志实现。常见的日志抽象出来的框架有 Apache commons-logging 和 slf4j。抽象层可以让我们更加容易地改变项目现有的日志框架，或者集成那些使用了不同日志框架的项目。</p>
<h2 id="4-日志故事"><a href="#4-日志故事" class="headerlink" title="4.日志故事"></a>4.日志故事</h2><p>这里有个故事：最新是开源社区提供了 commons-logging 抽象，被称为 JCL 日志框架「JCL，全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”」，出色地完成了兼容主流的日志实现「log4j、JUL、simplelog」，基本一统江湖，就连顶顶大名的 spring 也是依赖了 JCL。</p>
<p>看起来事物确实是美好，但是美好的日子不长，接下来另一个优秀的日志框架 slf4j 的加入导致了更加混乱的场面。比较巧的是 slf4j 的作者(Ceki Gülcü)就是 log4j 的作者，他觉得 JCL 不够优秀，所以他要自己搞一套更优雅的出来，于是 slf4j 日志体系诞生了，并为 slf4j 实现了一个亲子 —— logback，确实更加优雅。</p>
<p>但是由于之前很多代码库已经使用 JCL，虽然出现 slf4j 和 JCL 之间的桥接转换，但是集成的时候问题依然多多，对很多新手来说确实会很懊恼，因为比单独的 log4j 时代“复杂”多了，可以关注下这个，抱怨声确实很多。到此本来应该完了，但是 Ceki Gülcü 觉得还是得回头拯救下自己的 “大阿哥” —— log4j，于是 log4j2 诞生了，同样 log4j2 也参与到了 slf4j 日志体系中。日志体系的江湖又将面临血雨腥风的混乱了。</p>
<h2 id="5-Loggers-组件"><a href="#5-Loggers-组件" class="headerlink" title="5.Loggers 组件"></a>5.Loggers 组件</h2><p>Loggers 组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL      0  </span><br><span class="line">ERROR      3  </span><br><span class="line">WARN       4  </span><br><span class="line">INFO       6  </span><br><span class="line">DEBUG      7</span><br></pre></td></tr></table></figure></p>
<p>Log4j 有一个规则：只输出级别不低于设定级别的日志信息，假设 Loggers 级别设定为INFO，则 INFO、WARN、ERROR 和 FATAL 级别的日志信息都会输出，而级别比 INFO 低的 DEBUG 则不会输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Logger 对象</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-Appenders-组件"><a href="#6-Appenders-组件" class="headerlink" title="6.Appenders 组件"></a>6.Appenders 组件</h2><p>Appenders 为日志输出目的地，如控制台「Console」、文件「Files」等，还可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。Log4j 提供的 appenders 有以下几种：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.log4j.ConsoleAppender「控制台」</span><br><span class="line">org.apache.log4j.FileAppender「文件」</span><br><span class="line">org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」</span><br><span class="line">org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」</span><br><span class="line">org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」</span><br></pre></td></tr></table></figure></p>
<p>配置模式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.appender.appenderName = className</span><br><span class="line">log4j.appender.appenderName.Option1 = value1</span><br><span class="line">......</span><br><span class="line">log4j.appender.appenderName.OptionN = valueN</span><br></pre></td></tr></table></figure></p>
<h2 id="7-Layouts-指定日志输出格式"><a href="#7-Layouts-指定日志输出格式" class="headerlink" title="7.Layouts 指定日志输出格式"></a>7.Layouts 指定日志输出格式</h2><p>Layouts 指定日志输出格式。Layouts 提供四种日志输出样式：HTML样式、自由指定样式、包含日志级别与信息的样式、包含日志时间、线程、类别等信息的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.log4j.HTMLLayout「以HTML表格形式布局」</span><br><span class="line">org.apache.log4j.PatternLayout「可以灵活地指定布局模式」</span><br><span class="line">org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」</span><br><span class="line">org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」</span><br></pre></td></tr></table></figure>
<p>配置模式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.appender.appenderName.layout = className</span><br><span class="line">log4j.appender.appenderName.layout.Option1 = value1</span><br><span class="line">......</span><br><span class="line">log4j.appender.appenderName.layout.OptionN = valueN</span><br></pre></td></tr></table></figure></p>
<h2 id="8-配置详解"><a href="#8-配置详解" class="headerlink" title="8.配置详解"></a>8.配置详解</h2><p>在实际应用中，要使 Log4j 在系统中运行须事先设定配置文件。配置文件事实上也就是对 Logger、Appender 及 Layout 进行相应设定。Log4j 支持两种配置文件格式:</p>
<ul>
<li>一种是 XML 格式的文件。</li>
<li>一种是 properties 属性文件。</li>
</ul>
<p>下面以 properties 属性文件为例介绍 log4j.properties 的配置。</p>
<h3 id="8-1-配置根记录器-Logger"><a href="#8-1-配置根记录器-Logger" class="headerlink" title="8.1 配置根记录器 Logger"></a>8.1 配置根记录器 Logger</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger = [level], appenderName1, appenderName2, ......  </span><br><span class="line"># false：表示 Logger 不会在父 Logger 的 appender 里输出，默认为 true。</span><br><span class="line">log4j.additivity.org.apache = false;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>level</strong>：设定日志记录的最低级别，可设的值有 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 或者自定义的级别，Log4j 建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO 级别，则应用程序中所有 DEBUG 级别的日志信息将不会被打印出来。</li>
<li><strong>appendName</strong>：指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger＝INFO, A1, B2, C3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-2-配置输出目的地-appender"><a href="#8-2-配置输出目的地-appender" class="headerlink" title="8.2 配置输出目的地 appender"></a>8.2 配置输出目的地 appender</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># appenderName：自定义 appderName，在 log4j.rootLogger 设置中使用。</span><br><span class="line">log4j.appender.appenderName = className</span><br></pre></td></tr></table></figure>
<p>className 可以设如下值：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ConsoleAppender 选项</span><br><span class="line"># Threshold = WARN：指定日志信息的最低输出级别，默认为 DEBUG。</span><br><span class="line"># ImmediateFlush = true：表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true。</span><br><span class="line"># Target = System.err：默认值是 System.out。</span><br><span class="line">org.apache.log4j.ConsoleAppender「控制台」</span><br><span class="line"></span><br><span class="line"># FileAppender 选项</span><br><span class="line"># Threshold = WARN「同上」</span><br><span class="line"># ImmediateFlush = true「同上」</span><br><span class="line"># Append = false：true 表示消息增加到指定文件中，false 则将消息覆盖指定的文件内容，默认值是 true。</span><br><span class="line"># File = D:/logs/logging.log4j：指定消息输出到 D:/logs/logging.log4j 文件中。也可以使用相对路径。</span><br><span class="line">org.apache.log4j.FileAppender「文件」</span><br><span class="line"></span><br><span class="line"># DailyRollingFileAppender 选项</span><br><span class="line"># Threshold = WARN「同上」</span><br><span class="line"># ImmediateFlush = true「同上」</span><br><span class="line"># Append = false「同上」</span><br><span class="line"># File = D:/logs/logging.log4j「同上」</span><br><span class="line"># encoding = UTF-8 指定输出内容所采用的字符集</span><br><span class="line"># DatePattern = '.'yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。</span><br><span class="line">org.apache.log4j.DailyRollingFileAppender「每天产生一个日志文件」</span><br><span class="line"></span><br><span class="line"># RollingFileAppender 选项</span><br><span class="line"># Threshold = WARN「同上」</span><br><span class="line"># ImmediateFlush = true「同上」</span><br><span class="line"># Append = false「同上」</span><br><span class="line"># File = D:/logs/logging.log4j「同上」</span><br><span class="line"># MaxFileSize = 100KB：后缀可以是 KB, MB 或者 GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到 logging.log4j.1 文件中。</span><br><span class="line">org.apache.log4j.RollingFileAppender「文件大小到达指定尺寸的时候产生一个新的文件」</span><br><span class="line"></span><br><span class="line">org.apache.log4j.WriterAppender「将日志信息以流格式发送到任意指定的地方」</span><br></pre></td></tr></table></figure></p>
<p>注意：配置消息输出路径的时候，可以使用相对路径，这里的相对路径的参照点为服务器的目录。如：log4j.appender.file.File =  ../logs/info.log 该日志系统运行在 Tomcat 服务器上，所以其对应的绝对地址为：服务器 Tomcat 的绝对路径 + ../logs/info.log。</p>
<h3 id="8-3-配置输出格式-Layout"><a href="#8-3-配置输出格式-Layout" class="headerlink" title="8.3 配置输出格式 Layout"></a>8.3 配置输出格式 Layout</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.appender.appenderName.layout = className</span><br></pre></td></tr></table></figure>
<p>className 可以设如下值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># LocationInfo = true：输出 java 文件名称和行号，默认值是 false。</span><br><span class="line"># Title = My Logging： 默认值是 Log4J Log Messages。</span><br><span class="line">org.apache.log4j.HTMLLayout「以HTML表格形式布局」</span><br><span class="line"></span><br><span class="line"># ConversionPattern = %m%n：设定以怎样的格式显示消息。</span><br><span class="line">org.apache.log4j.PatternLayout「可以灵活地指定布局模式」</span><br><span class="line"></span><br><span class="line">org.apache.log4j.SimpleLayout「包含日志信息的级别和信息字符串」</span><br><span class="line"></span><br><span class="line">org.apache.log4j.TTCCLayout「包含日志产生的时间、线程、类别等等信息」</span><br></pre></td></tr></table></figure>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.jianshu.com/p/ca3d96e64607" target="_blank" rel="noopener">Java Log 日志</a><br><a href="https://www.jianshu.com/p/9fca47678ba4" target="_blank" rel="noopener">log4j 详细介绍</a><br><a href="http://blog.51cto.com/houenxun/1316871" target="_blank" rel="noopener">日志系统和日志框架</a><br><a href="https://www.jianshu.com/p/ccafda45bcea" target="_blank" rel="noopener">Log4j.properties 配置详解-简书</a><br><a href="https://blog.csdn.net/mahoking/article/details/53820671" target="_blank" rel="noopener">log4j.properties 配置详解-CSDN</a><br><a href="https://blog.csdn.net/phil_jing/article/details/52789655" target="_blank" rel="noopener">为什么 logger 要声明为 static final</a></p>
]]></content>
  </entry>
  <entry>
    <title>推荐阅读</title>
    <url>/2018/09/20/Personal-2018-09-20-%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote class="blockquote-center"> 记录在工作学习个人认为优秀的博客 </blockquote>

<a id="more"></a>
<p>1、<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p>
<p>2、<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>
<p>3、<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux 命令大全</a></p>
<p>4、<a href="https://coolshell.cn/" target="_blank" rel="noopener">左耳朵耗子</a></p>
<p>5、<a href="https://legacy.gitbook.com/explore?lang=zh" target="_blank" rel="noopener">GitBook</a></p>
]]></content>
      <categories>
        <category>个人思考</category>
      </categories>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
</search>
